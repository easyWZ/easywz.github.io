

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/index/bk.png">
  <link rel="icon" href="/img/index/bk.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="汪邹">
  <meta name="keywords" content="">
  
    <meta name="description" content="前端八股文">
<meta property="og:type" content="article">
<meta property="og:title" content="前端八股文">
<meta property="og:url" content="https://easywz.github.io/2024/02/19/Interview/frontInterviewQuestion/index.html">
<meta property="og:site_name" content="WZ&#39;s blog">
<meta property="og:description" content="前端八股文">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://easywz.github.io/img/index/bagu.jpeg">
<meta property="article:published_time" content="2024-02-19T03:18:14.000Z">
<meta property="article:modified_time" content="2025-09-03T06:49:03.451Z">
<meta property="article:author" content="汪邹">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://easywz.github.io/img/index/bagu.jpeg">
  
  
  
  <title>前端八股文 - WZ&#39;s blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"easywz.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>人生在勤，不索何获</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/cover/homeBg.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="前端八股文"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-02-19 11:18" pubdate>
          2024年2月19日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          16k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          130 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">前端八股文</h1>
            
              <p id="updated-time" class="note note-info" style="">
                
                  
                    本文最后更新于 2025年9月3日 下午
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ol>
<li><a href="#question1">js的数据类型及他们的区别</a></li>
<li><a href="#question2">判断数据类型的几种方法</a></li>
<li><a href="#question3">作用域和作用域链</a></li>
<li><a href="#question4">原型和原型链</a></li>
<li><a href="#question5">闭包</a></li>
<li><a href="#question6">内存泄漏，垃圾回收机制</a></li>
<li><a href="#question7">js获取dom</a></li>
<li><a href="#question8">浅拷贝和深拷贝</a></li>
<li><a href="#question9">route和router的区别详解</a></li>
<li><a href="#question10">如何改变this指向（call，apply，bind区别）</a></li>
<li><a href="#question11">箭头函数与普通函数区别</a></li>
<li><a href="#question12">浏览器存储的区别</a></li>
<li><a href="#question13">继承方式</a></li>
<li><a href="#question14">常用的数组方法</a></li>
<li><a href="#question15">什么是promise</a></li>
<li><a href="#question16">async，await</a></li>
<li><a href="#question17">宏任务和微任务以及执行顺序</a></li>
<li><a href="#question18">var let const的区别</a></li>
<li><a href="#question19">ES6的新特性</a></li>
<li><a href="#question20">从浏览器输入url后都经历了什么</a></li>
<li><a href="#question21">TCP协议和HTTP协议</a></li>
<li><a href="#question22">http和https区别</a></li>
<li><a href="#question23">如何解决前端跨域问题</a></li>
<li><a href="#question24">websocket和webwork</a></li>
<li><a href="#question25">性能优化</a></li>
<li><a href="#question26">Webpack是什么</a></li>
<li><a href="#question27">Webpack的基本功能？</a></li>
<li><a href="#question28">标准盒模型和怪异盒模型（IE盒模型）</a></li>
<li><a href="#question29">让一个元素水平&#x2F;垂直居中</a></li>
<li><a href="#question30">flex：1代表什么</a></li>
<li><a href="#question31">回溯算法</a></li>
<li><a href="#question32">冒泡算法排序</a></li>
<li><a href="#question33">快速排序</a></li>
<li><a href="#question34">什么是MVVM，MVC模型</a></li>
<li><a href="#question35">写react&#x2F;vue项目中为什么要在列表组件中写key，其作用是什么</a></li>
<li><a href="#question36"><code>[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;].map(parseInt)</code></a></li>
<li><a href="#question37">防抖和节流的区别和实现</a></li>
<li><a href="#question38">Set,Map.WeakSet和WeakMap的区别</a></li>
<li><a href="#question39">深度优先遍历和广度优先遍历的实现</a></li>
<li><a href="#question40">分别用深度优先思想和广度优先思想实现一个拷贝函数</a></li>
<li><a href="#question41">ES5&#x2F;ES6的继承除了写法之外还有什么区别</a></li>
<li><a href="#question42">setTimeout,Promise,Async&#x2F;Await的区别</a></li>
<li><a href="#question43">Async&#x2F;Await如何通过同步的方式实现异步</a></li>
<li><a href="#question44">JS异步解决方案的发展历程以及优缺点</a></li>
<li><a href="#question45">Promise构造函数是同步执行还是异步执行，then呢</a></li>
<li><a href="#question46">如何实现一个new</a></li>
<li><a href="#question47">简单阐述http2的多路复用</a></li>
<li><a href="#question48">TCP的三次握手和四次挥手</a></li>
<li><a href="#question49">A，B机器正常连接后，B机器突然重启，A处于TCP什么状态</a></li>
<li><a href="#question50">react中setState什么时候是同步的，什么时候是异步的</a></li>
<li><a href="#question51">npm模块安装机制，为什么输入npm install就可以自动安装对应的</a></li>
<li><a href="#question52">重绘和回流及如何优化</a></li>
<li><a href="#question53">观察者模式和订阅-发布模式区别，各自适用什么场景</a></li>
<li><a href="#question54">Redux和Vuex的设计思想</a></li>
<li><a href="#question55">浏览器和Node事件循环的区别</a></li>
<li><a href="#question56">介绍模块化发展历程</a></li>
<li><a href="#question57">全局作用域中，用const和let声明的变量不在window上，那到底在哪</a></li>
<li><a href="#question58">cookie和token都存放在header中，为什么不会劫持token</a></li>
<li><a href="#question59">强制缓存和协商缓存</a></li>
<li><a href="#question60">DOCTYPE有什么作用？</a></li>
<li><a href="#question61">img标签的title和alt属性有什么区别</a></li>
<li><a href="#question62">简述一下src与href的区别</a></li>
<li><a href="#question63">iframe有哪些优缺点？</a></li>
<li><a href="#question64">常用的meta标签有哪些？</a></li>
<li>H5和H4有什么不同？</li>
<li>SVG和CANVAS的区别</li>
<li>defer 和 async 的区别 ?</li>
<li>style标签prefetch和preload区别？</li>
<li>CSS 属性是否区分大小写？</li>
<li>CSS的盒模型?</li>
<li>link与@import的区别</li>
<li>元素垂直居中的方式有哪些？</li>
<li>文本垂直居中的方式有哪些？</li>
<li>CSS 选择器的优先级是如何计算的？</li>
<li>请阐述块格式化上下文（Block Formatting Context）、工作原理以及形成条件？</li>
<li>请阐述z-index属性，并说明如何形成层叠上下文（stacking context）</li>
<li>CSS 有哪些继承属性？</li>
<li>有哪些清除浮动的技术，都适用哪些情况？</li>
<li>响应式布局有哪些</li>
<li>讲一下三栏布局实现？圣杯布局、双飞翼布局和flex布局</li>
<li>使用过哪些CSS预处理器？它们有什么优劣？</li>
<li>如何解决CSS样式在不同浏览器中的兼容性问题？</li>
<li>如何制作一个自适应的正方形？</li>
<li>讲讲margin塌陷和margin合并以及解决方案？</li>
<li>如何实现一个三角形？</li>
<li>如何画一条0.5px的线</li>
<li>视差滚动效果的原理？</li>
<li>js有哪些内置对象？</li>
<li>什么是闭包？</li>
<li>如何理解作用域、作用域链和执行上下文？</li>
<li>如何理解原型链？</li>
<li>let const var比较</li>
<li>谈谈你对变量提升的理解</li>
<li>JSON.stringify有什么缺点？</li>
<li>for…in 和 for…of的区别?</li>
<li>new操作符都做了什么</li>
<li>类数组和数组的区别，dom 的类数组如何转换成数组</li>
<li>offsetWidth&#x2F;offsetHeight，clientWidth&#x2F;clientHeight 与 scrollWidth&#x2F;scrollHeight 的区别</li>
<li>mouseover&#x2F;mouseout 与 mouseenter&#x2F;mouseleave 的区别与联系</li>
<li>event.stopPropagation()与event.stopImmediatePropagation的区别</li>
<li>说一下事件循环机制Event Loop</li>
<li>esm和commonjs的区别</li>
<li>解释下JavaScript栈内存和堆内存？</li>
<li>箭头函数与普通函数区别？</li>
<li>箭头函数的this是声明时确定还是调用时确定？</li>
<li>isNaN与Number.isNaN的区别</li>
</ol>
<h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><hr>
<ol>
<li><a id="question1"><strong>Js的数据类型有哪些他们的区别是什么</strong></a><ol>
<li>基本数据类型(存储在内存中<ol>
<li>String</li>
<li>Number</li>
<li>Boolean</li>
<li>Null</li>
<li>undefined</li>
<li>Symbol</li>
</ol>
</li>
<li>引用数据类型（存储的是对象在内存中的地址<ol>
<li>Object</li>
<li>Array</li>
<li>Date</li>
<li>Function</li>
</ol>
</li>
<li>区别<ol>
<li>存储方式：基本数据类型直接存储数据值，而引用数据类型存储的是对象的引用</li>
<li>内存占用：基本数据类型占用固定的内存空间，而引用数据类型的大小取决于对象的大小。</li>
<li>赋值方式：基本数据类型的赋值是通过将值直接复制给变量，而引用数据类型的赋值是将对象的引用赋给变量。</li>
<li>传递方式：基本数据类型作为参数传递时，传递的是值的副本，而引用数据类型作为参数传递时，传递的是引用的副本。</li>
</ol>
</li>
</ol>
</li>
</ol>
<hr>
<ol start="2">
<li><a id="question2"><strong>判断数据类型有几种方法</strong></a><ol>
<li><strong>typeof</strong><ol>
<li>其中typeof返回的类型都是字符串形式</li>
<li>缺点：typeof null的值为Object，无法分辨是null还是Object</li>
<li><code>alert(typeof &quot;helloworld&quot;)</code></li>
</ol>
</li>
<li><strong>instanceof</strong><ol>
<li>instanceof 后面一定要是对象类型，并且大小写不能错，该方法适合一些条件选择或分支。</li>
<li><code>[1,2,3] instanceof Array </code></li>
</ol>
</li>
<li><strong>Object.prototype.toString.call</strong><ol>
<li>（适用于所有类型的判断检测,注意区分大小写. toString方法,在Object原型上返回数据格式,）</li>
<li><code>console.log(Object.prototype.toString.call(&quot;123&quot;))           --------&gt;[object String]</code></li>
</ol>
</li>
<li><strong>constructor</strong><ol>
<li>constructor 判断方法跟instanceof相似,但是constructor检测Object与instanceof不一样,constructor还可以处理基本数据类型的检测,不仅仅是对象类型</li>
<li><code>console.log(A.constructor === B)</code></li>
</ol>
</li>
<li><strong>jquery.type()</strong><ol>
<li>如果对象是null跟undefined,直接返回”null”和”undefined”,</li>
<li><code>console.log(jQuery.type(undefined) === &quot;undefined&quot;)           --------&gt;true</code></li>
</ol>
</li>
<li><strong>&#x3D;&#x3D;&#x3D;</strong><ol>
<li>有局限的判断:严格运算符&#x3D;&#x3D;&#x3D;</li>
</ol>
</li>
<li>总结<ol>
<li>一般变量用typeof</li>
<li>已知对象类型用instanceof</li>
<li>通用方法Object.prototype.toString.call()</li>
</ol>
</li>
</ol>
</li>
</ol>
<hr>
<ol start="3">
<li><a id="question3"><strong>作用域和作用域链</strong></a><ol>
<li>作用域：规定变量和函数的可使用范围称作作用域</li>
<li>作用域链：每个函数都有一个作用域链，查找变量或者函数时，需要从局部作用域到全局作用域依次查找，这些作用域的集合称作作用域链</li>
</ol>
</li>
</ol>
<hr>
<ol start="4">
<li><a id="question4"><strong>原型和原型链</strong></a><ol>
<li>原型：<ol>
<li>原型分为隐式原型和显式原型，每个对象都有一个隐式原型，它指向自己的构造函数的显式原型</li>
<li>在 JavaScript 中，每当定义一个对象（函数也是对象）时候，对象中都会包含一些预定义的属性。其中每个函数对象都有一个prototype 属性，这个属性指向函数的原型对象，使用原型对象的好处是所有对象实例共享它所包含的属性和方法</li>
</ol>
</li>
<li>原型链：<ol>
<li>当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，于是就这样一直找下去，也就是我们平时所说的原型链的概念</li>
<li>每个对象拥有一个原型对象，通过 proto 指针指向其原型对象，并从中继承方法和属性，同时原型对象也可能拥有原型，这样一层一层，最终指向 null(Object.proptotype.__proto__指向的是null)。这种关系被称为原型链，通过原型链一个对象可以拥有定义在其他对象中的属性和方法</li>
</ol>
</li>
<li>原型和原型链的区别<ol>
<li>原型是为了实现对象间的联系，解决构造函数无法数据共享而引入的一个属性，而原型链是一个实现对象间联系即继承的主要方法</li>
</ol>
</li>
</ol>
</li>
<li><a id="question5">什么是闭包</a><ol>
<li>JS中内层函数可以访问外层函数的变量，使内部私有变量不受外界干扰，起到保护和保存的作用，我们把这个特性称作闭包。</li>
<li>好处<ol>
<li>隔离作用域，保护私有变量；有了闭包才有局部变量，要不然都是全局变量了。</li>
<li>让我们可以使用回调，操作其他函数内部；</li>
<li>变量长期驻扎在内存中，不会被内存回收机制回收，即延长变量的生命周期；</li>
</ol>
</li>
<li>坏处<ol>
<li>内层函数引用外层函数变量，内层函数占用内存。如果不释放内存，过多时，易引起内存泄露</li>
</ol>
</li>
<li>引用场景<ol>
<li>for循环中的保留i的操作 </li>
<li>防抖和节流</li>
</ol>
</li>
</ol>
</li>
<li><a id="question6">内存泄露、垃圾回收机制</a><ol>
<li>内存泄露：是指不再用的内存没有被及时释放出来，导致该段内存无法被使用就是内存泄漏，内存泄漏指我们无法在通过js访问某个对象，而垃圾回收机制却认为该对象还在被引用，因此垃圾回收机制不会释放该对象，导致该块内存永远无法释放，积少成多，系统会越来越卡以至于崩溃。</li>
<li>垃圾回收机制：就是垃圾收集器按照固定的时间间隔，周期性地寻找那些不再使用的变量，然后将其清除或释放内存。（标记清除&#x2F;引用计数）</li>
</ol>
</li>
<li><a id="question7">Js获取dom</a><ol>
<li>getElementById</li>
<li>getElementByClassName</li>
<li>getElementByTagName</li>
<li>querySelector</li>
<li>querySelectorAll</li>
</ol>
</li>
<li><a id="question8">浅拷贝与深拷贝</a><ol>
<li>浅拷贝<ol>
<li><strong>Object.assign()</strong><ol>
<li><code>Object.assign(target, ...sources)</code></li>
</ol>
</li>
<li><strong>…</strong><ol>
<li><code>let objClone = &#123; ...obj &#125;;</code></li>
</ol>
</li>
<li>Array.prototype.<strong>concat</strong>()拷贝数组</li>
<li>Array.prototype.<strong>slice</strong>()拷贝数组</li>
<li>手动实现 <figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-function">function <span class="hljs-title">shallowClone</span><span class="hljs-params">(<span class="hljs-keyword">target</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (typeof <span class="hljs-keyword">target</span> === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; <span class="hljs-keyword">target</span> !== <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">const</span> cloneTarget = Array.isArray(<span class="hljs-keyword">target</span>) ? [] : &#123;&#125;;<br>        <span class="hljs-keyword">for</span> (let prop in <span class="hljs-keyword">target</span>) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">target</span>.hasOwnProperty(prop)) &#123;<br>                cloneTarget[prop] = <span class="hljs-keyword">target</span>[prop];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cloneTarget;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">target</span>;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">// 测试</span><br><span class="hljs-keyword">const</span> shallowCloneObj = shallowClone(obj)<br><br>shallowCloneObj === obj  <span class="hljs-comment">// false，返回的是一个新对象</span><br>shallowCloneObj.arr === obj.arr  <span class="hljs-comment">// true，对于对象类型只拷贝了引用</span><br></code></pre></td></tr></table></figure></li>
</ol>
</li>
<li>深拷贝<ol>
<li><strong>JSON.parse(JSON.stringify(target));</strong></li>
<li><strong>递归基础版深拷贝</strong> <figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-function">function <span class="hljs-title">deepClone</span><span class="hljs-params">(<span class="hljs-keyword">target</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (typeof <span class="hljs-keyword">target</span> === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; <span class="hljs-keyword">target</span>) &#123;<br>        let cloneObj = &#123;&#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key in <span class="hljs-keyword">target</span>) &#123; <span class="hljs-comment">// 遍历</span><br>            <span class="hljs-keyword">const</span> val = <span class="hljs-keyword">target</span>[key]<br>            <span class="hljs-keyword">if</span> (typeof val === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; val) &#123;<br>                cloneObj[key] = deepClone(val) <span class="hljs-comment">// 是对象就再次调用该函数递归</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cloneObj[key] = val <span class="hljs-comment">// 基本类型的话直接复制值</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cloneObj<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">target</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 开头的测试obj存在循环引用，除去这个条件进行测试</span><br><span class="hljs-keyword">const</span> clonedObj = deepClone(obj)<br><br><span class="hljs-comment">// 测试</span><br>clonedObj === obj  <span class="hljs-comment">// false，返回的是一个新对象</span><br>clonedObj.arr === obj.arr  <span class="hljs-comment">// false，说明拷贝的不是引用</span><br></code></pre></td></tr></table></figure></li>
<li><strong>递归完美版深拷贝</strong> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepClone</span>(<span class="hljs-params">target</span>) &#123;<br>    <span class="hljs-comment">// WeakMap作为记录对象Hash表（用于防止循环引用）</span><br>    <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>()<br><br>    <span class="hljs-comment">// 判断是否为object类型的辅助函数，减少重复代码</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">isObject</span>(<span class="hljs-params">target</span>) &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">typeof</span> target === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; target ) || <span class="hljs-keyword">typeof</span> target === <span class="hljs-string">&#x27;function&#x27;</span><br>    &#125;<br><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">clone</span>(<span class="hljs-params">data</span>) &#123;<br><br>        <span class="hljs-comment">// 基础类型直接返回值</span><br>        <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isObject</span>(data)) &#123;<br>            <span class="hljs-keyword">return</span> data<br>        &#125;<br><br>        <span class="hljs-comment">// 日期或者正则对象则直接构造一个新的对象返回</span><br>        <span class="hljs-keyword">if</span> ([<span class="hljs-title class_">Date</span>, <span class="hljs-title class_">RegExp</span>].<span class="hljs-title function_">includes</span>(data.<span class="hljs-property">constructor</span>)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> data.<span class="hljs-title function_">constructor</span>(<span class="hljs-params">data</span>)<br>        &#125;<br><br>        <span class="hljs-comment">// 处理函数对象</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> data === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>(<span class="hljs-string">&#x27;return &#x27;</span> + data.<span class="hljs-title function_">toString</span>())()<br>        &#125;<br><br>        <span class="hljs-comment">// 如果该对象已存在，则直接返回该对象</span><br>        <span class="hljs-keyword">const</span> exist = map.<span class="hljs-title function_">get</span>(data)<br>        <span class="hljs-keyword">if</span> (exist) &#123;<br>            <span class="hljs-keyword">return</span> exist<br>        &#125;<br><br>        <span class="hljs-comment">// 处理Map对象</span><br>        <span class="hljs-keyword">if</span> (data <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Map</span>) &#123;<br>            <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()<br>            map.<span class="hljs-title function_">set</span>(data, result)<br>            data.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">val, key</span>) =&gt;</span> &#123;<br>                <span class="hljs-comment">// 注意：map中的值为object的话也得深拷贝</span><br>                <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isObject</span>(val)) &#123;<br>                    result.<span class="hljs-title function_">set</span>(key, <span class="hljs-title function_">clone</span>(val))<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    result.<span class="hljs-title function_">set</span>(key, val)<br>                &#125;<br>            &#125;)<br>            <span class="hljs-keyword">return</span> result<br>        &#125;<br><br>        <span class="hljs-comment">// 处理Set对象</span><br>        <span class="hljs-keyword">if</span> (data <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Set</span>) &#123;<br>            <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>()<br>            map.<span class="hljs-title function_">set</span>(data, result)<br>            data.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> &#123;<br>                <span class="hljs-comment">// 注意：set中的值为object的话也得深拷贝</span><br>                <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isObject</span>(val)) &#123;<br>                    result.<span class="hljs-title function_">add</span>(<span class="hljs-title function_">clone</span>(val))<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    result.<span class="hljs-title function_">add</span>(val)<br>                &#125;<br>            &#125;)<br>            <span class="hljs-keyword">return</span> result<br>        &#125;<br><br>        <span class="hljs-comment">// 收集键名（考虑了以Symbol作为key以及不可枚举的属性）</span><br>        <span class="hljs-keyword">const</span> keys = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownKeys</span>(data)<br>        <span class="hljs-comment">// 利用 Object 的 getOwnPropertyDescriptors 方法可以获得对象的所有属性以及对应的属性描述</span><br>        <span class="hljs-keyword">const</span> allDesc = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptors</span>(data)<br>        <span class="hljs-comment">// 结合 Object 的 create 方法创建一个新对象，并继承传入原对象的原型链， 这里得到的result是对data的浅拷贝</span><br>        <span class="hljs-keyword">const</span> result = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(data), allDesc)<br><br>        <span class="hljs-comment">// 新对象加入到map中，进行记录</span><br>        map.<span class="hljs-title function_">set</span>(data, result)<br><br>        <span class="hljs-comment">// Object.create()是浅拷贝，所以要判断并递归执行深拷贝</span><br>        keys.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123;<br>            <span class="hljs-keyword">const</span> val = data[key]<br>            <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isObject</span>(val)) &#123;<br>                <span class="hljs-comment">// 属性值为 对象类型 或 函数对象 的话也需要进行深拷贝</span><br>                result[key] = <span class="hljs-title function_">clone</span>(val)<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                result[key] = val<br>            &#125;<br>        &#125;)<br>        <span class="hljs-keyword">return</span> result<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">clone</span>(target)<br>&#125;<br><br><span class="hljs-comment">// 测试</span><br><span class="hljs-keyword">const</span> clonedObj = <span class="hljs-title function_">deepClone</span>(obj)<br>clonedObj === obj  <span class="hljs-comment">// false，返回的是一个新对象</span><br>clonedObj.<span class="hljs-property">arr</span> === obj.<span class="hljs-property">arr</span>  <span class="hljs-comment">// false，说明拷贝的不是引用</span><br>clonedObj.<span class="hljs-property">func</span> === obj.<span class="hljs-property">func</span>  <span class="hljs-comment">// false，说明function也复制了一份</span><br>clonedObj.<span class="hljs-property">proto</span>  <span class="hljs-comment">// proto，可以取到原型的属性</span><br></code></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
<li><a id="question9">route和router的区别详解</a><ol>
<li>router是用来操作路由的</li>
<li>route是用来获取路由信息的。 $route.path $route.params route.query等</li>
</ol>
</li>
<li><a id="question10">如何改变this指向（call、apply与bind区别）</a><ol>
<li>call、bind、apply 都是 JavaScript 中用于改变函数执行上下文（即 this 指向）的方法。</li>
<li>传参 call、bind可以传递无数个参数，apply只有两个参数，第二个参数为数组</li>
<li>返回 call和apply方法是直接调用函数并改变函数上下文，而bind方法则是返回一个新函数，稍后调用时绑定指定的上下文。</li>
</ol>
</li>
<li><a id="question11">箭头函数和普通函数的区别</a><ol>
<li>箭头函数是普通函数的简写，但是它不具备很多普通函数的特性</li>
<li>箭头函数都是匿名函数</li>
<li>箭头函数的 this 永远指向其上下文的 this ，任何方法都改变不了其指向，如 call() , bind() , apply();普通函数的this指向调用它的那个对象</li>
<li>没有arguments对象，不能使用arguments,取而代之用rest参数…解决</li>
<li>不会进行函数提升</li>
<li>箭头函数不能用于构造函数，不能使用new</li>
</ol>
</li>
<li><a id="question12">浏览器存储，他们的区别？</a><ol>
<li>localStorage：永久保存，以键值对保存，存储空间5M</li>
<li>sessionStorage：关闭页签&#x2F;浏览器时清空</li>
<li>cookie：随着请求发送，通过设置过期时间删除</li>
<li>session：保存在服务端</li>
<li>ocalStorage&#x2F;sessionStorage是window的属性，cookie是document的方法</li>
</ol>
</li>
<li><a id="question13">继承方式有哪些</a><ol>
<li><strong>原型链继承</strong><ol>
<li>code <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent1</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;parent1&#x27;</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">play</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child1</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">type</span> = <span class="hljs-string">&#x27;child2&#x27;</span>;<br>&#125;<br><span class="hljs-title class_">Child1</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parent1</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Child1</span>());<br></code></pre></td></tr></table></figure></li>
<li>因为两个实例使用的是同一个原型对象。它们的内存空间是共享的，当一个发生变化的时候，另外一个也随之进行了变化，这就是使用原型链继承方式的一个缺点。</li>
</ol>
</li>
<li><strong>构造函数继承（借助 call）</strong><ol>
<li>code <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent1</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;parent1&#x27;</span>;<br>&#125;<br>         <br><span class="hljs-title class_">Parent1</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;<br>&#125;<br>         <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child1</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-title class_">Parent1</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>);<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">type</span> = <span class="hljs-string">&#x27;child1&#x27;</span><br>&#125;<br>         <br><span class="hljs-keyword">let</span> child = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child1</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child);  <span class="hljs-comment">// 没问题</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child.<span class="hljs-title function_">getName</span>());  <span class="hljs-comment">// 会报错</span><br></code></pre></td></tr></table></figure></li>
<li>它使父类的引用属性不会被共享，优化了第一种继承方式的弊端；但是随之而来的缺点也比较明显——只能继承父类的实例属性和方法，不能继承原型属性或者方法。</li>
</ol>
</li>
<li><strong>组合继承（前两种组合）</strong><ol>
<li>code <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent3</span> () &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;parent3&#x27;</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">play</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>&#125;<br>         <br><span class="hljs-title class_">Parent3</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child3</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 第二次调用 Parent3()</span><br>  <span class="hljs-title class_">Parent3</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>);<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">type</span> = <span class="hljs-string">&#x27;child3&#x27;</span>;<br>&#125;<br>         <br><span class="hljs-comment">// 第一次调用 Parent3()</span><br><span class="hljs-title class_">Child3</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parent3</span>();<br><span class="hljs-comment">// 手动挂上构造器，指向自己的构造函数</span><br><span class="hljs-title class_">Child3</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Child3</span>;<br><span class="hljs-keyword">var</span> s3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child3</span>();<br><span class="hljs-keyword">var</span> s4 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child3</span>();<br>s3.<span class="hljs-property">play</span>.<span class="hljs-title function_">push</span>(<span class="hljs-number">4</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s3.<span class="hljs-property">play</span>, s4.<span class="hljs-property">play</span>);  <span class="hljs-comment">// 不互相影响</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s3.<span class="hljs-title function_">getName</span>()); <span class="hljs-comment">// 正常输出&#x27;parent3&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s4.<span class="hljs-title function_">getName</span>()); <span class="hljs-comment">// 正常输出&#x27;parent3&#x27;</span><br></code></pre></td></tr></table></figure></li>
</ol>
</li>
<li><strong>原型式继承</strong><ol>
<li>ES5 里面的 Object.create 方法，这个方法接收两个参数：一是用作新对象原型的对象、二是为新对象定义额外属性的对象（可选参数 <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">let parent4 = &#123;<br>  <span class="hljs-type">name</span>: &quot;parent4&quot;,<br>  friends: [&quot;p1&quot;, &quot;p2&quot;, &quot;p3&quot;],<br>  getName: <span class="hljs-keyword">function</span>() &#123;<br>    <span class="hljs-keyword">return</span> this.name;<br>  &#125;<br>&#125;;<br>         <br>let person4 = <span class="hljs-keyword">Object</span>.<span class="hljs-keyword">create</span>(parent4);<br>person4.name = &quot;tom&quot;;<br>person4.friends.push(&quot;jerry&quot;);<br>let person5 = <span class="hljs-keyword">Object</span>.<span class="hljs-keyword">create</span>(parent4);<br>person5.friends.push(&quot;lucy&quot;);<br>         <br>console.log(person4.name);<br>console.log(person4.name === person4.getName());<br>console.log(person5.name);<br>console.log(person4.friends);<br>console.log(person5.friends);<br></code></pre></td></tr></table></figure></li>
<li>关于这种继承方式的缺点也很明显，多个实例的引用类型属性指向相同的内存，存在篡改的可能</li>
</ol>
</li>
<li><strong>寄生式继承</strong><ol>
<li>使用原型式继承可以获得一份目标对象的浅拷贝，然后利用这个浅拷贝的能力再进行增强，添加一些方法，这样的继承方式就叫作寄生式继承。</li>
<li>code <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"> <span class="hljs-keyword">let</span> parent5 = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;parent5&quot;</span>,<br>  <span class="hljs-attr">friends</span>: [<span class="hljs-string">&quot;p1&quot;</span>, <span class="hljs-string">&quot;p2&quot;</span>, <span class="hljs-string">&quot;p3&quot;</span>],<br>  <span class="hljs-attr">getName</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;<br>  &#125;<br>&#125;;<br>         <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">clone</span>(<span class="hljs-params">original</span>) &#123;<br>  <span class="hljs-keyword">let</span> clone = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(original);<br>  clone.<span class="hljs-property">getFriends</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">friends</span><br>  &#125;;<br>  <span class="hljs-keyword">return</span> clone;<br>&#125;<br>         <br><span class="hljs-keyword">let</span> person5 = <span class="hljs-title function_">clone</span>(parent5);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person5.<span class="hljs-title function_">getName</span>());<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person5.<span class="hljs-title function_">getFriends</span>());<br></code></pre></td></tr></table></figure></li>
</ol>
</li>
<li><strong>寄生组合式继承</strong><ol>
<li>code <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">clone</span> (parent, child) &#123;<br>  <span class="hljs-comment">// 这里改用 Object.create 就可以减少组合继承中多进行一次构造的过程</span><br>  child.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(parent.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br>  child.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = child;<br>&#125;<br>         <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent6</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;parent6&#x27;</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">play</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>&#125;<br> <span class="hljs-title class_">Parent6</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child6</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title class_">Parent6</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>);<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">friends</span> = <span class="hljs-string">&#x27;child5&#x27;</span>;<br>&#125;<br>         <br><span class="hljs-title function_">clone</span>(<span class="hljs-title class_">Parent6</span>, <span class="hljs-title class_">Child6</span>);<br>         <br><span class="hljs-title class_">Child6</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getFriends</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">friends</span>;<br>&#125;<br>         <br><span class="hljs-keyword">let</span> person6 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child6</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person6);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person6.<span class="hljs-title function_">getName</span>());<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person6.<span class="hljs-title function_">getFriends</span>());<br></code></pre></td></tr></table></figure></li>
<li>结合第四种中提及的继承方式，解决普通对象的继承问题的 Object.create 方法，我们在前面这几种继承方式的优缺点基础上进行改造，得出了寄生组合式的继承方式，这也是所有继承方式里面相对最优的继承方式</li>
</ol>
</li>
<li>ES6 的 extends 关键字实现逻辑<ol>
<li>code <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>  constructor(name) &#123;<br>    <span class="hljs-keyword">this</span>.name = name<br>  &#125;<br>  <span class="hljs-comment">// 原型方法</span><br>  <span class="hljs-comment">// 即 Person.prototype.getName = function() &#123; &#125;</span><br>  <span class="hljs-comment">// 下面可以简写为 getName() &#123;...&#125;</span><br>  getName = function () &#123;<br>    console.log(&#x27;<span class="hljs-type">Person</span>:&#x27;, <span class="hljs-keyword">this</span>.name)<br>  &#125;<br>&#125;<br> <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Gamer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> </span>&#123;<br>  constructor(name, age) &#123;<br>    <span class="hljs-comment">// 子类中存在构造函数，则需要在使用“this”之前首先调用 super()。</span><br>    <span class="hljs-keyword">super</span>(name)<br>    <span class="hljs-keyword">this</span>.age = age<br>  &#125;<br>&#125;<br> <br>const asuna = <span class="hljs-keyword">new</span> <span class="hljs-type">Gamer</span>(&#x27;<span class="hljs-type">Asuna</span>&#x27;, <span class="hljs-number">20</span>)<br>asuna.getName() <span class="hljs-comment">// 成功访问到父类的方法</span><br></code></pre></td></tr></table></figure></li>
<li>通过编译解码可以发现，extends内步也是采用的寄生组合继承方式。</li>
</ol>
</li>
</ol>
</li>
<li><a id="question14">常用的数组方法有哪些？</a><ol>
<li>改变原数组<ol>
<li>push</li>
<li>pop</li>
<li>shift</li>
<li>unshift</li>
<li>sort</li>
<li>splice</li>
<li>reverse</li>
</ol>
</li>
<li>不改变原数组<ol>
<li>concat</li>
<li>join</li>
<li>map</li>
<li>forEach</li>
<li>filter</li>
<li>slice</li>
</ol>
</li>
</ol>
</li>
<li><a id="question15">什么是Promise</a><ol>
<li>Promise异步编程的一种解决方案。Promise是一个构造函数，接收一个函数作为参数，返回一个 Promise 实例。</li>
<li>code <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>)&#123;<br>		<span class="hljs-comment">//做一些异步操作</span><br>		<span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>			<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;执行完成Promise&#x27;</span>);<br>			<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;要返回的数据可以任何数据例如接口返回数据&#x27;</span>);<br>		&#125;, <span class="hljs-number">2000</span>);<br>	&#125;);<br></code></pre></td></tr></table></figure></li>
<li>Promise对象有三种状态，他们分别是 pending（等待中） resolved（已完成）rejected（拒绝）</li>
<li>Promise.all哪怕一个请求失败了也能得到其余正确的请求结果的解决方案</li>
<li>promise 的then会返回一个新的 promise 对象，能保证 then 方 可以进行链式调用</li>
</ol>
</li>
<li><a id="question16">async、await</a><ol>
<li>Async 和 await 是一种同步的写法，但还是异步的操作，两个必须配合一起使用</li>
<li>函数前面的async关键字，表明该函数内部有异步操作。调用该函数时，会立即返回一个Promise对象，await 是个运算符，用于组成表达式，await 表达式的运算结果取决于它等的东西，如果是promise则会等待promaise 返回结果，接普通函数直接进行链式调用</li>
<li>如果await后面不是Promise对象, 就直接返回对应的值，只能在async函数中出现, 普通函数直接使用会报错，await语句后的Promise对象变成reject状态时，那么整个async函数会中断，后面的程序不会继续执行</li>
<li>async&#x2F;await 的优势在于处理 then 链;单一的 Promise 链并不能发现 async&#x2F;await 的优势，但是，如果需要处理由多个 Promise 组成的 then 链的时候，优势就能体现出来了（很有意思，Promise 通过 then 链来解决多层回调的问题，现在又用 async&#x2F;await 来进一步优化它）。</li>
</ol>
</li>
<li><a id="question17">宏任务和微任务有哪些？执行顺序</a><ol>
<li>宏任务<ol>
<li>script</li>
<li>setTimeout</li>
<li>setInterval</li>
</ol>
</li>
<li>微任务<ol>
<li>Promise</li>
<li>process.nextTick</li>
</ol>
</li>
<li>微任务会优先于宏任务执行。这意味着在当前任务执行结束后，所有微任务都会被立即执行，而宏任务只有在所有微任务执行完毕后才会执行。</li>
</ol>
</li>
<li><a id="question18">var  let  const的区别</a><ol>
<li>var声明的变量存在变量提升，即变量可以在声明之前调用，var允许重复声明变量var不存在块级作用域</li>
<li>let和const不存在变量提升，即它们所声明的变量一定要在声明后使用，否则报错</li>
<li>let和const存在块级作用域</li>
<li>let和const在同一作用域不允许重复声明变量</li>
<li>const声明的是常量，常量不可以修改</li>
<li>const变量不能修改指针，但是可以修改值，比如我们定义一个对象，我们就可以修改对象里的属性值，但是不可以重写整个对象。</li>
</ol>
</li>
<li><a id="question19">ES6新特性</a><ol>
<li>模版字符串</li>
<li>箭头函数</li>
<li>拓展运算符</li>
<li>map和set</li>
<li>promise和proxy</li>
<li>数组方法from,map,filter,forEach,some,every</li>
<li>等等</li>
</ol>
</li>
<li><a id="question20">从浏览器输入url后都经历了什么</a><ol>
<li>浏览器输入域名</li>
<li>浏览器查找域名的ip地址<ol>
<li>查找浏览器缓存</li>
<li>查找系统缓存</li>
<li>查找路由缓存</li>
<li>递归查询</li>
<li>迭代查询</li>
</ol>
</li>
<li>浏览器与目标服务器建立tcp连接<ol>
<li>三次握手</li>
</ol>
</li>
<li>浏览器通过http协议发送请求</li>
<li>某些服务器会做永久重定向响应</li>
<li>浏览器跟踪重定向地址</li>
<li>服务器处理请求</li>
<li>服务器发出一个HTML响应</li>
<li>释放tcp连接<ol>
<li>四次挥手</li>
</ol>
</li>
<li>浏览器显示页面</li>
<li>浏览器发送获取嵌入在html中的其他内容</li>
</ol>
</li>
<li><a id="question21">TCP协议和HTTP 协议</a><ol>
<li>TCP协议在建立过程中会进行三次握手四次挥手，三次握手确保双方同步并避免无效连接，四次挥手则正常终止连接或异常终止连接。</li>
<li>HTTP协议是超文本传输协议（Hyper Text Transfer Protocol），是用于从万维网服务器传输超文本到本地浏览器的传送协议。HTTP是一个基于TCP&#x2F;IP通信协议来传递数据的。</li>
</ol>
</li>
<li><a id="question22">HTTP与HTTPS有什么区别</a><ol>
<li>HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。</li>
</ol>
</li>
<li><a id="question23">如何解决前端跨域问题</a><ol>
<li>jsonp</li>
<li>CORS</li>
<li>postMessage</li>
<li>document.domain</li>
<li>window.name</li>
<li>location.hash</li>
<li>http-proxy</li>
<li>nginx代理</li>
<li>nodejs中间件代理</li>
<li>WebSocket协议跨域<ol>
<li>webSocket本身不存在跨域问题，所以我们可以利用webSocket来进行非同源之间的通信。</li>
</ol>
</li>
</ol>
</li>
<li><a id="question24">WebSocket和webwork</a><ol>
<li>WebSocket作用是即使通信双向通信，webwork是多进程的</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/zxc123401/article/details/131491466">资料详解</a></li>
</ol>
</li>
<li><a id="question25">性能优化</a><ol>
<li>异步组件：对于较大的组件，可以使用异步组件进行延迟加载，提高页面加载速度。</li>
<li>列表性能优化：对于大数据列表，使用虚拟滚动或分页加载来减少渲染的数据量。</li>
<li>图片优化：使用适当的图片压缩和懒加载，并提供多种分辨率的图片，以避免不必要的网络负载。</li>
<li>组件懒加载：将页面按需加载，只加载当前视图所需的组件，减少首次加载的体积和渲染时间。</li>
<li>减少重绘和回流：合理使用CSS样式，避免频繁的DOM操作，以减少页面的重绘和回流。</li>
<li>接口过慢：后端优化接口，分段式请求接口，对加载过慢的接口做过度动画提升用户体验。</li>
<li>使用浏览器缓存：在合适的情况下，使用浏览器缓存可以显著减少请求时间，提高页面加载速度。</li>
</ol>
</li>
<li><a id="question26">Webpack是什么</a><ol>
<li>Webpack是一个模块打包工具，可以使用它管理项目中的模块依赖，并编译输出模块所需的静态文件。</li>
<li>它可以很好地管理、打包开发中所用到的HTML,CSS,JavaScript和静态文件（图片，字体）等，让开发更高效。</li>
<li>对于不同类型的依赖，Webpack有对应的模块加载器，而且会分析模块间的依赖关系，最后合并生成优化的静态资源。</li>
</ol>
</li>
<li><a id="question27">Webpack的基本功能？</a><ol>
<li>代码转换：TypeScript 编译成 JavaScript、SCSS 编译成 CSS 等等</li>
<li>文件优化：压缩 JavaScript、CSS、HTML 代码，压缩合并图片等</li>
<li>代码分割：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载</li>
<li>模块合并：在采用模块化的项目有很多模块和文件，需要构建功能把模块分类合并成一个文件</li>
<li>自动刷新：监听本地源代码的变化，自动构建，刷新浏览器</li>
<li>代码校验：在代码被提交到仓库前需要检测代码是否符合规范，以及单元测试是否通过</li>
<li>自动发布：更新完代码后，自动构建出线上发布代码并传输给发布系统。</li>
</ol>
</li>
<li><a id="question28">盒模型和怪异盒模型</a><ol>
<li>标准盒模型总宽度&#x3D;**width+margin(左右)+padding(左右)border(左右)**。box-sizing:<strong>centent-box</strong></li>
<li>怪异盒模型的总宽度&#x3D;width+margin(左右)( width已经包含了padding和border值)。box-sizing:<strong>border-box</strong></li>
</ol>
</li>
<li><a id="question29">让一个元素水平&#x2F;垂直居中</a><ol>
<li>父、子元素宽高未知时<ol>
<li><strong>table-cell</strong>（使用表格样式）</li>
<li><strong>flex</strong> 布局（父级 justify-content: center 和 align-items: center 即可）</li>
<li><strong>absolute + transform</strong>（定位的上、左为 50%，translate 上、左负 50%）</li>
<li><strong>absolute + margin: auto</strong>（定位的上下左右为 0）</li>
<li><strong>Grid</strong> 网格布局</li>
<li>直接使用 <strong>table</strong>（改变结构实现，和第一条类似）</li>
</ol>
</li>
<li>子元素固定宽高已知时（假设子元素宽高为 200px）<ol>
<li><strong>absolute + calc</strong>（定位上、左负50%时减去子元素宽、高）</li>
<li><strong>absolute + 负margin</strong>（定位的上、左为 50%，margin 的上、左负子元素的一半）</li>
</ol>
</li>
<li>父元素高度已知（假设为 400px），子元素宽高未知<ol>
<li><strong>text-align + vertical-align</strong></li>
</ol>
</li>
</ol>
</li>
<li><a id="question30">flex:1 到底代表什么 </a><ol>
<li>是一个简写方式，相当于同时设置了 <code>flex-grow: 1</code>、<code>flex-shrink: 1</code>、<code>flex-basis: 0</code> 这三个属性。满足项目的自适应需求。</li>
</ol>
</li>
<li><a id="question31">回溯算法</a><ol>
<li>数组arr[1,2,3] 输出结果[1, 2, 3] [1, 3, 2] [2, 1, 3] [2, 3, 1] [3, 1, 2] [3, 2, 1]</li>
<li>定义一个空数组res，用于存储所有的排列结果。</li>
<li>定义一个空数组path，用于存储当前的排列结果。</li>
<li>编写回溯函数backtrack，函数参数为当前的排列结果path和可选的数字列表nums。</li>
<li>如果nums为空，说明已经选完了所有的数字，将path加入到res中。</li>
<li>遍历nums中的每个数字，将其加入到path中，然后从nums中删除该数字，递归调用backtrack函数。</li>
<li>递归结束后，将path中的最后一个数字删除，将该数字加入到nums中，回溯到上一层。</li>
<li>调用backtrack函数，开始全排列。</li>
<li>code<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs vim">def permute(nums):<br>    <span class="hljs-keyword">res</span> = []<br>    path = []<br>    def backtrack(path, nums):<br>        <span class="hljs-keyword">if</span> not nums:<br>            <span class="hljs-keyword">res</span>.<span class="hljs-keyword">append</span>(path[:])<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">for</span> i in <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>            path.<span class="hljs-keyword">append</span>(nums[i])<br>            backtrack(path, nums[:i]+nums[i+<span class="hljs-number">1</span>:])<br>            path.<span class="hljs-keyword">pop</span>()<br>    backtrack(path, nums)<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">res</span><br> <br>arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><span class="hljs-keyword">res</span> = permute(arr)<br><span class="hljs-keyword">for</span> r in <span class="hljs-keyword">res</span>:<br>    <span class="hljs-keyword">print</span>(r)<br></code></pre></td></tr></table></figure></li>
</ol>
</li>
<li><a id="question32">冒泡算法排序</a><ol>
<li>code <figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// 冒泡排序</span><br><span class="hljs-comment">/* 1.比较相邻的两个元素，如果前一个比后一个大，则交换位置。</span><br><span class="hljs-comment">    　　　2.第一轮的时候最后一个元素应该是最大的一个。</span><br><span class="hljs-comment">    　　　3.按照步骤一的方法进行相邻两个元素的比较，这个时候由于最后一个元素已经是最大的了，所以最后一个元素不用比较。 */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bubbleSort</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">length</span>; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; arr.<span class="hljs-built_in">length</span>; j++) &#123;<br>      <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;<br>        <span class="hljs-keyword">var</span> temp = arr[j]<br>        arr[j] = arr[j + <span class="hljs-number">1</span>]<br>        arr[j + <span class="hljs-number">1</span>] = temp<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br>     <br><span class="hljs-keyword">var</span> Arr = [<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">74</span>, <span class="hljs-number">64</span>, <span class="hljs-number">64</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span>, <span class="hljs-number">49</span>, <span class="hljs-number">16</span>, <span class="hljs-number">161</span>, <span class="hljs-number">9</span>, <span class="hljs-number">4</span>]<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(Arr, <span class="hljs-string">&quot;before&quot;</span>);<br>bubbleSort(Arr)<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(Arr, <span class="hljs-string">&quot;after&quot;</span>);<br></code></pre></td></tr></table></figure></li>
</ol>
</li>
<li><a id="question33">快速排序</a><ol>
<li>code <figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">/*</span><br><span class="hljs-comment">快速排序是对冒泡排序的一种改进，第一趟排序时将数据分成两部分，一部分比另一部分的所有数据都要小。</span><br><span class="hljs-comment">然后递归调用，在两边都实行快速排序。  </span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">quickSort</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-keyword">if</span> (arr.<span class="hljs-built_in">length</span> &lt;= <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">return</span> arr<br>  &#125;<br>  <span class="hljs-keyword">var</span> middle = Math.<span class="hljs-built_in">floor</span>(arr.<span class="hljs-built_in">length</span> / <span class="hljs-number">2</span>)<br>  <span class="hljs-keyword">var</span> middleData = arr.<span class="hljs-built_in">splice</span>(middle, <span class="hljs-number">1</span>)[<span class="hljs-number">0</span>]<br> <br>  <span class="hljs-keyword">var</span> <span class="hljs-built_in">left</span> = []<br>  <span class="hljs-keyword">var</span> <span class="hljs-built_in">right</span> = []<br>  <br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">length</span>; i++) &#123;<br>    <span class="hljs-keyword">if</span> (arr[i] &lt; middleData) &#123;<br>      <span class="hljs-built_in">left</span>.<span class="hljs-built_in">push</span>(arr[i])<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-built_in">right</span>.<span class="hljs-built_in">push</span>(arr[i])<br>    &#125;<br>  &#125;<br> <br>  <span class="hljs-keyword">return</span> quickSort(<span class="hljs-built_in">left</span>).concat([middleData], quickSort(<span class="hljs-built_in">right</span>))<br>&#125;<br> <br><span class="hljs-keyword">var</span> Arr = [<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">74</span>, <span class="hljs-number">64</span>, <span class="hljs-number">64</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span>, <span class="hljs-number">49</span>, <span class="hljs-number">16</span>, <span class="hljs-number">161</span>, <span class="hljs-number">9</span>, <span class="hljs-number">4</span>]<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(Arr, <span class="hljs-string">&quot;before&quot;</span>);<br><span class="hljs-keyword">var</span> newArr = quickSort(Arr)<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(newArr, <span class="hljs-string">&quot;after&quot;</span>);<br></code></pre></td></tr></table></figure></li>
</ol>
</li>
<li><a id="question34">什么是MVVM，MVC模型</a><ol>
<li>M V C:Model View Controller<ol>
<li>Controller负责将Model的数据用View显示出来。</li>
</ol>
</li>
<li>M V VM 视图模型双向绑定<ol>
<li>Model，View，ViewModel</li>
<li>Model 和 View 并无直接关联，而是通过 ViewModel 来进行交互的（即双向数据绑定），</li>
<li>View的变化可以引起Model的变化，Model的变化也可以引起View变化（类似于浅拷贝）。ViewModel是View和Model层的桥梁，数据会绑定到viewModel层并自动将数据渲染到页面中，视图变化的时候会通知viewModel层更新数据。</li>
<li>使用：react vue</li>
</ol>
</li>
</ol>
</li>
<li><a id="question35">写React &#x2F; Vue项目时为什么要在列表组件中写key，其作用是什么?</a><ol>
<li>key是给每一个vnode的唯一id,可以依靠key,更准确,更快的拿到oldVnode中对应的vnode节点</li>
</ol>
</li>
<li><a id="question36">[‘1’, ‘2’, ‘3’].map(parseInt)</a><ol>
<li><code>[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;].map((value, index) =&gt; &#123;  parseInt(value, index);&#125;);</code></li>
<li>相当于执行<ol>
<li>parseInt(‘1’, 0) &#x2F;&#x2F; radix为0时，且string参数不以“0x”和“0”开头时，按照10为基数处理。返回1</li>
<li>parseInt(‘2’, 1) &#x2F;&#x2F; 基数为1（1进制）表示的数中，最大值小于2，所以无法解析，返回NaN</li>
<li>parseInt(‘3’, 2) &#x2F;&#x2F; 基数为2（2进制）表示的数中，最大值小于3，所以无法解析，返回NaN</li>
</ol>
</li>
<li>结果：<code>[1, NaN, NaN]</code></li>
</ol>
</li>
<li><a id="question37">什么是防抖和节流?有什么区别?如何实现?</a><ol>
<li>防抖<ol>
<li>所谓防抖，就是指触发事件后 n 秒后才执行函数，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。</li>
</ol>
</li>
<li>节流<ol>
<li>所谓节流，就是指连续触发事件但是在 n 秒中只执行一次函数。**节流会稀释函数的执行频率。</li>
</ol>
</li>
<li><strong>防抖就是回城，节流就是放技能</strong></li>
</ol>
</li>
<li><a id="question38">介绍下Set、 Map. WeakSet 和WeakMap的区别?</a><a target="_blank" rel="noopener" href="https://juejin.cn/post/6981747653323276319">详解</a><ol>
<li>Set<ol>
<li>ES6 新增的一种新的数据结构，类似于数组，但成员是唯一且无序的，没有重复的值。</li>
<li>Set 本身是一种构造函数，用来生成 Set 数据结构。</li>
<li>Set 实例属性<ol>
<li>constructor： 构造函数</li>
<li>size：元素数量</li>
</ol>
</li>
<li>Set 实例方法<ol>
<li>操作方法<ol>
<li>add(value)：新增，相当于 array里的push</li>
<li>delete(value)：存在即删除集合中value</li>
<li>has(value)：判断集合中是否存在 value</li>
<li>clear()：清空集合</li>
</ol>
</li>
<li>遍历方法（遍历顺序为插入顺序）<ol>
<li>keys()：返回一个包含集合中所有键的迭代器</li>
<li>values()：返回一个包含集合中所有值得迭代器</li>
<li>entries()：返回一个包含Set对象中所有元素得键值对迭代器</li>
<li>forEach(callbackFn, thisArg)：用于对集合成员执行callbackFn操作，如果提供了 thisArg 参数，回调中的this会是这个参数，没有返回值</li>
<li>由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys方法和values方法的行为完全一致</li>
</ol>
</li>
</ol>
</li>
<li>Array.from 方法可以将 Set 结构转为数组</li>
</ol>
</li>
<li>WeakSet<ol>
<li>WeakSet 结构与 Set 类似，也是不重复的值的集合。 WeakSet 对象允许你将弱引用对象储存在一个集合中。</li>
<li>WeakSet 与 Set 的区别<ol>
<li>WeakSet 只能储存对象引用，不能存放值，而 Set 对象都可以</li>
<li>WeakSet 对象中储存的对象值都是被弱引用的，即垃圾回收机制不考虑 WeakSet 对该对象的应用，如果没有其他的变量或属性引用这个对象值，则这个对象将会被垃圾回收掉（不考虑该对象还存在于 WeakSet 中），所以，WeakSet 对象里有多少个成员元素，取决于垃圾回收机制有没有运行，运行前后成员个数可能不一致，遍历结束之后，有的成员可能取不到了（被垃圾回收了），WeakSet 对象是无法被遍历的（ES6 规定 WeakSet 不可遍历），也没有办法拿到它包含的所有元素</li>
<li>constructor：构造函数，任何一个具有 Iterable 接口的对象，都可以作参数。</li>
</ol>
</li>
<li>WeakSet方法<ol>
<li>add(value)：在WeakSet 对象中添加一个元素value</li>
<li>has(value)：判断 WeakSet 对象中是否包含value</li>
<li>delete(value)：删除元素 value</li>
<li>clear()：注意该方法已废弃, WeakSet没这个方法</li>
</ol>
</li>
</ol>
</li>
<li>Map<ol>
<li>Map诞生原因:<ol>
<li>为了解决对象只能用字符串当作键的问题。</li>
<li>ES6 提供了 Map 数据结构，类似于对象，也是键值对的集合，但是 “键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。</li>
</ol>
</li>
<li>Map的属性和方法<ol>
<li>size属性返回 Map 结构的成员总数。</li>
<li>set方法设置键名key对应的键值为value，然后返回整个 Map 结构。如果key已经有值，则键值会被更新，否则就新生成该键。<ol>
<li>set方法返回的是当前的Map对象，因此可以采用链式写法。</li>
<li><code>let map = new Map().set(1, &#39;a&#39;).set(2, &#39;b&#39;).set(3, &#39;c&#39;);</code></li>
<li>如果对同一个键多次赋值，后面的值将覆盖前面的值:</li>
</ol>
</li>
<li>get方法读取key对应的键值，如果找不到key，返回undefined。</li>
<li>has方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。</li>
<li>delete方法删除某个键，返回true。如果删除失败，返回false。</li>
<li>clear方法清除所有成员，没有返回值。</li>
</ol>
</li>
<li>注意<ol>
<li>数组做参数<ol>
<li>作为构造函数，Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。</li>
</ol>
</li>
<li>Map 的键实际上是跟内存地址绑定的<ol>
<li>如果读取一个未知的键，则返回undefined</li>
<li>只有对同一个对象的引用，Map 结构才将其视为同一个键</li>
</ol>
</li>
</ol>
</li>
<li>Map遍历方法<ol>
<li>Map.prototype.keys()：返回键名的遍历器。</li>
<li>Map.prototype.values()：返回键值的遍历器。</li>
<li>Map.prototype.entries()：返回所有成员的遍历器。</li>
<li>Map.prototype.forEach()：遍历 Map 的所有成员。</li>
</ol>
</li>
<li>Map 结构转为数组结构，比较快速的方法是使用扩展运算符（…）</li>
</ol>
</li>
<li>WeakMap<ol>
<li>WeakMap结构与Map结构类似，也是用于生成键值对的集合</li>
<li>WeakMap与Map的区别<ol>
<li>WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名</li>
<li>WeakMap的键名所指向的对象，不计入垃圾回收机制。</li>
</ol>
</li>
<li>WeakMap 的语法<ol>
<li>没有遍历操作（即没有keys()、values()和entries()方法），也没有size属性</li>
<li>无法清空，即不支持clear方法</li>
<li>WeakMap只有四个方法可用：get()、set()、has()、delete()。</li>
</ol>
</li>
<li>WeakMap 的用途<ol>
<li>WeakMap 应用的典型场合就是 DOM 节点作为键名。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><a id="question39">介绍下深度优先遍历和广度优先遍历，如何实现?</a><ol>
<li>深度优先遍历：是指从某个顶点出发，首先访问这个顶点，然后找出刚访问这个结点的第一个未被访问的邻结点，然后再以此邻结点为顶点，继续找它的下一个顶点进行访问。重复此步骤，直至所有结点都被访问完为止。</li>
<li>广度优先遍历：是从某个顶点出发，首先访问这个顶点，然后找出刚访问这个结点所有未被访问的邻结点，访问完后再访问这些结点中第一个邻结点的所有结点，重复此方法，直到所有结点都被访问完为止。</li>
</ol>
</li>
<li><a id="question40">请分别用深度优先思想和广度优先思想实现一个拷贝函数?</a><ol>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_46299172/article/details/108545861">address</a></li>
<li>深度优先的深拷贝 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <span class="hljs-title function_">DFSdeepClone</span> = (<span class="hljs-params">obj, visitedArr = []</span>) =&gt; &#123;<br>  <span class="hljs-keyword">let</span> _obj = &#123;&#125;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isTypeOf</span>(obj, <span class="hljs-string">&#x27;array&#x27;</span>) || <span class="hljs-title function_">isTypeOf</span>(obj, <span class="hljs-string">&#x27;object&#x27;</span>)) &#123;<br>    <span class="hljs-keyword">let</span> index = visitedArr.<span class="hljs-title function_">indexOf</span>(obj)<br>    _obj = <span class="hljs-title function_">isTypeOf</span>(obj, <span class="hljs-string">&#x27;array&#x27;</span>) ? [] : &#123;&#125;<br>    <span class="hljs-keyword">if</span> (~index) &#123; <span class="hljs-comment">// 判断环状数据 ~-1 == 0 一个骚操作而已</span><br>      _obj = visitedArr[index]<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      visitedArr.<span class="hljs-title function_">push</span>(obj)<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">in</span> obj) &#123;<br>        _obj[item] = <span class="hljs-title class_">DFSdeepClone</span>(obj[item], visitedArr)<br>      &#125;<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isTypeOf</span>(obj, <span class="hljs-string">&#x27;function&#x27;</span>)) &#123;<br>    _obj = <span class="hljs-built_in">eval</span>(<span class="hljs-string">&#x27;(&#x27;</span> + obj.<span class="hljs-title function_">toString</span>() + <span class="hljs-string">&#x27;)&#x27;</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    _obj = obj<br>  &#125;<br>  <span class="hljs-keyword">return</span> _obj<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>广度优先的拷贝 <figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">let</span> BFSdeepClone = (obj) =&gt; &#123;<br><span class="hljs-built_in">let</span> <span class="hljs-built_in">origin</span> = [obj],<br>  copyObj = &#123;&#125;,<br>  <span class="hljs-built_in">copy</span> = [copyObj]<br>  // 去除环状数据<br><span class="hljs-built_in">let</span> visitedQueue = [],<br>  visitedCopyQueue = []<br><span class="hljs-keyword">while</span> (<span class="hljs-built_in">origin</span>.<span class="hljs-built_in">length</span> &gt; <span class="hljs-number">0</span>) &#123;<br>  <span class="hljs-built_in">let</span> items = <span class="hljs-built_in">origin</span>.shift(),<br>    _obj = <span class="hljs-built_in">copy</span>.shift()<br>  visitedQueue.<span class="hljs-built_in">push</span>(items)<br>  <span class="hljs-keyword">if</span> (isTypeOf(items, &#x27;object&#x27;) || isTypeOf(items, &#x27;<span class="hljs-built_in">array</span>&#x27;)) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">let</span> item <span class="hljs-keyword">in</span> items) &#123;<br>      <span class="hljs-built_in">let</span> val = items[item]<br>      <span class="hljs-keyword">if</span> (isTypeOf(val, &#x27;object&#x27;)) &#123;<br>        <span class="hljs-built_in">let</span> index = visitedQueue.indexOf(val)<br>        <span class="hljs-keyword">if</span> (!~index) &#123;<br>          _obj[item] = &#123;&#125;<br>            //下次<span class="hljs-keyword">while</span>循环使用给空对象提供数据<br>          <span class="hljs-built_in">origin</span>.<span class="hljs-built_in">push</span>(val)<br>            // 推入引用对象<br>          <span class="hljs-built_in">copy</span>.<span class="hljs-built_in">push</span>(_obj[item])<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          _obj[item] = visitedCopyQueue[index]<br>          visitedQueue.<span class="hljs-built_in">push</span>(_obj)<br>        &#125;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isTypeOf(val, &#x27;<span class="hljs-built_in">array</span>&#x27;)) &#123;<br>        // 数组类型在这里创建了一个空数组<br>        _obj[item] = []<br>        <span class="hljs-built_in">origin</span>.<span class="hljs-built_in">push</span>(val)<br>        <span class="hljs-built_in">copy</span>.<span class="hljs-built_in">push</span>(_obj[item])<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isTypeOf(val, &#x27;function&#x27;)) &#123;<br>        _obj[item] = <span class="hljs-built_in">eval</span>(&#x27;(&#x27; + val.toString() + &#x27;)&#x27;);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        _obj[item] = val<br>      &#125;<br>    &#125;<br>    // 将已经处理过的对象数据推入数组 给环状数据使用<br>    visitedCopyQueue.<span class="hljs-built_in">push</span>(_obj)<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isTypeOf(items, &#x27;function&#x27;)) &#123;<br>    copyObj = <span class="hljs-built_in">eval</span>(&#x27;(&#x27; + items.toString() + &#x27;)&#x27;);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    copyObj = obj<br>  &#125;<br>&#125;<br>  <span class="hljs-built_in">return</span> copyObj<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
</li>
<li><a id="question41">ES5&#x2F;ES6的继承除了写法以外还有什么区别?</a><ol>
<li>ES5的继承：<ol>
<li>先创建子类的实例对象，然后再将父类的方法添加到this上（Parent.apply(this)）；</li>
<li>通过原型或构造函数机制来实现；</li>
</ol>
</li>
<li>ES6的继承：<ol>
<li>先创建父类的实例对象this(所以必须先调用父类的super()方法)，然后再用子类的构造函数修改this。</li>
<li>通过class关键字定义类，里面有构造方法，类之间通过extends关键字实现继承<ol>
<li>子类必须在constructor方法中调用super方法，否则新建实例报错。因 为子类没有自己的 this 对象，而是继承了父类的 this 对象，然后对其进行加工。 如果不调用 super 方法，子类得不到 this 对象。</li>
<li>注意 super 关键字指代父类的实例，即父类的 this 对象</li>
<li>注意 在子类构造函数中，调用 super 后，才可使用 this 关键字，否则报错</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><a id="question42">setTimeout、Promise、 Async&#x2F;Await的区别</a><ol>
<li>setTimeout属性宏任务，Promise里面的then方法属于微任务，Async&#x2F;Await中await语法后面紧跟的表达式是同步的，但接下来的代码是异步的，属于微任务。</li>
<li>setTimeout<ol>
<li>code <figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;script start&quot;</span>);<br>   setTimeout(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>       <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;setTimeout&#x27;</span>)<br>   &#125;, <span class="hljs-number">0</span>);<br>   <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;script end&#x27;</span>);<br></code></pre></td></tr></table></figure></li>
<li>输出script start -&gt; script end -&gt; set</li>
</ol>
</li>
<li>Promise：<ol>
<li>Promise本身是同步的，但在执行resolve或者rejects时是异步的，即then方法是异步的。</li>
<li>code <figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;script start&quot;</span>);<br> let promise1 = <span class="hljs-keyword">new</span> Promise(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) &#123;<br>     <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;promise1&quot;</span>);<br>     resolve();<br>     <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;promise1 end&quot;</span>);<br> &#125;).then(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>     <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;promise2&#x27;</span>);<br> &#125;)<br>        <br> setTimeout(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>     <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;setTimeout&#x27;</span>);<br> &#125;, <span class="hljs-number">0</span>)<br> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;script end&#x27;</span>);<br></code></pre></td></tr></table></figure></li>
<li>输出顺序： script start -&gt; promise1 -&gt; promise1 end -&gt; script end -&gt; promise2 -&gt;setTimeout</li>
</ol>
</li>
<li>async&#x2F;await<ol>
<li>async 函数返回一个 Promise 对象，当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再执行函数体内后面的语句。可以理解为，是让出了线程，跳出了 async 函数体。</li>
<li>await后面跟一个表达式，async方法执行时，遇到await后会立即执行表达式，然后把表达式后边的代码放到微任务队列中，让出执行栈让同步代码先执行；</li>
<li>code <figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arcade">async <span class="hljs-keyword">function</span> <span class="hljs-title function_">async1</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;async1 start&#x27;</span>);<br>await async2();<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;async1 end&#x27;</span>)<br>&#125;<br>async <span class="hljs-keyword">function</span> <span class="hljs-title function_">async2</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;async2&#x27;</span>)<br>&#125;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;script start&#x27;</span>);<br>async1();<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;script end&#x27;</span>)<br></code></pre></td></tr></table></figure></li>
<li>输出顺序：script start -&gt; async1 start -&gt; async2 -&gt; script end -&gt; async1 end</li>
</ol>
</li>
</ol>
</li>
<li><a id="question43">Async&#x2F;Await如何通过同步的方式实现异步</a><ol>
<li>Async 和 Await 都是异步编程的关键字。</li>
<li>在 Async 函数内部使用 await 关键字来等待异步操作完成。await 表示等待异步操作返回结果后再继续执行后续的代码。</li>
<li>Async&#x2F;Await 是如何通过同步的方式实现异步的呢？答案就是 Generator 函数和 Promise。</li>
<li>Generator 函数是一种特殊的函数，它可以被暂停和恢复执行。在 Generator 函数中，我们可以使用 yield 关键字将控制权交给调用方，并在下次调用时从上次暂停的位置继续执行。这种特性可以用来实现异步操作。</li>
<li>Promise 是 ES6 引入的另一种异步编程技术。Promise 对象表示一个尚未完成或失败的操作，它可以被异步执行，并返回一个代表操作结果的值。</li>
<li>Async 函数实际上是一种特殊的 Generator 函数，它使用 yield 关键字暂停执行，并在异步操作完成后，通过调用 next 方法恢复执行。这个过程中，Async 函数内部创建了一个 Promise 对象，并将该 Promise 对象返回给调用方。</li>
<li>使用 Async&#x2F;Await 可以避免回调地狱和 Promise 层层嵌套的问题。</li>
</ol>
</li>
<li><a id="question44">JS异步解决方案的发展历程以及优缺点</a><ol>
<li>回调函数（callback）</li>
<li>Promise</li>
<li>Generator</li>
<li>Async&#x2F;await</li>
</ol>
</li>
<li><a id="question45">Promise构造函数是同步执行还是异步执行，那么then方法呢?</a><ol>
<li>promise构造函数是同步执行的，then方法是异步执行的</li>
</ol>
</li>
<li><a id="question46">如何实现一个new</a><ol>
<li>创建一个空的简单 JavaScript 对象（即{}）；</li>
<li>链接该对象（即设置该对象的构造函数）到另一个对象 ；（ 通俗理解就是新对象隐式原型__proto__链接到构造函数显式原型prototype上。）</li>
<li>将步骤 1 新创建的对象作为 this 的上下文；（ 实际是执行了构造函数 并将构造函数作用域指向新对象 ）</li>
<li>如果该函数没有返回对象，则返回 this。（ 实际是返回一个空对象， new Object()就是返回一个空对象{} ）</li>
<li>code <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">_new</span>(<span class="hljs-params">constructor, ...arg</span>) &#123;<br>  <span class="hljs-keyword">var</span> obj = &#123;&#125;; <span class="hljs-comment">// 对应于上面的步骤 1</span><br>  obj.<span class="hljs-property">__proto__</span> = constructor.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>; <span class="hljs-comment">// 对应于上面的步骤 2</span><br><br>  <span class="hljs-keyword">var</span> res = constructor.<span class="hljs-title function_">apply</span>(obj, arg); <span class="hljs-comment">// 对应于上面的步骤 3</span><br><br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(res) === <span class="hljs-string">&#x27;[object Object]&#x27;</span> ? res : obj; <span class="hljs-comment">// 对应于上面的步骤 4</span><br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Fun</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">_new</span>(<span class="hljs-title class_">Fun</span>, <span class="hljs-string">&#x27;小明&#x27;</span>));<br><br><span class="hljs-comment">// Fun &#123;name: &quot;小明&quot;&#125;</span><br><br></code></pre></td></tr></table></figure></li>
</ol>
</li>
<li><a id="question47">简单讲解一下http2的多路复用</a><ol>
<li>在 HTTP&#x2F;2 中，有两个非常重要的概念，分别是帧（frame）和流（stream）。</li>
<li>帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。</li>
<li>HTTP2 采用二进制数据帧传输，取代了 HTTP1.x 的文本格式，二进制格式解析更高效。</li>
<li>多路复用代替了 HTTP1.x 的序列和阻塞机制，所有的相同域名请求都通过同一个 TCP 连接并发完成。同一 Tcp 中可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。</li>
</ol>
</li>
<li><a id="question48">谈谈你对TCP三次握手和四次挥手</a><ol>
<li>TCP协议？<ol>
<li>TCP( Transmission control protocol )即传输控制协议，是一种面向连接、可靠的数据传输协议，它是为了在不可靠的互联网上提供可靠的端到端字节流而专门设计的一个传输协议。<ol>
<li>面向连接：数据传输之前客户端和服务器端必须建立连接</li>
<li>可靠的：数据传输是有序的 要对数据进行校验</li>
</ol>
</li>
</ol>
</li>
<li>TCP三次握手<ol>
<li>为了保证客户端和服务器端的可靠连接，TCP建立连接时必须要进行三次会话，也叫TCP三次握手，进行三次握手的目的是为了确认双方的接收能力和发送能力是否正常。<ol>
<li>我打给你 问你能听到吗</li>
<li>你说你能听到 问我能听到吗</li>
<li>我说我能听到 开始交流吧</li>
</ol>
</li>
</ol>
</li>
<li>TCP四次挥手（我客户端 你服务端）<ol>
<li>我告诉你 我要关闭了</li>
<li>你说 好吧 你关闭吧</li>
<li>你再说 那我也关闭了？</li>
<li>我说 行你也关吧</li>
</ol>
</li>
</ol>
</li>
<li><a id="question49">A、B机器正常连接后，B机器突然重启，问A此时处于TCP什么状态</a><ol>
<li>等待 超时 抛出异常</li>
</ol>
</li>
<li><a id="question50">React中setState什么时候是同步的，什么时候是异步的?</a><ol>
<li><ul>
<li><ol>
<li>由 React 控制的事件处理程序，以及生命周期函数调用 setState 不会同步更新 state 。</li>
<li>React 控制之外的事件中调用 setState 是同步更新的。比如原生 js 绑定的事件，setTimeout&#x2F;setInterval 等。</li>
</ol>
</li>
</ul>
</li>
<li>在合成事件 和 生命周期钩子(除componentDidUpdate) 中，setState是”异步”的；</li>
<li>在 原生事件 和setTimeout 中，setState是同步的，可以马上获取更新后的值；</li>
<li>批量更新：多个顺序的setState不是同步地一个一个执行，会一个一个加入队列，然后最后一起执行。在 合成事件 和 生命周期钩子 中，setState更新队列时，存储的是 合并状态(Object.assign)。因此前面设置的 key 值会被后面所覆盖，最终只会执行一次更新。</li>
<li>函数式： setState第一个参数为函数形式时，在这个函数中可以回调拿到最新的state对象，然后函数return出的对象将被设置成newState。<code>this.setState((state, props) =&gt; newState)</code></li>
</ol>
</li>
<li><a id="question51">介绍下npm模块安装机制，为什么输入npm install就可以自动安装对应的</a><ol>
<li>npm 模块安装机制：<ol>
<li>发出npm install命令</li>
<li>查询node_modules目录之中是否已经存在指定模块<ol>
<li>若存在，不再重新安装</li>
<li>若不存在<ol>
<li>npm 向 registry 查询模块压缩包的网址</li>
<li>下载压缩包，存放在根目录下的.npm目录里</li>
<li>解压压缩包到当前项目的node_modules目录</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>npm 实现原理<ol>
<li>输入 npm install 命令并敲下回车后，会经历如下几个阶段（以 npm 5.5.1 为例）<ol>
<li>执行工程自身 preinstall</li>
<li>确定首层依赖模块</li>
<li>获取模块<ol>
<li>获取模块是一个递归的过程，分为以下几步<ol>
<li>获取模块信息。在下载一个模块之前，首先要确定其版本，这是因为 package.json 中往往是 semantic version（semver，语义化版本）。此时如果版本描述文件（npm-shrinkwrap.json 或 package-lock.json）中有该模块信息直接拿即可，如果没有则从仓库获取。如 packaeg.json 中某个包的版本是 ^1.1.0，npm 就会去仓库中获取符合 1.x.x 形式的最新版本。</li>
<li>获取模块实体。上一步会获取到模块的压缩包地址（resolved 字段），npm 会用此地址检查本地缓存，缓存中有就直接拿，如果没有则从仓库下载。</li>
<li>查找该模块依赖，如果有依赖则回到第1步，如果没有则停止。</li>
</ol>
</li>
</ol>
</li>
<li>模块扁平化（dedupe）</li>
<li>安装模块<ol>
<li>这一步将会更新工程中的 node_modules，并执行模块中的生命周期函数（按照 preinstall、install、postinstall 的顺序）。</li>
</ol>
</li>
<li>执行工程自身生命周期<ol>
<li>当前 npm 工程如果定义了钩子此时会被执行（按照 install、postinstall、prepublish、prepare 的顺序）。</li>
</ol>
</li>
<li>生成或更新版本描述文件，npm install 过程完成。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><a id="question52">重绘和回流(Repaint &amp; Reflow)，以及如何进行优化</a><ol>
<li>重绘<ol>
<li>由于节点的几何属性发生改变或者由于样式发生改变而不会影响布局的，称为重绘，例如outline, visibility, color、background-color等，重绘的代价是高昂的，因为浏览器必须验证DOM树上其他节点元素的可见性。</li>
</ol>
</li>
<li>回流<ol>
<li>回流是布局或者几何属性需要改变就称为回流。回流是影响浏览器性能的关键因素，因为其变化涉及到部分页面（或是整个页面）的布局更新。一个元素的回流可能会导致了其所有子元素以及DOM中紧随其后的节点、祖先节点元素的随后的回流。</li>
</ol>
</li>
<li>回流必定会发生重绘，重绘不一定会引发回流。</li>
<li>下列属性都会强制渲染刷新队列<ol>
<li>offsetTop、offsetLeft、offsetWidth、offsetHeight</li>
<li>scrollTop、scrollLeft、scrollWidth、scrollHeight</li>
<li>clientTop、clientLeft、clientWidth、clientHeight</li>
<li>width、height</li>
<li>getComputedStyle()</li>
<li>getBoundingClientRect()</li>
</ol>
</li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zjknb/p/13974879.html">减少重绘与回流</a></li>
</ol>
</li>
<li><a id="question53">介绍下观察者模式和订阅-发布模式的区别，各自适用于什么场景</a><ol>
<li>观察者模式里，只有两个角色 —— 观察者(Observer) + 被观察者(Subject || Observable)</li>
<li>发布订阅模式里，却不仅仅只有发布者(Publisher)和订阅者(Subscriber)两个角色，还有一个经常被我们忽略的 —— 经纪人Broker<br> 1. </li>
<li>使用：<ol>
<li>观察者模式，多用于单个应用内部</li>
<li>发布订阅模式，则更多的是一种跨应用的模式(cross-application pattern)，比如我们常用的消息中间件</li>
</ol>
</li>
</ol>
</li>
<li><a id="question54">聊聊 Redux 和Vuex的设计思想</a><ol>
<li>不管是 Vue，还是 React，都需要管理状态（state），比如组件之间都有共享状态的需要。</li>
<li>Redux 和 Vuex 的设计思想都是为了让应用程序的状态变得更加可控、可预测和易于维护。通过使用单一数据源、状态只读、组件解耦、动态更新和中心化管理等技术手段，这两个库可以实现复杂应用程序的状态管理，并提高代码的可重用性和可扩展性。</li>
</ol>
</li>
<li><a id="question55">说说浏览器和Node事件循环的区别</a><ol>
<li>执行环境不同：浏览器中的事件循环主要运行在Javascript引擎和渲染引擎之间，而Node.js中的事件循环是运行在单独的的线程中。因此，在浏览器中，事件循环跟渲染进程共享同一个线程，可能会出现线程阻塞。</li>
<li>宏任务和微任务的实现方式不同<ol>
<li>在浏览器中，宏任务和微任务是通过HTML5规范中定义的消息队列来实现的。所有的异步任务都被分为宏任务和微任务两种类型，并依次加入到对应的队列中。当当前的宏任务执行完毕后，会立即执行所有的微任务，然后再选择下一个宏任务执行。 常见的宏任务包括：setTimeout, setInterval, DOM事件等，常见的微任务包括：Promise.then, MutationObserve等。</li>
<li>在Node.js中，宏任务和微任务的实现方式有所不同。Node.js使用libuv库提供的事件循环机制来管理宏任务，而使用process.nextTick()方法来实现微任务。在Node.js的事件循环中，所有的宏任务都被分为6个不同的阶段，每个阶段会执行一些同步和异步的操作。当当前阶段的所有任务执行完毕后，才会执行process.nextTick()的为任务队列。</li>
</ol>
</li>
<li>在处理 I&#x2F;O 操作和定时器方面有些许不同<ol>
<li>Node.js 中采用异步 I&#x2F;O 和非阻塞 I&#x2F;O，可以提供更高效的事件循环机制。而浏览器中，大多数的 I&#x2F;O 操作都是通过 Web APIs 实现的，这些 API 通常是基于异步回调函数实现的。在处理定时器方面，Node.js 提供了 setImmediate() 方法来代替 setTimeout() 函数，在性能上有所提升。</li>
</ol>
</li>
</ol>
</li>
<li><a id="question56">介绍模块化发展历程</a><ol>
<li>文件划分方式</li>
<li>命名空间方式</li>
<li>立即执行函数 IIFE 方式<ol>
<li>具体做法，就是将每个模块成员都放在一个函数提供的私有作用域中，对于需要暴露给外部的成员，通过挂到全局对象（window）上的方式实现。</li>
</ol>
</li>
<li>利用自执行函数参数作为依赖声明使用<ol>
<li>具体做法就是在第3阶段的基础上，利用立即执行函数的参数传递模块依赖项。这样就使得每个模块之间的关系变得更加明显了。</li>
</ol>
</li>
<li>模块化规范的出现 <ol>
<li>CommonJS 规范<ol>
<li>一个文件就是一个模块</li>
<li>每个模块都有单独的作用域</li>
<li>通过 module.exports 导出成员</li>
<li>通过 require 函数载入模块</li>
</ol>
</li>
<li>AMD 规范与 Require.js</li>
<li>CMD 规范与 Sea.js</li>
</ol>
</li>
<li>模块化标准规范</li>
<li>总的来说，前端模块化，目前算是统一成了 CommonJS 和 ES Modules 这两个规范</li>
</ol>
</li>
<li><a id="question57">全局作用域中，用const 和let声明的变量不在window 上，那到底在哪</a><ol>
<li>在全局作用域中，用 let 和 const 声明的全局变量并没有在全局对象中，只是一个块级作用域（Script）中。那要怎么获取呢？在定义变量的块级作用域中就能获取啊，既然不属于顶层对象Window，那就不加 window（global），直接访问即可。</li>
</ol>
</li>
<li><a id="question58">cookie和 token 都存放在header中，为什么不会劫持token?</a><ol>
<li>因为传统的cookie保存的session id，服务器会根据这个session id，确保服务器与客户端对话；这是的cookie是有状态的，意味着验证记录或者会话需要一直在服务端和客户端保持。而token是无状态的，服务器不记录哪些用户登录了或者哪些 JWT 被发布了，只判断token是否有效，通常我们都会给token设置有效时间，来确保不被劫持。所有劫持cookie比劫持token，更有效，毕竟cookie在某种情况下可以一直使用下去，而token不行。</li>
</ol>
</li>
<li><a id="question59">强制缓存和协商缓存</a><ol>
<li>什么是缓存？<ol>
<li>缓存是指在计算机中存储数据副本的地方，以便快速访问数据，而不需要重新计算或从原始位置获取数据。<strong>在Web开发中，缓存是指将网页内容存储在本地浏览器或CDN等代理服务器上，以便在用户再次访问时能够快速加载网页</strong>。</li>
</ol>
</li>
<li>什么是强缓存和协商缓存？<ol>
<li>强缓存和协商缓存是Web缓存的两种类型。<ol>
<li>强缓存<ol>
<li>强缓存是指浏览器在没有任何请求的情况下，直接从本地缓存中获取资源。如果本地缓存中有该资源，浏览器将直接使用它，而不会向服务器发送请求。强缓存通过设置HTTP响应头中的<strong>Expires</strong>和<strong>Cache-Control</strong>来实现。Expires头指定资源过期的时间戳，而Cache-Control头可以指定一个相对时间（如1小时后过期）或一个绝对时间（如2023年1月1日过期）。</li>
</ol>
</li>
<li>协商缓存<ol>
<li>协商缓存是指浏览器在请求资源时，与服务器进行协商来确定是否使用本地缓存的资源。服务器根据请求中的条件（如<strong>If-Modified-Since</strong>和<strong>If-None-Match</strong>）与资源的当前状态进行比较，来决定是否返回<strong>304</strong>未修改状态码，告诉浏览器可以使用本地缓存的资源。协商缓存通过设置HTTP请求头中的If-Modified-Since和If-None-Match来实现。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>如何设置强缓存和协商缓存？<ol>
<li>设置强缓存和协商缓存需要在HTTP响应头中添加相应的字段。以下是一些常用的方法：<ol>
<li>对于强缓存，可以使用<strong>Expires头或Cache-Control头</strong>。例如，Expires: Wed, 21 Jul 2023 17:00:00 GMT表示资源在2023年7月21日下午5点过期。或者使用Cache-Control: max-age&#x3D;3600表示资源在1小时后过期。</li>
<li>对于协商缓存，可以使用<strong>Last-Modified头和ETag头</strong>。例如，Last-Modified: Wed, 21 Jul 2023 17:00:00 GMT表示资源的最后修改时间是2023年7月21日下午5点。或者使用ETag: “123456789”表示资源的唯一标识符。</li>
<li>在使用这些头字段时，需要注意它们的格式和值。错误的格式或值可能导致缓存机制无法正常工作。</li>
</ol>
</li>
</ol>
</li>
<li>强缓存和协商缓存有什么区别？<ol>
<li>强缓存和协商缓存的主要区别在于<strong>它们处理请求的方式不同</strong>。</li>
<li><strong>强缓存是在没有请求的情况下直接从本地缓存中获取资源，而协商缓存是在发送请求时与服务器进行协商来确定是否使用本地缓存的资源</strong>。因此，强缓存更加高效，因为它避免了不必要的请求到服务器。</li>
<li>然而，由于强缓存的过期时间是由服务器设置的，如果服务器的时间戳不准确，可能会导致过期时间的不准确。而协商缓存可以更加准确地判断资源是否已更改，因为它与服务器进行了实时比较。</li>
</ol>
</li>
</ol>
</li>
<li><a id="question60">DOCTYPE有什么作用？</a><ol>
<li>DOCTYPE是一种指示浏览器以何种HTML或XHTML规范来解析文档的声明。它能够告知浏览器网页文档使用的标记语言的类型以及版本，从而确保浏览器能够正确地展示网页内容。DOCTYPE声明通常位于HTML文档的开头，是HTML文档的必须部分。</li>
</ol>
</li>
<li><a id="question61">img标签的title和alt属性有什么区别</a><ol>
<li>alt属性用于为图像提供替代文本，即使图像无法加载，也可以描述图像内容，提高网页的可访问性和可用性。title属性则提供有关图像的额外信息，可以通过鼠标悬停或使用辅助技术来查看。它通常用于提供更多的上下文或补充描述，但并不是必需的。</li>
<li>alt属性和title属性相同点：<br> 它们都会出现浮层，显示自己设置的图片相关的内容。<br> alt属性和title属性不同点：<br> alt属性:1.当图片加载不出来的时候，就会在图片未显示的地方出现一段alt设置的属性内容。这个属性的作用是为了给未加载的图片显示提示信息，即使在网络比较差的时候，用户也可以知道图片的内容，方便用户浏览网页。同时在程序员对网站维护的时候也能更快的查找到问题。2.浏览器的搜索引擎可以通过alt属性的文字描述来获取图片。<br> title属性：title属性可以用在任何的元素上，当用户把鼠标移动到元素上时，就会显示预先设置的title的内容，起到对图片说明的作用，实质上就是对图片的解释和备注。</li>
<li>img标签中引用的图片不论是否能够正常的显示，图片只设置了title属性后，当鼠标经过或者悬停在图片区域时，就能看到图片的文字的描述。当图片仅仅设置alt属性的时候啊，当鼠标悬停或者经过图片区域的时候，可以看到该图片设置的alt的属性的文字内容。如果图片设置了title属性和alt属性，鼠标悬停或者经过图片区域的时候，只会显示title属性设置的内容。</li>
</ol>
</li>
<li><a id="question62">简述一下src与href的区别</a><ol>
<li>在 HTML 中，src 属性是用来指定外部资源的 URL，如图像、脚本或嵌入式对象的位置。例如，<img> 标签中的 src 属性指定图像的 URL。</li>
<li>而 href 属性则用来指定超文本链接的目标资源的位置，如超链接或 link 标记中的外部样式表。例如，<a> 标签中的 href 属性指定了链接目标的 URL。</li>
</ol>
</li>
<li><a id="question63">iframe有哪些优缺点？</a><ol>
<li>iframe（内联框架）是一种 HTML 元素，它允许在当前文档中嵌入另一个独立的 HTML 文档。iframe 有一些优点和缺点：</li>
<li>优点：<ol>
<li>内容隔离：iframe 可以将不同来源的内容隔离开来，使得它们在不同的上下文中运行。这有助于保护当前文档免受潜在的安全风险，并确保不同来源的内容不会互相干扰。</li>
<li>异步加载：iframe 中的内容可以异步加载，这意味着页面主体内容可以在 iframe 加载完成之前呈现。这有助于提高页面加载速度。</li>
<li>独立滚动：iframe 内的内容可以独立滚动，而不会影响主页面的滚动。这有助于在需要展示大量内容的情况下，提高用户体验。</li>
<li>跨域资源访问：在一定程度上，iframe 可以用于访问跨域资源，例如嵌入来自其他域的网页或应用。</li>
</ol>
</li>
<li>缺点：<ol>
<li>性能影响：iframe 的使用可能会导致性能下降，因为它需要浏览器加载额外的文档资源。每个嵌入的 iframe 都需要额外的 HTTP 请求，这可能会延长页面加载时间。</li>
<li>复杂性增加：iframe 的使用可能会使页面结构更加复杂，导致维护困难。而且，在 iframe 和主页面之间进行通信可能会涉及到跨域问题，这会增加开发难度。</li>
<li>SEO 不友好：搜索引擎可能无法完全索引 iframe 中的内容，这会影响到网页的搜索引擎优化（SEO）。</li>
<li>可访问性问题：iframe 在某些情况下可能导致可访问性问题。例如，屏幕阅读器可能无法正确解析 iframe 中的内容，导致部分用户无法访问这些内容。</li>
</ol>
</li>
</ol>
</li>
</ol>
<hr>
<ol start="64">
<li><a id="question64">常用的meta标签有哪些？</a><ol>
<li>字符集声明：声明文档使用的字符编码，通常为 UTF-8。<code>&lt;meta charset=&quot;UTF-8&quot;&gt;</code></li>
<li>视口设置：控制页面在移动设备上的显示方式，如缩放级别和页面宽度。<code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</code></li>
<li>页面描述：提供页面的简短描述，有助于搜索引擎了解页面内容。<code>&lt;meta name=&quot;description&quot; content=&quot;A brief description of the page.&quot;&gt;</code></li>
<li>关键词：设置页面关键词，有助于搜索引擎优化（SEO）。但请注意，大多数现代搜索引擎不再使用此标签。<code>&lt;meta name=&quot;keywords&quot; content=&quot;keyword1, keyword2, keyword3&quot;&gt;</code></li>
<li>作者：指定页面作者。<code>&lt;meta name=&quot;author&quot; content=&quot;Author Name&quot;&gt;</code></li>
<li>禁止缓存：告诉浏览器不要缓存页面。<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;meta <span class="hljs-attribute">http-equiv</span>=<span class="hljs-string">&quot;Cache-Control&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-string">&quot;no-cache, no-store, must-revalidate&quot;</span>&gt;<br>&lt;meta <span class="hljs-attribute">http-equiv</span>=<span class="hljs-string">&quot;Pragma&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-string">&quot;no-cache&quot;</span>&gt;<br>&lt;meta <span class="hljs-attribute">http-equiv</span>=<span class="hljs-string">&quot;Expires&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-string">&quot;0&quot;</span>&gt;<br></code></pre></td></tr></table></figure></li>
<li>自动刷新：设置页面在特定时间间隔后自动刷新。<code>&lt;meta http-equiv=&quot;refresh&quot; content=&quot;30&quot;&gt;</code></li>
<li>跳转到其他页面：在指定的时间间隔后，自动将用户重定向到其他页面。<code>&lt;meta http-equiv=&quot;refresh&quot; content=&quot;5; URL=https://example.com/new-page.html&quot;&gt;</code></li>
<li>兼容模式：指定浏览器（如 Internet Explorer）使用特定的渲染模式。<code>&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</code></li>
<li>搜索引擎索引控制：指示搜索引擎是否应索引页面和跟踪链接。<code>&lt;meta name=&quot;robots&quot; content=&quot;index, follow&quot;&gt;</code></li>
</ol>
</li>
</ol>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E5%89%8D%E7%AB%AF/" class="category-chain-item">前端</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>前端八股文</div>
      <div>https://easywz.github.io/2024/02/19/Interview/frontInterviewQuestion/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>汪邹</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年2月19日</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>更新于</div>
          <div>2025年9月3日</div>
        </div>
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
<!-- hexo injector body_end start --><script src="/js/scrollTop.js"></script><!-- hexo injector body_end end --></body>
</html>
