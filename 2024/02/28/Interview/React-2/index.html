

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/index/bk.png">
  <link rel="icon" href="/img/index/bk.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="汪邹">
  <meta name="keywords" content="">
  
    <meta name="description" content="react.js相关面试题">
<meta property="og:type" content="article">
<meta property="og:title" content="react.js">
<meta property="og:url" content="https://easywz.github.io/2024/02/28/Interview/React-2/index.html">
<meta property="og:site_name" content="WZ&#39;s blog">
<meta property="og:description" content="react.js相关面试题">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://easywz.github.io/img/index/interview.jpeg">
<meta property="article:published_time" content="2024-02-28T09:45:59.000Z">
<meta property="article:modified_time" content="2024-09-09T08:18:12.195Z">
<meta property="article:author" content="汪邹">
<meta property="article:tag" content="react">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://easywz.github.io/img/index/interview.jpeg">
  
  
  
  <title>react.js - WZ&#39;s blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"easywz.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>人生在勤，不索何获</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/index/home-1.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="react.js"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-02-28 17:45" pubdate>
          2024年2月28日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          25k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          212 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">react.js</h1>
            
              <p id="updated-time" class="note note-info" style="">
                
                  
                    本文最后更新于 2024年9月9日 下午
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/677917087">资料一</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/438358521">资料二</a></p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ol>
<li>React的严格模式如何使用，有什么用处？</li>
<li>在React中遍历的方法有哪些？</li>
<li>在React中页面重新加载时怎样保留数据？</li>
<li>React必须使用JSX吗？</li>
<li>为什么使用jsx的组件中没有看到使用react却需要引入react</li>
<li>在React中怎么使用async&#x2F;await？</li>
<li>React.Children.map和js的map有什么区别？</li>
<li>React 中的高阶组件运用了什么设计模式？</li>
<li>类组件和函数组件有何不同？</li>
<li>React 中 keys 的作用是什么？</li>
<li>为什么调用 setState 而不是直接改变 state？</li>
<li>React 类组件中 setState 是同步的还是异步的？</li>
<li>React实现缓存的方式有哪些？他们有什么区别？</li>
<li>React的生命周期有哪些？</li>
<li>React 废弃了哪些生命周期？为什么</li>
<li>React 16.X 中 props 改变后在哪个生命周期中处理</li>
<li>React 性能优化在哪个生命周期？它优化的原理是什么？</li>
<li>state 和 props 触发更新的生命周期分别有什么区别？</li>
<li>React中发起网络请求应该在哪个生命周期中进行？为什么？</li>
<li>React 16中新生命周期有哪些</li>
<li>组件通信</li>
<li>如何解决 props 层级过深的问题</li>
<li>组件通信的方式有哪些</li>
<li>对 React Hook 的理解，它的实现原理是什么</li>
<li>为什么 useState 要使用数组而不是对象</li>
<li>React Hooks 解决了哪些问题？</li>
<li>React Hook 的使用限制有哪些？</li>
<li>useEffect 与 useLayoutEffect 的区别</li>
<li>React Hooks在平时开发中需要注意的问题和原因</li>
<li>对虚拟 DOM 的理解？虚拟 DOM 主要做了什么？虚拟 DOM 本身是什么？</li>
<li>React key 是干嘛用的 为什么要加？key 主要是解决哪一类问题的</li>
<li>虚拟 DOM 的引入与直接操作原生 DOM 相比，哪一个效率更高，为什么</li>
<li>React 与 Vue 的 diff 算法有何不同？</li>
<li>React 设计思路，它的理念是什么？</li>
<li>React组件命名推荐的方式是哪个？</li>
<li>react 最新版本解决了什么问题，增加了哪些东西</li>
<li>React 数据持久化有什么实践吗？</li>
<li>对 React 和 Vue 的理解，它们的异同</li>
<li>React中props.children和React.Children的区别</li>
<li>React的状态提升是什么？使用场景有哪些？</li>
<li>React中constructor和getInitialState的区别</li>
<li>React的严格模式如何使用，有什么用处？</li>
<li>同时引用这三个库react.js、react-dom.js和babel.js它们都有什么作用？</li>
<li>对React SSR的理解</li>
<li>HOC相比 mixins 有什么优点？</li>
<li>React的事件和普通的HTML事件有什么不同？</li>
<li>React 事件机制</li>
<li>React 组件中怎么做事件代理？它的原理是什么？</li>
<li>React 高阶组件、Render props、hooks 有什么区别，为什么要不断迭代</li>
<li>对React-Fiber的理解，它解决了什么问题？</li>
<li>React.Component 和 React.PureComponent 的区别</li>
<li>Component, Element, Instance 之间有什么区别和联系？</li>
<li>React.createClass和extends Component的区别有哪些？</li>
<li>React 高阶组件是什么，和普通组件有什么区别，适用什么场景</li>
<li>对componentWillReceiveProps（已更名为UNSAFE_componentWillReceiveProps） 的理解</li>
<li>哪些方法会触发 React 重新渲染？重新渲染 render 会做些什么？</li>
<li>React如何判断什么时候重新渲染组件</li>
<li>React声明组件有哪几种方法，有什么不同？</li>
<li>对React中Fragment的理解，它的使用场景是什么？</li>
<li>React如何获取组件对应的DOM元素？</li>
<li>React中可以在render访问refs吗？为什么？</li>
<li>对React的插槽(Portals)的理解，如何使用，有哪些使用场景</li>
<li>在React中如何避免不必要的render？</li>
<li>对 React-Intl 的理解，它的工作原理？</li>
<li>对 React context 的理解</li>
<li>为什么React并不推荐优先考虑使用Context？</li>
<li>React中什么是受控组件和非控组件？</li>
<li>React中refs的作用是什么？有哪些应用场景？</li>
<li>React组件的构造函数有什么作用？它是必须的吗？</li>
<li>React.forwardRef是什么？它有什么作用</li>
<li>类组件与函数组件有什么异同？</li>
<li>React-Router的实现原理是什么？</li>
<li>如何配置 React-Router 实现路由切换</li>
<li>React-Router怎么设置重定向？</li>
<li>react-router 里的 Link 标签和 a 标签的区别</li>
</ol>
<h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><ol>
<li>React的严格模式如何使用，有什么用处？<ol>
<li>strictMode是一个用来突出显示应用程序中潜在的问题。与Fragment一样，strictMode不会渲染任何可见的UI。它为其后代元素触发额外的检查和警告。可以为应用程序的任何部分启用严格模式。</li>
<li>有助于<ol>
<li>识别不安全的生命周期</li>
<li>关于使用过时字符串 ref API 的警告</li>
<li>关于使用废弃的 findDOMNode 方法的警告</li>
<li>检测意外的副作用</li>
<li>检测过时的 context API</li>
</ol>
</li>
</ol>
</li>
<li>在React中遍历的方法有哪些？<ol>
<li>遍历数组：map &amp;&amp; forEach</li>
<li>遍历对象：map &amp;&amp; for in</li>
</ol>
</li>
<li>在React中页面重新加载时怎样保留数据？<ol>
<li><strong>Redux</strong>： 将页面的数据存储在redux中，在重新加载页面时，获取Redux中的数据；</li>
<li><strong>data.js</strong>： 使用webpack构建的项目，可以建一个文件，data.js，将数据保存data.js中，跳转页面后获取；</li>
<li><strong>sessionStorge</strong>： 在进入选择地址页面之前，componentWillUnMount的时候，将数据存储到sessionStorage中，每次进入页面判断sessionStorage中有没有存储的那个值，有，则读取渲染数据；没有，则说明数据是初始化的状态。返回或进入除了选择地址以外的页面，清掉存储的sessionStorage，保证下次进入是初始化的数据</li>
<li><strong>history API</strong>： History API 的 pushState 函数可以给历史记录关联一个任意的可序列化 state，所以可以在路由 push 的时候将当前页面的一些信息存到 state 中，下次返回到这个页面的时候就能从 state 里面取出离开前的数据重新渲染。react-router 直接可以支持。这个方法适合一些需要临时存储的场景。</li>
</ol>
</li>
<li>React必须使用JSX吗？<ol>
<li>React 并不强制要求使用 JSX。当不想在构建环境中配置有关 JSX 编译时，不在 React 中使用 JSX 会更加方便。</li>
<li>每个 JSX 元素只是调用 React.createElement(component, props, …children) 的语法糖。因此，使用 JSX 可以完成的任何事情都可以通过纯 JavaScript 完成。</li>
</ol>
</li>
<li>为什么使用jsx的组件中没有看到使用react却需要引入react？<ol>
<li>本质上来说JSX是React.createElement(component, props, …children)方法的语法糖。在React 17之前，如果使用了JSX，其实就是在使用React， babel 会把组件转换为 CreateElement 形式。在React 17之后，就不再需要引入，因为 babel 已经可以帮我们自动引入react。</li>
</ol>
</li>
<li>在React中怎么使用async&#x2F;await？<ol>
<li>async&#x2F;await是ES7标准中的新特性。如果是使用React官方的脚手架创建的项目，就可以直接使用。如果是在自己搭建的webpack配置的项目中使用，可能会遇到 regeneratorRuntime is not defined 的异常错误。那么我们就需要引入babel，并在babel中配置使用async&#x2F;await。可以利用babel的 transform-async-to-module-method 插件来转换其成为浏览器支持的语法，虽然没有性能的提升，但对于代码编写体验要更好。</li>
</ol>
</li>
<li>React.Children.map和js的map有什么区别？<ol>
<li>JavaScript中的map不会对为null或者undefined的数据进行处理，而React.Children.map中的map可以处理React.Children为null或者undefined的情况。</li>
</ol>
</li>
<li>React 中的高阶组件运用了什么设计模式？<ol>
<li>使用了装饰模式，高阶组件的运用</li>
<li>装饰模式的特点是不需要改变 被装饰对象 本身，而只是在外面套一个外壳接口。JavaScript 目前已经有了原生装饰器的提案，其用法如下：<code>@testable class MyTestableClass &#123;&#125;</code></li>
</ol>
</li>
<li>类组件和函数组件有何不同？<ol>
<li>在 React 16.8版本（引入钩子）之前，使用基于类的组件来创建需要维护内部状态或利用生命周期方法的组件（即componentDidMount和shouldComponentUpdate）。基于类的组件是 ES6 类，它扩展了 React 的 Component 类，并且至少实现了render()方法。</li>
<li>函数组件是无状态的（同样，小于 React 16.8版本），并返回要呈现的输出。它们渲染 UI 的首选只依赖于属性，因为它们比基于类的组件更简单、更具性能。</li>
</ol>
</li>
<li>React 中 keys 的作用是什么？<ol>
<li>Keys 是 React 用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识。</li>
<li>在 React 中渲染集合时，向每个重复的元素添加关键字对于帮助React跟踪元素与数据之间的关联非常重要。key 应该是唯一ID，最好是 UUID 或收集项中的其他唯一字符串</li>
<li>在集合中添加和删除项目时，不使用键或将索引用作键会导致奇怪的行为。</li>
</ol>
</li>
<li>为什么调用 setState 而不是直接改变 state？<ol>
<li>如果您尝试直接改变组件的状态，React 将无法得知它需要重新渲染组件。通过使用setState()方法，React 可以更新组件的UI。</li>
<li>如果需要基于另一个状态（或属性）更新组件的状态，请向setState()传递一个函数，该函数将 state 和 props 作为其两个参数</li>
</ol>
</li>
<li>React 类组件中 setState 是同步的还是异步的？<ol>
<li>在 React 管理的事件回调和生命周期中，setState 是异步的，而其他时候 setState 都是同步的。这个问题根本原因就是 React 在自己管理的事件回调和生命周期中，对于 setState 是批量更新的，而在其他时候是立即更新的。</li>
<li>批量更新 setState 时，多次执行 setState 只会触发一次 Render 过程。相反在立即更新 setState 时，每次 setState 都会触发一次 Render 过程。</li>
<li>注意：在函数组件中生成的函数是通过闭包引用了 state，而不是通过 this.state 的方式引用 state，所以函数组件的处理函数中 state 一定是旧值，不可能是新值。可以说函数组件已经将这个问题屏蔽掉了。</li>
<li>可以将类组件中的 setState 理解为 函数组件 useState 的第二个返回值。</li>
</ol>
</li>
<li>React实现缓存的方式有哪些？他们有什么区别？<ol>
<li>React 组件中常用 PureComponent、React.memo、hook函数useCallback、useMemo等方法 缓存上次计算的结果。</li>
<li>PureComponent：主要是用在类组件中，使用PureComponent, 每次会对props进行一次浅比较，也可以在shouldComponentUpdate，去做更深层次的比对。</li>
<li>React.memo、hook函数useCallback、useMemo主要应用在函数组件中。</li>
<li></li>
</ol>
</li>
<li>React的生命周期有哪些？<ol>
<li>React 通常将组件生命周期分为三个阶段：<ol>
<li>装载阶段（Mount），组件第一次在DOM树中被渲染的过程；</li>
<li>更新过程（Update），组件状态发生变化，重新更新渲染的过程；</li>
<li>卸载过程（Unmount），组件从DOM树中被移除的过程；</li>
</ol>
</li>
<li>组件挂载阶段<ol>
<li>挂载阶段组件被创建，然后组件实例插入到 DOM 中，完成组件的第一次渲染，该过程只会发生一次，在此阶段会依次调用以下这些方法：<ol>
<li>constructor<ol>
<li>组件的构造函数，第一个被执行，若没有显式定义它，会有一个默认的构造函数，但是若显式定义了构造函数，我们必须在构造函数中执行 super(props)，否则无法在构造函数中拿到this。如果不初始化 state 或不进行方法绑定，则不需要为 React 组件实现构造函数Constructor。</li>
<li>constructor中通常只做两件事：<ol>
<li>初始化组件的 state</li>
<li>给事件处理方法绑定 this <figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-function"><span class="hljs-keyword">constructor</span><span class="hljs-params">(props)</span> <span class="hljs-comment">&#123;</span></span><br><span class="hljs-comment"><span class="hljs-function">  super(props);</span></span><br><span class="hljs-comment"><span class="hljs-function">  // 不要在构造函数中调用 setState，可以直接给 state 设置初始值</span></span><br><span class="hljs-comment"><span class="hljs-function">  this.state = &#123; counter: 0 &#125;</span></span><br><span class="hljs-function">  <span class="hljs-title">this</span>.<span class="hljs-title">handleClick</span> = <span class="hljs-title">this</span>.<span class="hljs-title">handleClick</span>.<span class="hljs-title">bind</span><span class="hljs-params">(this)</span></span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
<li>getDerivedStateFromProps<ol>
<li><code>static getDerivedStateFromProps(props, state)</code></li>
<li>这是个静态方法，所以不能在这个函数里使用 this，有两个参数 props 和 state，分别指接收到的新参数和当前组件的 state 对象，这个函数会返回一个对象用来更新当前的 state 对象，如果不需要更新可以返回 null。</li>
<li>该函数会在装载时，接收到新的 props 或者调用了 setState 和 forceUpdate 时被调用。如当接收到新的属性想修改 state ，就可以使用。</li>
</ol>
</li>
<li>render<ol>
<li>render是React 中最核心的方法，一个组件中必须要有这个方法，它会根据状态 state 和属性 props 渲染组件。这个函数只做一件事，就是返回需要渲染的内容，所以不要在这个函数内做其他业务逻辑，通常调用该方法会返回以下类型中一个：<ol>
<li>React 元素：这里包括原生的 DOM 以及 React 组件；</li>
<li>数组和 Fragment（片段）：可以返回多个元素；</li>
<li>Portals（插槽）：可以将子元素渲染到不同的 DOM 子树种；</li>
<li>字符串和数字：被渲染成 DOM 中的 text 节点；</li>
<li>布尔值或 null：不渲染任何内容。</li>
</ol>
</li>
</ol>
</li>
<li>componentDidMount<ol>
<li>componentDidMount()会在组件挂载后（插入 DOM 树中）立即调。该阶段通常进行以下操作：<ol>
<li>执行依赖于DOM的操作；</li>
<li>发送网络请求；（官方建议）</li>
<li>添加订阅消息（会在componentWillUnmount取消订阅）；</li>
<li>如果在 componentDidMount 中调用 setState ，就会触发一次额外的渲染，多调用了一次 render 函数，由于它是在浏览器刷新屏幕前执行的，所以用户对此是没有感知的，但是我应当避免这样使用，这样会带来一定的性能问题，尽量是在 constructor 中初始化 state 对象。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>组件更新阶段<ol>
<li>当组件的 props 改变了，或组件内部调用了 setState&#x2F;forceUpdate，会触发更新重新渲染，这个过程可能会发生多次。这个阶段会依次调用下面这些方法：<ol>
<li>getDerivedStateFromProps</li>
<li>shouldComponentUpdate<ol>
<li><code>shouldComponentUpdate(nextProps, nextState)</code></li>
<li>在说这个生命周期函数之前，来看两个问题：<ol>
<li>setState 函数在任何情况下都会导致组件重新渲染吗？例如下面这种情况：<ol>
<li><code>this.setState(&#123;number: this.state.number&#125;)</code></li>
<li>如果没有调用 setState，props 值也没有变化，是不是组件就不会重新渲染？</li>
<li>第一个问题答案是 会 </li>
<li>第二个问题如果是父组件重新渲染时，不管传入的 props 有没有变化，都会引起子组件的重新渲染。</li>
<li>有没有什么方法解决在这两个场景下不让组件重新渲染进而提升性能呢</li>
</ol>
</li>
<li>shouldComponentUpdate登场了，这个生命周期函数是用来提升速度的，它是在重新渲染组件开始前触发的，默认返回 true，可以比较 this.props 和 nextProps ，this.state 和 nextState 值是否变化，来确认返回 true 或者 false。当返回 false时，组件的更新过程停止，后续的 render、componentDidUpdate 也不会被调用。</li>
<li>注意： 添加 shouldComponentUpdate 方法时，不建议使用深度相等检查（如使用 JSON.stringify()），因为深比较效率很低，可能会比重新渲染组件效率还低。而且该方法维护比较困难，建议使用该方法会产生明显的性能提升时使用。</li>
</ol>
</li>
</ol>
</li>
<li>render</li>
<li>getSnapshotBeforeUpdate<ol>
<li><code>getSnapshotBeforeUpdate(prevProps, prevState)</code></li>
<li>这个方法在 render 之后，componentDidUpdate 之前调用，有两个参数 prevProps 和 prevState，表示更新之前的 props 和 state，这个函数必须要和 componentDidUpdate 一起使用，并且要有一个返回值，默认是 null，这个返回值作为第三个参数传给 componentDidUpdate。</li>
</ol>
</li>
<li>componentDidUpdate<ol>
<li>componentDidUpdate() 会在更新后会被立即调用，首次渲染不会执行此方法。 该阶段通常进行以下操作：</li>
<li>当组件更新后，对 DOM 进行操作；</li>
<li>如果你对更新前后的 props 进行了比较，也可以选择在此处进行网络请求；（例如，当 props 未发生变化时，则不会执行网络请求）。</li>
<li><code>componentDidUpdate(prevProps, prevState, snapshot)&#123;&#125;</code><ol>
<li>该方法有三个参数：</li>
<li>prevProps: 更新前的props</li>
<li>prevState: 更新前的state</li>
<li>snapshot: getSnapshotBeforeUpdate()生命周期的返回值</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>组件卸载阶段<ol>
<li>卸载阶段只有一个生命周期函数，componentWillUnmount() 会在组件卸载及销毁之前直接调用。在此方法中执行必要的清理操作：<ol>
<li>清除 timer，取消网络请求或清除</li>
<li>取消在 componentDidMount() 中创建的订阅等；</li>
<li>这个生命周期在一个组件被卸载和销毁之前被调用，因此你不应该再这个方法中使用 setState，因为组件一旦被卸载，就不会再装载，也就不会重新渲染。</li>
</ol>
</li>
</ol>
</li>
<li>错误处理阶段<ol>
<li>componentDidCatch(error, info)，此生命周期在后代组件抛出错误后被调用。 它接收两个参数∶<ol>
<li>error：抛出的错误。</li>
<li>info：带有 componentStack key 的对象，其中包含有关组件引发错误的栈信息</li>
</ol>
</li>
</ol>
</li>
<li>React常见生命周期的过程大致如下：<ol>
<li>挂载阶段，首先执行constructor构造方法，来创建组件</li>
<li>创建完成之后，就会执行render方法，该方法会返回需要渲染的内容</li>
<li>随后，React会将需要渲染的内容挂载到DOM树上</li>
<li>挂载完成之后就会执行componentDidMount生命周期函数</li>
<li>如果我们给组件创建一个props（用于组件通信）、调用setState（更改state中的数据）、调用forceUpdate（强制更新组件）时，都会重新调用render函数</li>
<li>render函数重新执行之后，就会重新进行DOM树的挂载</li>
<li>挂载完成之后就会执行componentDidUpdate生命周期函数</li>
<li>当移除组件时，就会执行componentWillUnmount生命周期函数</li>
</ol>
</li>
<li>React主要生命周期总结：<ol>
<li>getDefaultProps：这个函数会在组件创建之前被调用一次（有且仅有一次），它被用来初始化组件的 Props；</li>
<li>getInitialState：用于初始化组件的 state 值；</li>
<li>componentWillMount：在组件创建后、render 之前，会走到 componentWillMount 阶段。React16 直接废弃了这个生命周期</li>
<li>render：这是所有生命周期中唯一一个你必须要实现的方法。一般来说需要返回一个 jsx 元素，这时 React 会根据 props 和 state 来把组件渲染到界面上；不过有时，你可能不想渲染任何东西，这种情况下让它返回 null 或者 false 即可；</li>
<li>componentDidMount：会在组件挂载后（插入 DOM 树中后）立即调用，标志着组件挂载完成。一些操作如果依赖获取到 DOM 节点信息，我们就会放在这个阶段来做。此外，这还是 React 官方推荐的发起 ajax 请求的时机。该方法和 componentWillMount 一样，有且仅有一次调用。</li>
</ol>
</li>
</ol>
</li>
<li>React 废弃了哪些生命周期？为什么？<ol>
<li>componentWillMount</li>
<li>componentWillReceiveProps</li>
<li>componentWillUpdate</li>
</ol>
</li>
<li>React 16.X 中 props 改变后在哪个生命周期中处理<ol>
<li>在getDerivedStateFromProps中进行处理。</li>
</ol>
</li>
<li>React 性能优化在哪个生命周期？它优化的原理是什么？<ol>
<li>react的父级组件的render函数重新渲染会引起子组件的render方法的重新渲染。但是，有的时候子组件的接受父组件的数据没有变动。子组件render的执行会影响性能，这时就可以使用shouldComponentUpdate来解决这个问题。</li>
<li>shouldComponentUpdate提供了两个参数nextProps和nextState，表示下一次props和一次state的值，当函数返回false时候，render()方法不执行，组件也就不会渲染，返回true时，组件照常重渲染。此方法就是拿当前props中值和下一次props中的值进行对比，数据相等时，返回false，反之返回true。</li>
<li>需要注意，在进行新旧对比的时候，是<strong>浅对比</strong>也就是说如果比较的数据时引用数据类型，只要数据的引用的地址没变，即使内容变了，也会被判定为true。面对这个问题，可以使用如下方法进行解决：<ol>
<li>使用setState改变数据之前，先采用ES6中assgin进行拷贝，但是assgin只深拷贝的数据的第一层</li>
<li>使用JSON.parse(JSON.stringfy())进行深拷贝，但是遇到数据为undefined和函数时就会错。</li>
</ol>
</li>
</ol>
</li>
<li>state 和 props 触发更新的生命周期分别有什么区别？<ol>
<li>state 更新流程：shouldComponentUpdate-componentWillUpdate-render-componentDidUpdate</li>
<li>props 更新流程：componentWillReceiveProps-shouldComponentUpdate-componentWillUpdate-render-componentDidUpdate</li>
<li>相对于 state 更新，props 更新后唯一的区别是增加了对 componentWillReceiveProps 的调用。关于 componentWillReceiveProps，需要知道这些事情：<ol>
<li>componentWillReceiveProps：它在Component接受到新的 props 时被触发。</li>
<li>componentWillReceiveProps 会接收一个名为 nextProps 的参数（对应新的 props 值）。该生命周期是 React16 废弃掉的三个生命周期之一。在它被废弃前，可以用它来比较 this.props 和 nextProps 来重新setState。在 React16 中，用一个类似的新生命周期getDerivedStateFromProps 来代替它。</li>
</ol>
</li>
</ol>
</li>
<li>React中发起网络请求应该在哪个生命周期中进行？为什么？<ol>
<li>对于异步请求，最好放在componentDidMount中去操作，对于同步的状态改变，可以放在componentWillMount中，一般用的比较少。</li>
<li>如果认为在componentWillMount里发起请求能提早获得结果，这种想法其实是错误的，通常componentWillMount比componentDidMount早不了多少微秒，网络上任何一点延迟，这一点差异都可忽略不计。</li>
<li>react的生命周期： constructor() -&gt; componentWillMount() -&gt; render() -&gt; componentDidMount()</li>
<li>上面这些方法的调用是有次序的，由上而下依次调用。<ol>
<li>constructor被调用是在组件准备要挂载的最开始，此时组件尚未挂载到网页上。</li>
<li>componentWillMount方法的调用在constructor之后，在render之前，在这方法里的代码调用setState方法不会触发重新render，所以它一般不会用来作加载数据之用。</li>
<li>componentDidMount方法中的代码，是在组件已经完全挂载到网页上才会调用被执行，所以可以保证数据的加载。此外，在这方法中调用setState方法，会触发重新渲染。所以，官方设计这个方法就是用来加载外部数据用的，或处理其他的副作用代码。与组件上的数据无关的加载，也可以在constructor里做，但constructor是做组件state初绐化工作，并不是做加载数据这工作的，constructor里也不能setState，还有加载的时间太长或者出错，页面就无法加载出来。所以有副作用的代码都会集中在componentDidMount方法里。</li>
</ol>
</li>
<li>总结：<ol>
<li>跟服务器端渲染（同构）有关系，如果在componentWillMount里面获取数据，fetch data会执行两次，一次在服务器端一次在客户端。在componentDidMount中可以解决这个问题，componentWillMount同样也会render两次。</li>
<li>在componentWillMount中fetch data，数据一定在render后才能到达，如果忘记了设置初始状态，用户体验不好。</li>
<li>react16.0以后，componentWillMount可能会被执行多次。</li>
</ol>
</li>
</ol>
</li>
<li>React 16中新生命周期有哪些<ol>
<li>React16 自上而下地对生命周期做了另一种维度的解读：<ol>
<li>Render 阶段：用于计算一些必要的状态信息。这个阶段可能会被 React 暂停，这一点和 React16 引入的 Fiber 架构</li>
<li>Pre-commit阶段：所谓“commit”，这里指的是“更新真正的 DOM 节点”这个动作。所谓 Pre-commit，就是说我在这个阶段其实还并没有去更新真实的 DOM，不过 DOM 信息已经是可以读取的了；</li>
<li>Commit 阶段：在这一步，React 会完成真实 DOM 的更新工作。Commit 阶段，我们可以拿到真实 DOM（包括 refs）。</li>
<li>与此同时，新的生命周期在流程方面，仍然遵循“挂载”、“更新”、“卸载”这三个广义的划分方式。它们分别对应到：<ol>
<li>挂载过程：<ol>
<li>constructor</li>
<li>getDerivedStateFromProps</li>
<li>render</li>
<li>componentDidMount</li>
</ol>
</li>
<li>更新过程：<ol>
<li>getDerivedStateFromProps</li>
<li>shouldComponentUpdate</li>
<li>render</li>
<li>getSnapshotBeforeUpdate</li>
<li>componentDidUpdate</li>
</ol>
</li>
<li>卸载过程：<ol>
<li>componentWillUnmount</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>组件通信<ol>
<li>React组件间通信常见的几种情况:<ol>
<li>父组件向子组件通信</li>
<li>子组件向父组件通信</li>
<li>跨级组件通信</li>
<li>非嵌套关系的组件通信</li>
</ol>
</li>
<li>通信方式<ol>
<li>父组件向子组件通信：父组件通过 props 向子组件传递需要的信息。 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 子组件: Child</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">Child</span> = props =&gt;&#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;props.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br>&#125;<br><span class="hljs-comment">// 父组件 Parent</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">Parent</span> = (<span class="hljs-params"></span>)=&gt;&#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;react&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Child</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>子组件向父组件通信：: props+回调的方式。 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 子组件: Child</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">Child</span> = props =&gt;&#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">cb</span> = msg =&gt;&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-function">()=&gt;</span>&#123;<br>          props.<span class="hljs-title function_">callback</span>(msg)<br>      &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;cb(</span>&quot;<span class="hljs-attr">你好</span>!&quot;)&#125;&gt;</span>你好<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>  )<br>&#125;<br><span class="hljs-comment">// 父组件 Parent</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> &#123;<br>    <span class="hljs-title function_">callback</span>(<span class="hljs-params">msg</span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(msg)<br>    &#125;<br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">callback</span>=<span class="hljs-string">&#123;this.callback.bind(this)&#125;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Child</span>&gt;</span></span>    <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>跨级组件的通信方式<ol>
<li>父组件向子组件的子组件通信，向更深层子组件通信：<ol>
<li>使用props，利用中间组件层层传递,但是如果父组件结构较深，那么中间每一层组件都要去传递props，增加了复杂度，并且这些props并不是中间组件自己需要的。</li>
<li>使用context，context相当于一个大容器，可以把要通信的内容放在这个容器中，这样不管嵌套多深，都可以随意取用，对于跨越多层的全局数据可以使用context实现。 <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// context方式实现跨级组件通信 </span><br><span class="hljs-comment">// Context 设计目的是为了共享那些对于一个组件树而言是“全局”的数据</span><br>const <span class="hljs-type">BatteryContext</span> = createContext();<br><span class="hljs-comment">//  子组件的子组件 </span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GrandChild</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>    render()&#123;<br>        <span class="hljs-keyword">return</span> (<br>            &lt;<span class="hljs-type">BatteryContext</span>.<span class="hljs-type">Consumer</span>&gt;<br>                &#123;<br>                    color =&gt; &lt;h1 style=&#123;&#123;<span class="hljs-string">&quot;color&quot;</span>:color&#125;&#125;&gt;我是红色的:&#123;color&#125;&lt;/h1&gt;<br>                &#125;<br>            &lt;/<span class="hljs-type">BatteryContext</span>.<span class="hljs-type">Consumer</span>&gt;<br>        )<br>    &#125;<br>&#125;<br><span class="hljs-comment">//  子组件</span><br>const <span class="hljs-type">Child</span> = () =&gt;&#123;<br>    <span class="hljs-keyword">return</span> (<br>        &lt;<span class="hljs-type">GrandChild</span>/&gt;<br>    )<br>&#125;<br><span class="hljs-comment">// 父组件</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>      state = &#123;<br>          color:<span class="hljs-string">&quot;red&quot;</span><br>      &#125;<br>      render()&#123;<br>          const &#123;color&#125; = <span class="hljs-keyword">this</span>.state<br>          <span class="hljs-keyword">return</span> (<br>          &lt;<span class="hljs-type">BatteryContext</span>.<span class="hljs-type">Provider</span> value=&#123;color&#125;&gt;<br>              &lt;<span class="hljs-type">Child</span>&gt;&lt;/<span class="hljs-type">Child</span>&gt;<br>          &lt;/<span class="hljs-type">BatteryContext</span>.<span class="hljs-type">Provider</span>&gt;<br>          )<br>      &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
<li>非嵌套关系组件的通信方式<ol>
<li>即没有任何包含关系的组件，包括兄弟组件以及不在同一个父级中的非兄弟组件</li>
<li>可以使用自定义事件通信（发布订阅模式）</li>
<li>可以通过redux等进行全局状态管理</li>
<li>如果是兄弟组件通信，可以找到这两个兄弟节点共同的父节点, 结合父子间通信方式进行通信。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>如何解决 props 层级过深的问题<ol>
<li>使用Context API：提供一种组件之间的状态共享，而不必通过显式组件树逐层传递props；</li>
<li>使用Redux等状态库。</li>
</ol>
</li>
<li>组件通信的方式有哪些<ol>
<li>⽗组件向⼦组件通讯: ⽗组件可以向⼦组件通过传 props 的⽅式，向⼦组件进⾏通讯</li>
<li>⼦组件向⽗组件通讯: props+回调的⽅式，⽗组件向⼦组件传递props进⾏通讯，此props为作⽤域为⽗组件⾃身的函 数，⼦组件调⽤该函数，将⼦组件想要传递的信息，作为参数，传递到⽗组件的作⽤域中</li>
<li>兄弟组件通信: 找到这两个兄弟节点共同的⽗节点,结合上⾯两种⽅式由⽗节点转发信息进⾏通信</li>
<li>跨层级通信: Context 设计⽬的是为了共享那些对于⼀个组件树⽽⾔是“全局”的数据，例如当前认证的⽤户、主题或⾸选语⾔，对于跨越多层的全局数据通过 Context 通信再适合不过</li>
<li>发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引⼊event模块进⾏通信</li>
<li>全局状态管理⼯具: 借助Redux或者Mobx等全局状态管理⼯具进⾏通信,这种⼯具会维护⼀个全局状态中⼼Store,并根据不同的事件产⽣新的状态</li>
</ol>
</li>
<li>对 React Hook 的理解，它的实现原理是什么<ol>
<li>React-Hooks 是 React 团队在 React 组件开发实践中，逐渐认知到的一个改进点，这背后其实涉及对类组件和函数组件两种组件形式的思考和侧重。</li>
<li>类组件<ol>
<li>所谓类组件，就是基于 ES6 Class 这种写法，通过继承 React.Component 得来的 React 组件。</li>
<li>React 类组件内部预置了相当多的“现成的东西”等着我们去调度&#x2F;定制，state 和生命周期就是这些“现成东西”中的典型。要想得到这些东西，难度也不大，只需要继承一个 React.Component 即可。</li>
<li>它太繁杂了，对于解决许多问题来说，编写一个类组件实在是一个过于复杂的姿势。复杂的姿势必然带来高昂的理解成本，这也是我们所不想看到的。除此之外，由于开发者编写的逻辑在封装后是和组件粘在一起的，这就使得类组件内部的逻辑难以实现拆分和复用。</li>
</ol>
</li>
<li>函数组件<ol>
<li>函数组件就是以函数的形态存在的 React 组件。早期并没有 React-Hooks，函数组件内部无法定义和维护 state，因此它还有一个别名叫“无状态组件”。</li>
</ol>
</li>
<li>通过对比，从形态上可以对两种组件做区分，它们之间的区别如下：<ol>
<li>类组件需要继承 class，函数组件不需要；</li>
<li>类组件可以访问生命周期方法，函数组件不能；</li>
<li>类组件中可以获取到实例化后的 this，并基于这个 this 做各种各样的事情，而函数组件不可以；</li>
<li>类组件中可以定义并维护 state（状态），而函数组件不可以；</li>
<li>函数组件就真正地将数据和渲染绑定到了一起。函数组件是一个更加匹配其设计理念、也更有利于逻辑拆分与重用的组件表达形式。</li>
</ol>
</li>
<li>React-Hooks 是一套能够使函数组件更强大、更灵活的“钩子”。</li>
</ol>
</li>
<li>为什么 useState 要使用数组而不是对象<ol>
<li>如果 useState 返回的是数组，那么使用者可以对数组中的元素命名，代码看起来也比较干净</li>
<li>如果 useState 返回的是对象，在解构对象的时候必须要和 useState 内部实现返回的对象同名，想要使用多次的话，必须得设置别名才能使用返回值</li>
<li>useState 返回的是 array 而不是 object 的原因就是为了降低使用的复杂度；返回数组的话可以直接根据顺序解构，而返回对象的话要想使用多次就需要定义别名了。</li>
</ol>
</li>
<li>React Hooks 解决了哪些问题？<ol>
<li>在组件之间复用状态逻辑很难</li>
<li>复杂组件变得难以理解</li>
<li>难以理解的 class</li>
</ol>
</li>
<li>React Hook 的使用限制有哪些？<ol>
<li>不要在循环、条件或嵌套函数中调用 Hook；<ol>
<li>因为 Hooks 的设计是基于数组实现。在调用时按顺序加入数组中，如果使用循环、条件或嵌套函数很有可能导致数组取值错位，执行错误的 Hook。当然，实质上 React 的源码里不是数组，是链表。</li>
</ol>
</li>
<li>在 React 的函数组件中调用 Hook。</li>
</ol>
</li>
<li>useEffect 与 useLayoutEffect 的区别<ol>
<li>共同点<ol>
<li>运用效果： useEffect 与 useLayoutEffect 两者都是用于处理副作用，这些副作用包括改变 DOM、设置订阅、操作定时器等。在函数组件内部操作副作用是不被允许的，所以需要使用这两个函数去处理。</li>
<li>使用方式：useEffect 与 useLayoutEffect 两者底层的函数签名是完全一致的，都是调用的 mountEffectImpl方法，在使用上也没什么差异，基本可以直接替换。</li>
</ol>
</li>
<li>不同点<ol>
<li>使用场景： useEffect 在 React 的渲染过程中是被异步调用的，用于绝大多数场景；而 useLayoutEffect 会在所有的 DOM 变更之后同步调用，主要用于处理 DOM 操作、调整样式、避免页面闪烁等问题。也正因为是同步处理，所以需要避免在 useLayoutEffect 做计算量较大的耗时任务从而造成阻塞。</li>
<li>使用效果： useEffect是按照顺序执行代码的，改变屏幕像素之后执行（先渲染，后改变DOM），当改变屏幕内容时可能会产生闪烁；useLayoutEffect是改变屏幕像素之前就执行了（会推迟页面显示的事件，先改变DOM后渲染），不会产生闪烁。useLayoutEffect总是比useEffect先执行。</li>
<li>在未来的趋势上，两个 API 是会长期共存的，暂时没有删减合并的计划，需要开发者根据场景去自行选择。React 团队的建议非常实用，如果实在分不清，先用 useEffect，一般问题不大；如果页面有异常，再直接替换为 useLayoutEffect 即可。</li>
</ol>
</li>
</ol>
</li>
<li>React Hooks在平时开发中需要注意的问题和原因<ol>
<li>不要在循环，条件或嵌套函数中调用Hook，必须始终在 React函数的顶层使用Hook</li>
<li>使用useState时候，使用push，pop，splice等直接更改数组对象的坑<ol>
<li>使用push直接更改数组无法获取到新值，应该采用析构方式，</li>
</ol>
</li>
<li>useState设置状态的时候，只有第一次生效，后期需要更新状态，必须通过useEffect</li>
<li>善用useCallback<ol>
<li>父组件传递给子组件事件句柄时，如果我们没有任何参数变动可能会选用useMemo。但是每一次父组件渲染子组件即使没变化也会跟着渲染一次。</li>
</ol>
</li>
<li>不要滥用useContext<ol>
<li>可以使用基于 useContext 封装的状态管理工具</li>
</ol>
</li>
<li>React Hooks 和生命周期的关系<ol>
<li>函数组件 的本质是函数，没有 state 的概念的，因此不存在生命周期一说，仅仅是一个 render 函数而已。</li>
<li>但是引入 Hooks 之后就变得不同了，它能让组件在不使用 class 的情况下拥有 state，所以就有了生命周期的概念，所谓的生命周期其实就是 useState、 useEffect() 和 useLayoutEffect() 。 </li>
<li>即：Hooks 组件（使用了Hooks的函数组件）有生命周期，而函数组件（未使用Hooks的函数组件）是没有生命周期的。</li>
<li>下面是具体的 class 与 Hooks 的生命周期对应关系：<ol>
<li>constructor：函数组件不需要构造函数，可以通过调用 <strong>useState 来初始化 state</strong>。如果计算的代价比较昂贵，也可以传一个函数给 useState。<ol>
<li><code>const [num, UpdateNum] = useState(0)</code></li>
</ol>
</li>
<li>getDerivedStateFromProps：一般情况下，我们不需要使用它，可以在渲染过程中更新 state，以达到实现 getDerivedStateFromProps 的目的。</li>
<li>render：这是函数组件体本身。</li>
<li>componentDidMount, componentDidUpdate：<ol>
<li>useLayoutEffect 与它们两的调用阶段是一样的。但是，我们推荐你一开始先用 useEffect，只有当它出问题的时候再尝试使用 useLayoutEffect。useEffect 可以表达所有这些的组合。</li>
</ol>
</li>
<li>请记得 React 会等待浏览器完成画面渲染之后才会延迟调用 ，因此会使得额外操作很方便<ol>
<li>componentWillUnmount：相当于 useEffect 里面返回的 cleanup 函数</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>对虚拟 DOM 的理解？虚拟 DOM 主要做了什么？虚拟 DOM 本身是什么？<ol>
<li>为什么要用 Virtual DOM：<ol>
<li>保证性能下限，在不进行手动优化的情况下，提供过得去的性能</li>
<li>跨平台 Virtual DOM本质上是JavaScript的对象，它可以很方便的跨平台操作，比如服务端渲染、uniapp等。</li>
</ol>
</li>
<li>React diff 算法的原理是什么？<ol>
<li>实际上，diff 算法探讨的就是虚拟 DOM 树发生变化后，生成 DOM 树更新补丁的方式。它通过对比新旧两株虚拟 DOM 树的变更差异，将更新补丁作用于真实 DOM，以最小成本完成视图更新。</li>
<li>具体的流程如下：<ol>
<li>真实的 DOM 首先会映射为虚拟 DOM；</li>
<li>当虚拟 DOM 发生变化后，就会根据差距计算生成 patch，这个 patch 是一个结构化的数据，内容包含了增加、更新、移除等；</li>
<li>根据 patch 去更新真实的 DOM，反馈到用户的界面上。</li>
<li>一个生成补丁、更新差异的过程统称为 diff 算法</li>
</ol>
</li>
<li>diff算法可以总结为三个策略，分别从树、组件及元素三个层面进行复杂度的优化：<ol>
<li>策略一：忽略节点跨层级操作场景，提升比对效率。（基于树进行对比）<ol>
<li>这一策略需要进行树比对，即对树进行分层比较。树比对的处理手法是非常“暴力”的，即两棵树只对同一层次的节点进行比较，如果发现节点已经不存在了，则该节点及其子节点会被完全删除掉，不会用于进一步的比较，这就提升了比对效率。</li>
</ol>
</li>
<li>如果组件的 class 一致，则默认为相似的树结构，否则默认为不同的树结构。（基于组件进行对比）<ol>
<li>在组件比对的过程中：<ol>
<li>如果组件是同一类型则进行树比对；</li>
<li>如果不是则直接放入补丁中。</li>
<li>只要父组件类型不同，就会被重新渲染。这也就是为什么 shouldComponentUpdate、PureComponent 及 React.memo 可以提高性能的原因。</li>
</ol>
</li>
</ol>
</li>
<li>策略三：同一层级的子节点，可以通过标记 key 的方式进行列表对比。（基于节点进行对比）<ol>
<li>元素比对主要发生在同层级中，通过标记节点操作生成补丁。节点操作包含了插入、移动、删除等。其中节点重新排序同时涉及插入、移动、删除三个操作，所以效率消耗最大，此时策略三起到了至关重要的作用。通过标记 key 的方式，React 可以直接移动 DOM 节点，降低内耗。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>React key 是干嘛用的 为什么要加？key 主要是解决哪一类问题的<ol>
<li>Keys 是 React 用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识。在开发过程中，我们需要保证某个元素的 key 在其同级元素中具有唯一性。</li>
<li>在 React Diff 算法中 React 会借助元素的 Key 值来判断该元素是新近创建的还是被移动而来的元素，从而减少不必要的元素重渲染此外，React 还需要借助 Key 值来判断元素与本地状态的关联关系。 注意事项：<ol>
<li>key值一定要和具体的元素一一对应；</li>
<li>尽量不要用数组的index去作为key；</li>
<li>不要在render的时候用随机数或者其他操作给元素加上不稳定的key，这样造成的性能开销比不加key的情况下更糟糕。</li>
</ol>
</li>
</ol>
</li>
<li>虚拟 DOM 的引入与直接操作原生 DOM 相比，哪一个效率更高，为什么<ol>
<li>虚拟DOM相对原生的DOM不一定是效率更高，如果只修改一个按钮的文案，那么虚拟 DOM 的操作无论如何都不可能比真实的 DOM 操作更快。</li>
<li>在首次渲染大量DOM时，由于多了一层虚拟DOM的计算，虚拟DOM也会比innerHTML插入慢。它能保证性能下限，在真实DOM操作的时候进行针对性的优化时，还是更快的。所以要根据具体的场景进行探讨。</li>
<li>在整个 DOM 操作的演化过程中，其实主要矛盾并不在于性能，而在于开发者写得爽不爽，在于研发体验&#x2F;研发效率。虚拟 DOM 不是别的，正是前端开发们为了追求更好的研发体验和研发效率而创造出来的高阶产物。虚拟 DOM 并不一定会带来更好的性能，React 官方也从来没有把虚拟 DOM 作为性能层面的卖点对外输出过。</li>
<li>虚拟 DOM 的优越之处在于，它能够在提供更爽、更高效的研发模式（也就是函数式的 UI 编程方式）的同时，仍然保持一个还不错的性能。</li>
</ol>
</li>
<li>React 与 Vue 的 diff 算法有何不同？<ol>
<li>diff 算法是指生成更新补丁的方式，主要应用于虚拟 DOM 树变化后，更新真实 DOM。所以 diff 算法一定存在这样一个过程：触发更新 → 生成补丁 → 应用补丁。</li>
<li>React 的 diff 算法，触发更新的时机主要在 state 变化与 hooks 调用之后。此时触发虚拟 DOM 树变更遍历，采用了深度优先遍历算法。但传统的遍历方式，效率较低。为了优化效率，使用了分治的方式。将单一节点比对转化为了 3 种类型节点的比对，分别是树、组件及元素，以此提升效率。<ol>
<li>树比对：由于网页视图中较少有跨层级节点移动，两株虚拟 DOM 树只对同一层次的节点进行比较。</li>
<li>组件比对：如果组件是同一类型，则进行树比对，如果不是，则直接放入到补丁中。</li>
<li>元素比对：主要发生在同层级中，通过标记节点操作生成补丁，节点操作对应真实的 DOM 剪裁操作。</li>
<li>以上是经典的 React diff 算法内容。自 React 16 起，引入了 Fiber 架构。为了使整个更新过程可随时暂停恢复，节点与树分别采用了 FiberNode 与 FiberTree 进行重构。fiberNode 使用了双链表的结构，可以直接找到兄弟节点与子节点。整个更新过程由 current 与 workInProgress 两株树双缓冲完成。workInProgress 更新完成后，再通过修改 current 相关指针指向新节点。</li>
</ol>
</li>
<li>Vue 的整体 diff 策略与 React 对齐，虽然缺乏时间切片能力，但这并不意味着 Vue 的性能更差，因为在 Vue 3 初期引入过，后期因为收益不高移除掉了。除了高帧率动画，在 Vue 中其他的场景几乎都可以使用防抖和节流去提高响应性能。</li>
</ol>
</li>
<li>React 设计思路，它的理念是什么？<ol>
<li>编写简单直观的代码</li>
<li>简化可复用的组件</li>
<li>Virtual DOM</li>
<li>函数式编程</li>
<li>一次学习，随处编写</li>
</ol>
</li>
<li>React组件命名推荐的方式是哪个？<ol>
<li>通过引用而不是使用来命名组件displayName。<ol>
<li>使用displayName命名组件：<code>export default React.createClass(&#123;  displayName: &#39;TodoApp&#39;,  // ...&#125;)</code></li>
<li>React推荐的方法：<ol>
<li><code>export default class TodoApp extends React.Component &#123;  // ...&#125;</code></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>react 最新版本解决了什么问题，增加了哪些东西<ol>
<li>React 16.x的三大新特性 Time Slicing、Suspense、 hooks<ol>
<li>Time Slicing（解决CPU速度问题）使得在执行任务的期间可以随时暂停，跑去干别的事情，这个特性使得react能在性能极其差的机器跑时，仍然保持有良好的性能</li>
<li>Suspense （解决网络IO问题） 和lazy配合，实现异步加载组件。 能暂停当前组件的渲染， 当完成某件事以后再继续渲染，解决从react出生到现在都存在的「异步副作用」的问题，而且解决得非的优雅，使用的是 T异步但是同步的写法，这是最好的解决异步问题的方式</li>
<li>提供了一个内置函数componentDidCatch，当有错误发生时，可以友好地展示 fallback 组件; 可以捕捉到它的子元素（包括嵌套子元素）抛出的异常; 可以复用错误组件。</li>
</ol>
</li>
<li>React16.8<ol>
<li>加入hooks，让React函数式组件更加灵活，hooks之前，React存在很多问题：<ol>
<li>在组件间复用状态逻辑很难</li>
<li>复杂组件变得难以理解，高阶组件和函数组件的嵌套过深。</li>
<li>class组件的this指向问题</li>
<li>难以记忆的生命周期</li>
</ol>
</li>
<li>hooks很好的解决了上述问题，hooks提供了很多方法<ol>
<li>useState 返回有状态值，以及更新这个状态值的函数</li>
<li>useEffect 接受包含命令式，可能有副作用代码的函数。</li>
<li>useContext 接受上下文对象（从 React.createContext返回的值）并返回当前上下文值，</li>
<li>useReducer useState 的替代方案。接受类型为 （state，action）&#x3D;&gt; newState的reducer，并返回与dispatch方法配对的当前状态。</li>
<li>useCalLback 返回一个回忆的memoized版本，该版本仅在其中一个输入发生更改时才会更改。纯函数的输入输出确定性 o useMemo 纯的一个记忆函数 o useRef 返回一个可变的ref对象，其Current 属性被初始化为传递的参数，返回的 ref 对象在组件的整个生命周期内保持不变。</li>
<li>useImperativeMethods 自定义使用ref时公开给父组件的实例值</li>
<li>useMutationEffect 更新兄弟组件之前，它在React执行其DOM改变的同一阶段同步触发</li>
<li>useLayoutEffect DOM改变后同步触发。使用它来从DOM读取布局并同步重新渲染</li>
</ol>
</li>
</ol>
</li>
<li>React16.9<ol>
<li>重命名 Unsafe 的生命周期方法。新的 UNSAFE_前缀将有助于在代码review和 debug 期间，使这些有问题的字样更突出</li>
<li>废弃 javascrip:形式的 URL。以javascript:开头的URL 非常容易遭受攻击，造成安全漏洞。</li>
<li>废弃”Factory”组件。 工厂组件会导致 React 变大且变慢。</li>
<li>act（）也支持异步函数，并且你可以在调用它时使用 await。</li>
<li>使用 &lt;React.ProfiLer&gt; 进行性能评估。在较大的应用中追踪性能回归可能会很方便</li>
</ol>
</li>
<li>React16.13.0<ol>
<li>支持在渲染期间调用setState，但仅适用于同一组件</li>
<li>可检测冲突的样式规则并记录警告</li>
<li>废弃 unstable_createPortal，使用CreatePortal</li>
<li>将组件堆栈添加到其开发警告中，使开发人员能够隔离bug并调试其程序，这可以清楚地说明问题所在，并更快地定位和修复错误。</li>
</ol>
</li>
<li>react 18<ol>
<li>v18 中我们可以通过 createRoot Api 手动创建 root 节点。</li>
<li>在 v18 之前只在事件处理函数中实现了批处理，在 v18 中所有更新都将自动批处理，包括 promise链、setTimeout等异步代码以及原生事件处理函数。</li>
<li>如果想退出自动批处理立即更新的话，可以使用 ReactDOM.flushSync() 进行包裹。</li>
<li>useTransition :接受传入一个毫秒的参数用来修改最迟更新时间，返回一个过渡期的pending 状态和startTransition函数。</li>
<li>SSR下的 Suspense 组件</li>
<li>useSyncExternalStore:这个 API 可以防止在 concurrent 模式下，任务中断后第三方 store 被修改，恢复任务时出现tearing从而数据不一致问题。用户一般很少使用，大多情况下提供给像 Redux 这样的状态管理库使用，通过 useSyncExternalStore 可以使 React 在 concurrent mode 下，保持自身 state 和来自 Redux 的状态同步。</li>
<li>useInsertionEffect:这个 hook 对现有的专为 React 设计的 css-in-js 库有着很大的作用，可以动态生成新规则与<code>&lt;style&gt;</code>标签一起插入到文档中。</li>
<li>useId:React 一直在向着 SSR 的领域发展，但 SSR 渲染必须保证客户端与服务端生成的HTML结构相匹配。我们平时使用的如Math.random()在SSR 面前是没法保证客户端与服务端之间的 id 唯一性。<ol>
<li>React为了解决这个问题，提出来useOpaqueIdentifier这个hook, 不过它在不同环境会产生不同的结果.<ol>
<li>在服务端会生成一个字符串</li>
<li>在客户端会生成一个对象，必须直接传递给DOM属性</li>
</ol>
</li>
<li>而useId 可以生成客户端与服务端之间的唯一id ，并且返回一个字符串。这样一个组件可以只需调用一次useId ，并将其结果作为整个组件所需的标识符基础（比如拼接不同的字符串），以便生成唯一 id。</li>
</ol>
</li>
<li>useDefferdValue<ol>
<li>React 可以通过 useDefferdValue 允许变量延时更新，同时接受一个可选的延迟更新的最大值。React 将尝试尽快更新延迟值，如果在给定的 timeoutMs 期限内未能完成，它将强制更新。</li>
<li>useDefferdValue 能够很好的展现并发渲染时优先级调整的特性，可以用于延迟计算逻辑比较复杂的状态，让其他组件优先渲染I，等待这个状态更新完毕之后再渲染。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>React 数据持久化有什么实践吗？<ol>
<li>redux-persist</li>
<li>redux-persist会将redux的store中的数据缓存到浏览器的localStorage中</li>
</ol>
</li>
<li>对 React 和 Vue 的理解，它们的异同<ol>
<li>相似之处：<ol>
<li>都将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库</li>
<li>都有自己的构建工具，能让你得到一个根据最佳实践设置的项目模板。</li>
<li>都使用了Virtual DOM（虚拟DOM）提高重绘性能</li>
<li>都有props的概念，允许组件间的数据传递</li>
<li>都鼓励组件化应用，将应用分拆成一个个功能明确的模块，提高复用性</li>
</ol>
</li>
<li>不同之处：<ol>
<li>数据流<ol>
<li>Vue默认支持数据双向绑定，而React一直提倡单向数据流</li>
</ol>
</li>
<li>虚拟DOM<ol>
<li>Vue宣称可以更快地计算出Virtual DOM的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。</li>
<li>对于React而言，每当应用的状态被改变时，全部子组件都会重新渲染。当然，这可以通过 PureComponent&#x2F;shouldComponentUpdate这个生命周期方法来进行控制，但Vue将此视为默认的优化。</li>
</ol>
</li>
<li>组件化<ol>
<li>React与Vue最大的不同是模板的编写。<ol>
<li>Vue鼓励写近似常规HTML的模板。写起来很接近标准 HTML元素，只是多了一些属性。</li>
<li>React推荐你所有的模板通用JavaScript的语法扩展——JSX书写。</li>
</ol>
</li>
<li>React中render函数是支持闭包特性的，所以我们import的组件在render中可以直接调用</li>
<li>在Vue中，由于模板中使用的数据都必须挂在 this 上进行一次中转，所以 import 完组件之后，还需要在 components 中再声明下。</li>
</ol>
</li>
<li>监听数据变化的实现原理不同<ol>
<li>Vue 通过 getter&#x2F;setter 以及一些函数的劫持，能精确知道数据变化，不需要特别的优化就能达到很好的性能</li>
<li>React 默认是通过比较引用的方式进行的，如果不优化PureComponent&#x2F;shouldComponentUpdate）可能导致大量不必要的vDOM的重新渲染。这是因为 Vue 使用的是可变数据，而React更强调数据的不可变。</li>
</ol>
</li>
<li>高阶组<ol>
<li>react可以通过高阶组件（Higher Order Components– HOC）来扩展，而vue需要通过mixins来扩展。</li>
<li>原因高阶组件就是高阶函数，而React的组件本身就是纯粹的函数，所以高阶函数对React来说易如反掌。相反Vue.js使用HTML模板创建视图组件，这时模板无法有效的编译，因此Vue不采用HOC来实现。</li>
</ol>
</li>
<li>构建工具<ol>
<li>React &#x3D;&#x3D;&gt; Create React APP</li>
<li>Vue &#x3D;&#x3D;&gt; vue-cli</li>
</ol>
</li>
<li>跨平台<ol>
<li>React &#x3D;&#x3D;&gt; React Native</li>
<li>Vue &#x3D;&#x3D;&gt; Weex</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>React中props.children和React.Children的区别<ol>
<li>在React中，当涉及组件嵌套，在父组件中使用props.children把所有子组件显示出来 <figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">ParentComponent</span>(props)&#123;<br>	<span class="hljs-keyword">return</span> <span class="hljs-type">(</span><br>		&lt;div&gt;<br>			&#123;props.children&#125;<br>		&lt;/div&gt;<br>	)<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>如果想把父组件中的属性传给所有的子组件，需要使用React.Children方法。</li>
</ol>
</li>
<li>React的状态提升是什么？使用场景有哪些？<ol>
<li>React的状态提升就是用户对子组件操作，子组件不改变自己的状态，通过自己的props把这个操作改变的数据传递给父组件，改变父组件的状态，从而改变受父组件控制的所有子组件的状态，这也是React单项数据流的特性决定的。</li>
<li>官方的原话是：共享 state(状态) 是通过将其移动到需要它的组件的最接近的共同祖先组件来实现的。 这被称为“状态提升(Lifting State Up)”。</li>
<li>概括来说就是<strong>将多个组件需要共享的状态提升到它们最近的父组件上，在父组件上改变这个状态然后通过props分发给子组件</strong>。</li>
</ol>
</li>
<li>React中constructor和getInitialState的区别?<ol>
<li>两者都是用来初始化state的。前者是ES6中的语法，后者是ES5中的语法，新版本的React中已经废弃了该方法。 getInitialState是ES5中的方法，如果使用createClass方法创建一个Component组件，可以自动调用它的getInitialState方法来获取初始化的State对象，</li>
</ol>
</li>
<li>React的严格模式如何使用，有什么用处？<ol>
<li>StrictMode是一个用来突出显示应用程序中潜在问题的工具。与Fragment一样，StrictMode不会渲染任何可见的 UI。它为其后代元素触发额外的检查和警告。 可以为应用程序的任何部分启用严格模式。</li>
</ol>
</li>
<li>同时引用这三个库react.js、react-dom.js和babel.js它们都有什么作用？<ol>
<li>react：包含react所必须的核心代码</li>
<li>react-dom：react渲染在不同平台所需要的核心代码</li>
<li>babel：将jsx转换成React代码的工具</li>
</ol>
</li>
<li>对React SSR的理解<ol>
<li>服务端渲染是数据与模版组成的html，即 HTML &#x3D; 数据 ＋ 模版。将组件或页面通过服务器生成html字符串，再发送到浏览器，最后将静态标记”混合”为客户端上完全交互的应用程序。页面没使用服务渲染，当请求页面时，返回的body里为空，之后执行js将html结构注入到body里，结合css显示出来;</li>
<li>SSR的优势：<ol>
<li>对SEO友好</li>
<li>所有的模版、图片等资源都存在服务器端</li>
<li>一个html返回所有数据</li>
<li>减少HTTP请求</li>
<li>响应快、用户体验好、首屏渲染快</li>
</ol>
</li>
<li>SSR的局限：<ol>
<li>服务端压力较大 本来是通过客户端完成渲染，现在统一到服务端node服务去做。尤其是高并发访问的情况，会大量占用服务端CPU资源;</li>
<li>开发条件受限 在服务端渲染中，只会执行到componentDidMount之前的生命周期钩子，因此项目引用的第三方的库也不可用其它生命周期钩子，这对引用库的选择产生了很大的限制;</li>
<li>学习成本相对较高 除了对webpack、MVVM框架要熟悉，还需要掌握node、 Koa2等相关技术。相对于客户端渲染，项目构建、部署过程更加复杂。</li>
</ol>
</li>
</ol>
</li>
<li>HOC相比 mixins 有什么优点？<ol>
<li>HOC 和 Vue 中的 mixins 作用是一致的，并且在早期 React 也是使用 mixins 的方式。但是在使用 class 的方式创建组件以后，mixins 的方式就不能使用了，并且其实 mixins 也是存在一些问题的，比如：<ol>
<li>隐含了一些依赖，比如我在组件中写了某个 state 并且在 mixin 中使用了，就这存在了一个依赖关系。万一下次别人要移除它，就得去 mixin 中查找依赖</li>
<li>多个 mixin 中可能存在相同命名的函数，同时代码组件中也不能出现相同命名的函数，否则就是重写了。</li>
<li>雪球效应，虽然我一个组件还是使用着同一个 mixin，但是一个 mixin 会被多个组件使用，可能会存在需求使得 mixin 修改原本的函数或者新增更多的函数，这样可能就会产生一个维护成本</li>
</ol>
</li>
</ol>
</li>
<li>React的事件和普通的HTML事件有什么不同？<ol>
<li>对于事件名称命名方式，原生事件为全小写，react 事件采用小驼峰；</li>
<li>对于事件函数处理语法，原生事件为字符串，react 事件为函数；</li>
<li>react 事件不能采用 return false 的方式来阻止浏览器的默认行为，而必须要地明确地调用preventDefault()来阻止默认行为。</li>
<li>合成事件是 react 模拟原生 DOM 事件所有能力的一个事件对象，其优点如下：<ol>
<li>兼容所有浏览器，更好的跨平台；</li>
<li>将事件统一存放在一个数组，避免频繁的新增与删除（垃圾回收）。</li>
<li>方便 react 统一管理和事务机制。</li>
<li>事件的执行顺序为原生事件先执行，合成事件后执行，合成事件会沿着fiber树模拟的dom树发生捕获和冒泡，最终会冒泡到 render 选择的容器节点上。</li>
</ol>
</li>
</ol>
</li>
<li>React 事件机制<ol>
<li>React中的事件是一个合成事件（SyntheticEvent），合成事件指的是react用js模拟了一个Dom事件流（类似，fiber树模拟Dom树结构） 合成事件的事件流在fiber树中发生捕获和冒泡。</li>
<li>React 根据 W3C 规范来定义这些合成事件，它的产生主要有两方面原因： <ol>
<li>统一解决了跨浏览器的兼容性问题 </li>
<li>避免这类DOM事件滥用，如果DOM上绑定了过多的事件处理函数，整个页面响应以及内存占用可能都会受到影响</li>
<li>React并不是将click事件绑在该 div 的真实DOM上，而是在document处监听所有支持的事件，当事件发生并冒泡至document处时，React将事件内容封装并交由真正的处理函数运行。 其中，由于event对象是复用的，事件处理函数执行完后，属性会被清空，所以event的属性无法被异步访问，详情请查阅event-pooling</li>
</ol>
</li>
</ol>
</li>
<li>React 组件中怎么做事件代理？它的原理是什么？<ol>
<li>React基于Virtual DOM实现了一个SyntheticEvent层（合成事件层），定义的事件处理器会接收到一个合成事件对象的实例，它符合W3C标准，且与原生的浏览器事件拥有同样的接口，支持冒泡机制，所有的事件都自动绑定在最外层上。在React底层，主要对合成事件做了两件事：<ol>
<li>事件委派： React会把所有的事件绑定到结构的最外层，使用统一的事件监听器，这个事件监听器上维持了一个映射来保存所有组件内部事件监听和处理函数。</li>
<li>自动绑定： React组件中，每个方法的上下文都会指向该组件的实例，即自动绑定this为当前组件。</li>
</ol>
</li>
</ol>
</li>
<li>React 高阶组件、Render props、hooks 有什么区别，为什么要不断迭代<ol>
<li>这三者是目前react解决代码复用的主要方式：<ol>
<li>高阶组件（HOC）：是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。具体而言，高阶组件是参数为组件，返回值为新组件的函数。</li>
<li>render props：是指一种在 React 组件之间使用一个值为函数的 prop 共享代码的简单技术，更具体的说，render prop 是一个用于告知组件需要渲染什么内容的函数 prop。</li>
<li>通常，render props 和高阶组件只渲染一个子节点。让 Hook 来服务这个使用场景更加简单。这两种模式仍有用武之地，（例如，一个虚拟滚动条组件或许会有一个 renderltem 属性，或是一个可见的容器组件或许会有它自己的 DOM 结构）。但在大部分场景下，Hook 足够了，并且能够帮助减少嵌套。<ol>
<li>HOC 官方解释∶ 高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。</li>
<li>简言之，HOC是一种组件的设计模式，HOC接受一个组件和额外的参数（如果需要），返回一个新的组件。HOC 是纯函数，没有副作用。</li>
<li>HOC的优缺点∶<ol>
<li>优点∶ 逻辑服用、不影响被包裹组件的内部逻辑。</li>
<li>缺点∶ hoc传递给被包裹组件的props容易和被包裹后的组件重名，进而被覆盖</li>
</ol>
</li>
</ol>
</li>
<li>Render props 官方解释∶”render prop”是指一种在 React 组件之间使用一个值为函数的 prop 共享代码的简单技术<ol>
<li>具有render prop 的组件接受一个返回React元素的函数，将render的渲染逻辑注入到组件内部。在这里，”render”的命名可以是任何其他有效的标识符。</li>
<li>由此可以看到，render props的优缺点也很明显∶<ol>
<li>优点：数据共享、代码复用，将组件内的state作为props传递给调用者，将渲染逻辑交给调用者。</li>
<li>缺点：无法在 return 语句外访问数据、嵌套写法不够优雅</li>
</ol>
</li>
</ol>
</li>
<li>Hooks 官方解释∶ Hook是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。通过自定义hook，可以复用代码逻辑。</li>
<li>总结:<ol>
<li>Hoc、render props和hook都是为了解决代码复用的问题</li>
<li>但是hoc和render props都有特定的使用场景和明显的缺点</li>
<li>hook是react16.8更新的新的API，让组件逻辑复用更简洁明了，同时也解决了hoc和render props的一些缺点。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>对React-Fiber的理解，它解决了什么问题？<ol>
<li>React V15 在渲染时，会递归比对 VirtualDOM 树，找出需要变动的节点，然后同步更新它们， 一气呵成。这个过程期间， React 会占据浏览器资源，这会导致用户触发的事件得不到响应，并且会导致掉帧，导致用户感觉到卡顿。</li>
<li>为了给用户制造一种应用很快的“假象”，不能让一个任务长期霸占着资源。 可以将浏览器的渲染、布局、绘制、资源加载(例如 HTML 解析)、事件响应、脚本执行视作操作系统的“进程”，需要通过某些调度策略合理地分配 CPU 资源，从而提高浏览器的用户响应速率, 同时兼顾任务执行效率。</li>
<li>所以 React 通过Fiber 架构，让这个执行过程变成可被中断。“适时”地让出 CPU 执行权，除了可以让浏览器及时地响应用户的交互，还有其他好处:<ol>
<li>分批延时对DOM进行操作，避免一次性操作大量 DOM 节点，可以得到更好的用户体验；</li>
<li>给浏览器一点喘息的机会，它会对代码进行编译优化（JIT）及进行热代码优化，或者对 reflow 进行修正。</li>
</ol>
</li>
<li>核心思想: <ol>
<li>Fiber 也称协程或者纤程。它和线程并不一样，协程本身是没有并发或者并行能力的（需要配合线程），它只是一种控制流程的让出机制。让出 CPU 的执行权，让 CPU 能在这段时间执行其他的操作。渲染的过程可以被中断，可以将控制权交回浏览器，让位给高优先级的任务，浏览器空闲后再恢复渲染。</li>
</ol>
</li>
</ol>
</li>
<li>React.Component 和 React.PureComponent 的区别<ol>
<li>React.Component 就是react得到普通组件。</li>
<li>PureComponent表示一个纯组件，可以用来优化React程序，减少render函数执行的次数，从而提高组件的性能。</li>
<li>在React中，当prop或者state发生变化时，可以通过在shouldComponentUpdate生命周期函数中执行return false来阻止页面的更新，从而减少不必要的render执行。React.PureComponent会自动执行 shouldComponentUpdate。</li>
<li>不过，pureComponent中的 shouldComponentUpdate() 进行的是浅比较，也就是说如果是引用数据类型的数据，只会比较不是同一个地址，而不会比较这个地址里面的数据是否一致。浅比较会忽略属性和或状态突变情况，其实也就是数据引用指针没有变化，而数据发生改变的时候render是不会执行的。如果需要重新渲染那么就需要重新开辟空间引用数据。PureComponent一般会用在一些纯展示组件上。</li>
<li>使用pureComponent的好处：当组件更新时，如果组件的props或者state都没有改变，render函数就不会触发。省去虚拟DOM的生成和对比过程，达到提升性能的目的。这是因为react自动做了一层浅比较。</li>
</ol>
</li>
<li>Component, Element, Instance 之间有什么区别和联系？<ol>
<li>组件： 一个组件component可以通过多种方式声明。可以是带有一个render()方法的类，简单点也可以定义为一个函数。这两种情况下，它都把属性props作为输入，把返回的一棵元素树作为输出。</li>
<li>元素： 一个元素element是一个普通对象(plain object)，描述了对于一个DOM节点或者其他组件component，你想让它在屏幕上呈现成什么样子。元素element可以在它的属性props中包含其他元素(译注:用于形成元素树)。创建一个React元素element成本很低。元素element创建之后是不可变的。</li>
<li>实例： 一个实例instance是你在所写的组件类component class中使用关键字this所指向的东西(译注:组件实例)。它用来存储本地状态和响应生命周期事件很有用。</li>
<li>函数式组件(Functional component)根本没有实例instance。类组件(Class component)有实例instance，但是永远也不需要直接创建一个组件的实例，因为React帮我们做了这些。</li>
</ol>
</li>
<li>React.createClass和extends Component的区别有哪些？<ol>
<li>语法区别<ol>
<li>createClass本质上是一个工厂函数，extends的方式更加接近最新的ES6规范的class写法。两种方式在语法上的差别主要体现在方法的定义和静态属性的声明上。</li>
<li>createClass方式的方法定义使用逗号，隔开，因为creatClass本质上是一个函数，传递给它的是一个Object；而class的方式定义方法时务必谨记不要使用逗号隔开，这是ES6 class的语法规范。</li>
</ol>
</li>
<li>propType 和 getDefaultProps<ol>
<li>React.createClass：通过proTypes对象和getDefaultProps()方法来设置和获取props.</li>
<li>React.Component：通过设置两个属性propTypes和defaultProps</li>
</ol>
</li>
<li>状态的区别<ol>
<li>React.createClass：通过getInitialState()方法返回一个包含初始值的对象</li>
<li>React.Component：通过constructor设置初始状态</li>
</ol>
</li>
<li>this区别<ol>
<li>React.createClass：会正确绑定this</li>
<li>React.Component：由于使用了 ES6，这里会有些微不同，属性并不会自动绑定到 React 类的实例上。</li>
</ol>
</li>
<li>Mixins<ol>
<li>React.createClass：使用 React.createClass 的话，可以在创建组件时添加一个叫做 mixins 的属性，并将可供混合的类的集合以数组的形式赋给 mixins。</li>
<li>如果使用 ES6 的方式来创建组件，那么 React mixins 的特性将不能被使用了。</li>
</ol>
</li>
</ol>
</li>
<li>React 高阶组件是什么，和普通组件有什么区别，适用什么场景<ol>
<li>高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。</li>
<li>高阶组件（HOC）就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件，它只是一种组件的设计模式，这种设计模式是由react自身的组合性质必然产生的。我们将它们称为纯组件，因为它们可以接受任何动态提供的子组件，但它们不会修改或复制其输入组件中的任何行为。</li>
<li>适用场景<ol>
<li>代码复用，逻辑抽象</li>
<li>渲染劫持</li>
<li>State 抽象和更改</li>
<li>Props 更改</li>
</ol>
</li>
<li>具体应用例子<ol>
<li>权限控制： 利用高阶组件的 条件渲染 特性可以对页面进行权限控制，权限控制一般分为两个维度：页面级别和 页面元素级别</li>
<li>组件渲染性能追踪： 借助父组件子组件生命周期规则捕获子组件的生命周期，可以方便的对某个组件的渲染时间进行记录</li>
<li>页面复用</li>
</ol>
</li>
</ol>
</li>
<li>对componentWillReceiveProps（已更名为UNSAFE_componentWillReceiveProps） 的理解<ol>
<li>该方法当props发生变化时执行，初始化render时不执行，在这个回调函数里面，你可以根据属性的变化，通过调用this.setState()来更新你的组件状态，旧的属性还是可以通过this.props来获取,这里调用更新状态是安全的，并不会触发额外的render调用。</li>
<li>使用好处： 在这个生命周期中，可以在子组件的render函数执行前获取新的props，从而更新子组件自己的state。 可以将数据请求放在这里进行执行，需要传的参数则从componentWillReceiveProps(nextProps)中获取。而不必将所有的请求都放在父组件中。于是该请求只会在该组件渲染时才会发出，从而减轻请求负担。</li>
<li>componentWillReceiveProps在初始化render的时候不会执行，它会在Component接受到新的状态(Props)时被触发，一般用于父组件状态更新时子组件的重新渲染。</li>
<li>注意：React官网已经把componentWillReceiveProps重名为UNSAFE_componentWillReceiveProps，可以用getDerivedStateFromProps替代。</li>
</ol>
</li>
<li>哪些方法会触发 React 重新渲染？重新渲染 render 会做些什么？<ol>
<li>setState（）方法被调用<ol>
<li>setState 是 React 中最常用的命令，通常情况下，执行 setState 会触发 render。但是这里有个点值得关注，执行 setState 的时候不一定会重新渲染。当 setState 传入 null 时，并不会触发 render。</li>
<li>父组件重新渲染<ol>
<li>只要父组件重新渲染了，即使传入子组件的 props 未发生变化，那么子组件也会重新渲染，进而触发 render</li>
</ol>
</li>
<li>重新渲染 render 会做些什么?<ol>
<li>会对新旧 VNode 进行对比，也就是我们所说的Diff算法。</li>
<li>对新旧两棵树进行一个深度优先遍历，这样每一个节点都会一个标记，在到深度遍历的时候，每遍历到一和个节点，就把该节点和新的节点树进行对比，如果有差异就放到一个对象里面</li>
<li>遍历差异对象，根据差异的类型，根据对应对规则更新VNode</li>
<li>React 的处理 render 的基本思维模式是每次一有变动就会去重新渲染整个应用。</li>
<li>在 Virtual DOM 没有出现之前，最简单的方法就是直接调用 innerHTML。「Virtual DOM厉害的地方并不是说它比直接操作 DOM 快，而是说不管数据怎么变，都会尽量以最小的代价去更新 DOM。」</li>
<li>React 将 render 函数返回的虚拟 DOM 树与老的进行比较，从而确定 DOM 要不要更新、怎么更新。当 DOM 树很大时，遍历两棵树进行各种比对还是相当耗性能的，特别是在顶层 setState 一个微小的修改，默认会去遍历整棵树。尽管 React 使用高度优化的 Diff 算法，但是这个过程仍然会损耗性能.</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>React如何判断什么时候重新渲染组件？<ol>
<li>组件状态的改变可以因为props的改变，或者直接通过setState方法改变。组件获得新的状态，然后React决定是否应该重新渲染组件。只要组件的state发生变化，React就会对组件进行重新渲染。这是因为React中的shouldComponentUpdate方法默认返回true，这就是导致每次更新都重新渲染的原因。</li>
<li>当React将要渲染组件时会执行shouldComponentUpdate方法来看它是否返回true（组件应该更新，也就是重新渲染）。所以需要重写shouldComponentUpdate方法让它根据情况返回true或者false来告诉React什么时候重新渲染什么时候跳过重新渲染。</li>
</ol>
</li>
<li>React声明组件有哪几种方法，有什么不同？<ol>
<li>函数式定义的无状态组件</li>
<li>ES5原生方式React.createClass定义的组件</li>
<li>ES6形式的extends React.Component定义的组件</li>
<li>不同：<ol>
<li>无状态函数式组件 它是为了创建纯展示组件，这种组件只负责根据传入的props来展示，不涉及到state状态的操作 组件不会被实例化，整体渲染性能得到提升，不能访问this对象，不能访问生命周期的方法</li>
<li>ES5 原生方式 React.createClass RFC React.createClass会自绑定函数方法，导致不必要的性能开销，增加代码过时的可能性。</li>
<li>E6继承形式 React.Component RCC 目前极为推荐的创建有状态组件的方式，最终会取代React.createClass形式；相对于 React.createClass可以更好实现代码复用。</li>
<li>无状态组件相对于于后者的区别： 与无状态组件相比，React.createClass和React.Component都是创建有状态的组件，这些组件是要被实例化的，并且可以访问组件的生命周期方法。</li>
</ol>
</li>
</ol>
</li>
<li>对React中Fragment的理解，它的使用场景是什么？<ol>
<li>在React中，组件返回的元素只能有一个根元素。为了不添加多余的DOM节点，我们可以使用Fragment标签来包裹所有的元素，Fragment标签不会渲染出任何元素。React官方对Fragment的解释：<ol>
<li>React 中的一个常见模式是一个组件返回多个元素。Fragments 允许你将子列表分组，而无需向 DOM 添加额外节点。</li>
</ol>
</li>
</ol>
</li>
<li>React如何获取组件对应的DOM元素？<ol>
<li>可以用ref来获取某个子节点的实例，然后通过当前class组件实例的一些特定属性来直接获取子节点实例。ref有三种实现方法:<ol>
<li>字符串格式：字符串格式，这是React16版本之前用得最多的，例如：<p ref="info">span</p></li>
<li>函数格式：ref对应一个方法，该方法有一个参数，也就是对应的节点实例，例如：&lt;p ref&#x3D;{ele &#x3D;&gt; this.info &#x3D; ele}&gt;</p></li>
<li>createRef方法：React 16提供的一个API，使用React.createRef()来实现</li>
</ol>
</li>
</ol>
</li>
<li>React中可以在render访问refs吗？为什么？<ol>
<li>不可以，render 阶段 DOM 还没有生成，无法获取 DOM。DOM 的获取需要在 pre-commit 阶段和 commit 阶段：</li>
</ol>
</li>
<li>对React的插槽(Portals)的理解，如何使用，有哪些使用场景<ol>
<li>React 官方对 Portals 的定义：<ol>
<li>Portal 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的优秀的方案</li>
<li>Portals 是React 16提供的官方解决方案，使得组件可以脱离父组件层级挂载在DOM树的任何位置。</li>
<li>通俗来讲，就是我们 render 一个组件，但这个组件的 DOM 结构并不在本组件内。Portals语法如下：<code>ReactDOM.createPortal(child, container);</code>第一个参数 child 是可渲染的 React 子项，比如元素，字符串或者片段等;第二个参数 container 是一个 DOM 元素。</li>
<li>一般情况下，组件的render函数返回的元素会被挂载在它的父级组件上</li>
<li>然而，有些元素需要被挂载在更高层级的位置。最典型的应用场景：当父组件具有overflow: hidden或者z-index的样式设置时，组件有可能被其他元素遮挡，这时就可以考虑要不要使用Portal使组件的挂载脱离父组件。例如：对话框，模态窗。</li>
</ol>
</li>
</ol>
</li>
<li>在React中如何避免不必要的render？<ol>
<li>React 基于虚拟 DOM 和高效 Diff 算法的完美配合，实现了对 DOM 最小粒度的更新。大多数情况下，React 对 DOM 的渲染效率足以业务日常。但在个别复杂业务场景下，性能问题依然会困扰我们。此时需要采取一些措施来提升运行性能，其很重要的一个方向，就是避免不必要的渲染（Render）。这里提下优化的点：<ol>
<li>shouldComponentUpdate 和 PureComponent<ol>
<li>在 React 类组件中，可以利用 shouldComponentUpdate或者 PureComponent 来减少因父组件更新而触发子组件的 render，从而达到目的。shouldComponentUpdate 来决定是否组件是否重新渲染，如果不希望组件重新渲染，返回 false 即可。</li>
</ol>
</li>
<li>利用高阶组件<ol>
<li>在函数组件中，并没有 shouldComponentUpdate 这个生命周期，可以利用高阶组件，封装一个类似 PureComponet 的功能</li>
</ol>
</li>
<li>使用 React.memo<ol>
<li>React.memo 是 React 16.6 新的一个 API，用来缓存组件的渲染，避免不必要的更新，其实也是一个高阶组件，与 PureComponent 十分类似，但不同的是， React.memo只能用于函数组件。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>对 React-Intl 的理解，它的工作原理？<ol>
<li>React-intl是雅虎的语言国际化开源项目FormatJS的一部分，通过其提供的组件和API可以与ReactJS绑定。</li>
<li>React-intl提供了两种使用方法，一种是引用React组件，另一种是直接调取API，官方更加推荐在React项目中使用前者，只有在无法使用React组件的地方，才应该调用框架提供的API。它提供了一系列的React组件，包括数字格式化、字符串格式化、日期格式化等。</li>
<li>在React-intl中，可以配置不同的语言包，他的工作原理就是根据需要，在语言包之间进行切换。</li>
</ol>
</li>
<li>对 React context 的理解<ol>
<li>在React中，数据传递一般使用props传递数据，维持单向数据流，这样可以让组件之间的关系变得简单且可预测，但是单项数据流在某些场景中并不适用。单纯一对的父子组件传递并无问题，但要是组件之间层层依赖深入，props就需要层层传递显然，这样做太繁琐了。</li>
<li>Context 提供了一种在组件之间共享此类值的方式，而不必显式地通过组件树的逐层传递 props。</li>
<li>可以把context当做是特定一个组件树内共享的store，用来做数据传递。简单说就是，当你不想在组件树中通过逐层传递props或者state的方式来传递数据时，可以使用Context来实现跨层级的组件数据传递。</li>
<li>JS的代码块在执行期间，会创建一个相应的作用域链，这个作用域链记录着运行时JS代码块执行期间所能访问的活动对象，包括变量和函数，JS程序通过作用域链访问到代码块内部或者外部的变量和函数。</li>
<li>假如以JS的作用域链作为类比，React组件提供的Context对象其实就好比一个提供给子组件访问的作用域，而 Context对象的属性可以看成作用域上的活动对象。由于组件 的 Context 由其父节点链上所有组件通 过 getChildContext（）返回的Context对象组合而成，所以，组件通过Context是可以访问到其父组件链上所有节点组件提供的Context的属性。</li>
</ol>
</li>
<li>为什么React并不推荐优先考虑使用Context？<ol>
<li>context的更新需要通过setState()触发，但是这并不是很可靠的，Context支持跨组件的访问，但是如果中间的子组件通过一些方法不影响更新，比如 shouldComponentUpdate() 返回false 那么不能保证Context的更新一定可以使用Context的子组件，因此，Context的可靠性需要关注</li>
</ol>
</li>
<li>React中什么是受控组件和非控组件？<ol>
<li>受控组件<ol>
<li>在使用表单来收集用户输入时，例如<code>&lt;input&gt;&lt;select&gt;&lt;textearea&gt;</code>等元素都要绑定一个change事件，当表单的状态发生变化，就会触发onChange事件，更新组件的state。这种组件在React中被称为受控组件，在受控组件中，组件渲染出的状态与它的value或checked属性相对应，react通过这种方式消除了组件的局部状态，使整个状态可控。react官方推荐使用受控表单组件。</li>
<li>受控组件更新state的流程：<ol>
<li>可以通过初始state中设置表单的默认值</li>
<li>每当表单的值发生变化时，调用onChange事件处理器</li>
<li>事件处理器通过事件对象e拿到改变后的状态，并更新组件的state</li>
<li>一旦通过setState方法更新state，就会触发视图的重新渲染，完成表单组件的更新</li>
</ol>
</li>
<li>受控组件缺陷：<ol>
<li>表单元素的值都是由React组件进行管理，当有多个输入框，或者多个这种组件时，如果想同时获取到全部的值就必须每个都要编写事件处理函数，这会让代码看着很臃肿，所以为了解决这种情况，出现了非受控组件。</li>
</ol>
</li>
</ol>
</li>
<li>非受控组件<ol>
<li>如果一个表单组件没有value props（单选和复选按钮对应的是checked props）时，就可以称为非受控组件。在非受控组件中，可以使用一个ref来从DOM获得表单值。而不是为每个状态更新编写一个事件处理程序。</li>
</ol>
</li>
<li>总结<ol>
<li>页面中所有输入类的DOM如果是现用现取的称为非受控组件，而通过setState将输入的值维护到了state中，需要时再从state中取出，这里的数据就受到了state的控制，称为受控组件。</li>
</ol>
</li>
</ol>
</li>
<li>React中refs的作用是什么？有哪些应用场景？<ol>
<li>Refs 提供了一种方式，用于访问在 render 方法中创建的 React 元素或 DOM 节点。Refs 应该谨慎使用，如下场景使用 Refs 比较适合：<ol>
<li>处理焦点、文本选择或者媒体的控制</li>
<li>触发必要的动画</li>
<li>集成第三方 DOM 库</li>
</ol>
</li>
<li>Refs 是使用 React.createRef() 方法创建的，他通过 ref 属性附加到 React 元素上。要在整个组件中使用 Refs，需要将 ref 在构造函数中分配给其实例属性</li>
<li>由于函数组件没有实例，因此不能在函数组件上直接使用ref;但可以通过闭合的帮助在函数组件内部进行使用 Refs：</li>
<li>注意：<ol>
<li>不应该过度的使用 Refs</li>
<li>ref 的返回值取决于节点的类型<ol>
<li>当 ref 属性被用于一个普通的 HTML 元素时，React.createRef() 将接收底层 DOM 元素作为他的 current 属性以创建 ref。</li>
<li>当 ref 属性被用于一个自定义的类组件时，ref 对象将接收该组件已挂载的实例作为他的 current。</li>
</ol>
</li>
<li>当在父组件中需要访问子组件中的 ref 时可使用传递 Refs 或回调 Refs</li>
</ol>
</li>
</ol>
</li>
<li>React组件的构造函数有什么作用？它是必须的吗？<ol>
<li>构造函数主要用于两个目的：<ol>
<li>通过将对象分配给this.state来初始化本地状态</li>
<li>将事件处理程序方法绑定到实例上</li>
</ol>
</li>
<li>构造函数用来新建父类的this对象；子类必须在constructor方法中调用super方法；否则新建实例时会报错；因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法；子类就得不到this对象。</li>
<li>注意：<ol>
<li>constructor () 必须配上 super(), 如果要在constructor 内部使用 this.props 就要 传入props , 否则不用</li>
<li>JavaScript中的 bind 每次都会返回一个新的函数, 为了性能等考虑, 尽量在constructor中绑定事件</li>
</ol>
</li>
</ol>
</li>
<li>React.forwardRef是什么？它有什么作用？<ol>
<li>React.forwardRef 会创建一个React组件，这个组件能够将其接受的 ref 属性转发到其组件树下的另一个组件中。这种技术并不常见，但在以下两种场景中特别有用：<ol>
<li>转发 refs 到 DOM 组件</li>
<li>在高阶组件中转发 refs</li>
</ol>
</li>
</ol>
</li>
<li>类组件与函数组件有什么异同？<ol>
<li>相同点：<ol>
<li>组件是 React 可复用的最小代码片段，它们会返回要在页面中渲染的 React 元素。也正因为组件是 React 的最小编码单位，所以无论是函数组件还是类组件，在使用方式和最终呈现效果上都是完全一致的。</li>
<li>我们甚至可以将一个类组件改写成函数组件，或者把函数组件改写成一个类组件（虽然并不推荐这种重构行为）。从使用者的角度而言，很难从使用体验上区分两者，而且在现代浏览器中，闭包和类的性能只在极端场景下才会有明显的差别。所以，基本可认为两者作为组件是完全一致的。</li>
</ol>
</li>
<li>不同点：<ol>
<li>它们在开发时的心智模型上却存在巨大的差异。类组件是基于面向对象编程的，它主打的是继承、生命周期等核心概念；而函数组件内核是函数式编程，主打的是 immutable、没有副作用、引用透明等特点。</li>
<li>之前，在使用场景上，如果存在需要使用生命周期的组件，那么主推类组件；设计模式上，如果需要使用继承，那么主推类组件。但现在由于 React Hooks 的推出，生命周期概念的淡出，函数组件可以完全取代类组件。其次继承并不是组件最佳的设计模式，官方更推崇“组合优于继承”的设计概念，所以类组件在这方面的优势也在淡出。</li>
<li>性能优化上，类组件主要依靠 shouldComponentUpdate 阻断渲染来提升性能，而函数组件依靠 React.memo 缓存渲染结果来提升性能。</li>
<li>从上手程度而言，类组件更容易上手，从未来趋势上看，由于React Hooks 的推出，函数组件成了社区未来主推的方案。</li>
<li>类组件在未来时间切片与并发模式中，由于生命周期带来的复杂度，并不易于优化。而函数组件本身轻量简单，且在 Hooks 的基础上提供了比原先更细粒度的逻辑组织与复用，更能适应 React 的未来发展。</li>
</ol>
</li>
</ol>
</li>
<li>React-Router的实现原理是什么？<ol>
<li>客户端路由实现的思想：<ol>
<li>基于 hash 的路由：通过监听hashchange事件，感知 hash 的变化<ol>
<li>改变 hash 可以直接通过 location.hash&#x3D;xxx</li>
</ol>
</li>
<li>基于 H5 history 路由：<ol>
<li>改变 url 可以通过 history.pushState 和 resplaceState 等，会将URL压入堆栈，同时能够应用 history.go() 等 API。监听 url 的变化可以通过自定义事件触发实现</li>
</ol>
</li>
</ol>
</li>
<li>react-router 实现的思想：<ol>
<li>基于 history 库来实现上述不同的客户端路由实现思想，并且能够保存历史记录等，磨平浏览器差异，上层无感知</li>
<li>通过维护的列表，在每次 URL 发生变化的回收，通过配置的 路由路径，匹配到对应的 Component，并且 render</li>
</ol>
</li>
</ol>
</li>
<li>如何配置 React-Router 实现路由切换<ol>
<li>使用<code>&lt;Route&gt; </code>组件</li>
<li>结合使用<code>&lt;Switch&gt;组件和&lt;Route&gt;</code>组件<ol>
<li><code>&lt;Switch&gt;用于将&lt;Route&gt;</code>分组。</li>
<li><code>&lt;Switch&gt;不是分组&lt;Route&gt;</code>所必须的，但他通常很有用。 一个<code>&lt;Switch&gt;</code>会遍历其所有的子<code>&lt;Route&gt;</code>元素，并仅渲染与当前地址匹配的第一个元素。</li>
</ol>
</li>
<li>使用<code>&lt;Link&gt;、 &lt;NavLink&gt;、&lt;Redirect&gt;</code>组件<ol>
<li><code>&lt;Link&gt;</code>组件来在你的应用程序中创建链接。无论你在何处渲染一个<code>&lt;Link&gt;</code>，都会在应用程序的 HTML 中渲染锚（<code>&lt;a&gt;</code>）。</li>
<li>当我们想强制导航时，可以渲染一个<code>&lt;Redirect&gt;</code>，当一个<code>&lt;Redirect&gt;</code>渲染时，它将使用它的to属性进行定向。</li>
</ol>
</li>
</ol>
</li>
<li>React-Router怎么设置重定向？<ol>
<li>使用<code>&lt;Redirect&gt;</code>组件实现路由的重定向：</li>
</ol>
</li>
<li>react-router 里的 Link 标签和 a 标签的区别<ol>
<li>从最终渲染的 DOM 来看，这两者都是链接，都是 标签，</li>
<li>区别是∶ <code>&lt;Link&gt;是react-router</code> 里实现路由跳转的链接，一般配合<code>&lt;Route&gt; </code>使用，<code>react-router</code>接管了其默认的链接跳转行为，区别于传统的页面跳转，<code>&lt;Link&gt;</code> 的“跳转”行为只会触发相匹配的<code>&lt;Route&gt;</code>对应的页面内容更新，而不会刷新整个页面。</li>
<li><code>&lt;Link&gt;</code>做了3件事情:<ol>
<li>有onclick那就执行onclick</li>
<li>click的时候阻止a标签默认事件</li>
<li>根据跳转href(即是to)，用history (web前端路由两种方式之一，history &amp; hash)跳转，此时只是链接变了，并没有刷新页面而<a>标签就是普通的超链接了，用于从当前页面跳转到href指向的另一 个页面(非锚点情况)。</li>
</ol>
</li>
<li>a标签默认事件禁掉之后做了什么才实现了跳转? <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> domArr = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&#x27;a&#x27;</span>)<br>[...domArr].<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>&#123;<br>    item.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>,<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        location.<span class="hljs-property">href</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">href</span><br>    &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure></li>
</ol>
</li>
<li>React-Router如何获取URL的参数和历史对象？<ol>
<li>get传值<ol>
<li>路由配置还是普通的配置，如：’admin’，传参方式如：’admin?id&#x3D;’1111’’。通过this.props.location.search获取url获取到一个字符串’?id&#x3D;’1111’ 可以用url，qs，querystring，浏览器提供的api URLSearchParams对象或者自己封装的方法去解析出id的值。</li>
</ol>
</li>
<li>动态路由传值<ol>
<li>路由需要配置成动态路由：如path&#x3D;’&#x2F;admin&#x2F;:id’，传参方式，如’admin&#x2F;111’。通过this.props.match.params.id 取得url中的动态路由id部分的值，除此之外还可以通过useParams（Hooks）来获取</li>
</ol>
</li>
<li>通过query或state传值<ol>
<li>传参方式如：在Link组件的to属性中可以传递对象{pathname:’&#x2F;admin’,query:’111’,state:’111’};。通过this.props.location.state或this.props.location.query来获取即可，传递的参数可以是对象、数组等，但是存在缺点就是只要刷新页面，参数就会丢失。</li>
</ol>
</li>
<li>获取历史对象<ol>
<li>如果React &gt;&#x3D; 16.8 时可以使用 React Router中提供的Hooks useHistory</li>
<li>使用this.props.history获取历史对象</li>
</ol>
</li>
</ol>
</li>
<li>React-Router 4怎样在路由变化时重新渲染同一个组件？<ol>
<li>当路由变化时，即组件的props发生了变化，会调用componentWillReceiveProps等生命周期钩子。那需要做的只是： 当路由改变时，根据路由，也去请求数据</li>
<li>利用生命周期componentWillReceiveProps，进行重新render的预处理操作。</li>
</ol>
</li>
<li>React-Router的路由有几种模式？<ol>
<li>React-Router 支持使用 hash（对应 HashRouter）和 browser（对应 BrowserRouter） 两种路由规则， react-router-dom 提供了 BrowserRouter 和 HashRouter 两个组件来实现应用的 UI 和 URL 同步：<ol>
<li>BrowserRouter 创建的 URL 格式：xxx.com&#x2F;path</li>
<li>HashRouter 创建的 URL 格式：xxx.com&#x2F;#&#x2F;path</li>
</ol>
</li>
<li>BrowserRouter<ol>
<li>它使用 HTML5 提供的 history API（pushState、replaceState 和 popstate 事件）来保持 UI 和 URL 的同步。由此可以看出，BrowserRouter 是使用 HTML 5 的 history API 来控制路由跳转的 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">BrowserRouter</span></span><br><span class="hljs-tag">    <span class="hljs-attr">basename</span>=<span class="hljs-string">&#123;string&#125;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">forceRefresh</span>=<span class="hljs-string">&#123;bool&#125;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">getUserConfirmation</span>=<span class="hljs-string">&#123;func&#125;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">keyLength</span>=<span class="hljs-string">&#123;number&#125;</span></span><br><span class="hljs-tag">/&gt;</span><br></code></pre></td></tr></table></figure></li>
<li>HashRouter 使用 URL 的 hash 部分（即 window.location.hash）来保持 UI 和 URL 的同步。由此可以看出，HashRouter 是通过 URL 的 hash 属性来控制路由跳转的： <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">HashRouter</span></span><br><span class="hljs-tag">    <span class="hljs-attr">basename</span>=<span class="hljs-string">&#123;string&#125;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">getUserConfirmation</span>=<span class="hljs-string">&#123;func&#125;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">hashType</span>=<span class="hljs-string">&#123;string&#125;</span>  </span><br><span class="hljs-tag">/&gt;</span><br></code></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
<li>React-Router 4的Switch有什么用？<ol>
<li>Switch 通常被用来包裹 Route，用于渲染与路径匹配的第一个子 <Route> 或 <Redirect>，它里面不能放其他元素。</li>
<li>精确匹配路径</li>
</ol>
</li>
<li>React setState 调用的原理<ol>
<li>具体的执行过程如下（源码级解析）：<ol>
<li>首先调用了setState 入口函数，入口函数在这里就是充当一个分发器的角色，根据入参的不同，将其分发到不同的功能函数中去；</li>
<li>enqueueSetState 方法将新的 state 放进组件的状态队列里，并调用 enqueueUpdate 来处理将要更新的实例对象；</li>
<li>在 enqueueUpdate 方法中引出了一个关键的对象——batchingStrategy，该对象所具备的isBatchingUpdates 属性直接决定了当下是要走更新流程，还是应该排队等待；如果轮到执行，就调用 batchedUpdates 方法来直接发起更新流程。由此可以推测，batchingStrategy 或许正是 React 内部专门用于管控批量更新的对象。</li>
<li>注意：batchingStrategy 对象可以理解为“锁管理器”。这里的“锁”，是指 React 全局唯一的 isBatchingUpdates变量，isBatchingUpdates 的初始值是 false，意味着“当前并未进行任何批量更新操作”。每当 React 调用 batchedUpdate 去执行更新动作时，会先把这个锁给“锁上”（置为 true），表明“现在正处于批量更新过程中”。当锁被“锁上”的时候，任何需要更新的组件都只能暂时进入 dirtyComponents 里排队等候下一次的批量更新，而不能随意“插队”。此处体现的“任务锁”的思想，是 React 面对大量状态仍然能够实现有序分批处理的基石。</li>
</ol>
</li>
</ol>
</li>
<li>React setState 调用之后发生了什么？是同步还是异步？<ol>
<li>React中setState后发生了什么<ol>
<li>在代码中调用setState函数之后，React 会将传入的参数对象与组件当前的状态合并，然后触发调和过程(Reconciliation)。经过调和过程，React 会以相对高效的方式根据新的状态构建 React 元素树并且着手重新渲染整个UI界面。</li>
<li>在 React 得到元素树之后，React 会自动计算出新的树与老树的节点差异，然后根据差异对界面进行最小化重渲染。在差异计算算法中，React 能够相对精确地知道哪些位置发生了改变以及应该如何改变，这就保证了按需更新，而不是全部重新渲染。</li>
<li>如果在短时间内频繁setState。React会将state的改变压入栈中，在合适的时机，批量更新state和视图，达到提高性能的效果。</li>
</ol>
</li>
<li>setState 是同步还是异步的<ol>
<li>异步： 在 React 可以控制的地方，就为 true，比如在 React 生命周期事件和合成事件中，都会走合并操作，延迟更新的策略。</li>
<li>同步： 在 React 无法控制的地方，比如原生事件，具体就是在 addEventListener 、setTimeout、setInterval 等事件中，就只能同步更新。</li>
</ol>
</li>
</ol>
</li>
<li>React中的setState批量更新的过程是什么？<ol>
<li>调用 setState 时，组件的 state 并不会立即改变， setState 只是把要修改的 state 放入一个队列， React 会优化真正的执行时机，并出于性能原因，会将 React 事件处理程序中的多次React 事件处理程序中的多次 setState的状态修改合并成一次状态修改。 最终更新只产生一次组件及其子组件的重新渲染，这对于大型应用程序中的性能提升至关重要。</li>
<li>需要注意：只要同步代码还在执行，“攒起来”这个动作就不会停止。（注：这里之所以多次 +1 最终只有一次生效，是因为在同一个方法中多次 setState 的合并动作不是单纯地将更新累加。比如这里对于相同属性的设置，React 只会为其保留最后一次的更新）。</li>
</ol>
</li>
<li>React中有使用过getDefaultProps吗？它有什么作用？<ol>
<li>通过实现组件的getDefaultProps，对属性设置默认值（ES5的写法）</li>
</ol>
</li>
<li>React中setState的第二个参数作用是什么？<ol>
<li>setState 的第二个参数是一个可选的回调函数。这个回调函数将在组件重新渲染后执行。等价于在 componentDidUpdate 生命周期内执行。通常建议使用 componentDidUpdate 来代替此方式。在这个回调函数中你可以拿到更新后 state 的值</li>
</ol>
</li>
<li>React中的setState和replaceState的区别是什么？<ol>
<li>setState()用于设置状态对象，<code>setState(object nextState[, function callback])</code><ol>
<li>nextState，将要设置的新状态，该状态会和当前的state合并</li>
<li>callback，可选参数，回调函数。该函数会在setState设置成功，且组件重新渲染后调用。</li>
<li>合并nextState和当前state，并重新渲染组件。setState是React事件处理函数中和请求回调函数中触发UI更新的主要方法。</li>
</ol>
</li>
<li>replaceState()<ol>
<li>replaceState()方法与setState()类似，但是方法只会保留nextState中状态，原state不在nextState中的状态都会被删除。其语法如下：<code>replaceState(object nextState[, function callback])</code><ol>
<li>nextState，将要设置的新状态，该状态会替换当前的state。</li>
<li>callback，可选参数，回调函数。该函数会在replaceState设置成功，且组件重新渲染后调用。</li>
</ol>
</li>
</ol>
</li>
<li>总结： setState 是修改其中的部分状态，相当于 Object.assign，只是覆盖，不会减少原来的状态。而replaceState 是完全替换原来的状态，相当于赋值，将原来的 state 替换为另一个对象，如果新状态属性减少，那么 state 中就没有这个状态了。</li>
</ol>
</li>
<li>在React中组件的this.state和setState有什么区别？<ol>
<li>this.state通常是用来初始化state的，this.setState是用来修改state值的。如果初始化了state之后再使用this.state，之前的state会被覆盖掉，如果使用this.setState，只会替换掉相应的state值。所以，如果想要修改state的值，就需要使用setState，而不能直接修改state，直接修改state之后页面是不会更新的</li>
</ol>
</li>
<li>state 是怎么注入到组件的，从 reducer 到组件经历了什么样的过程<ol>
<li>通过connect和mapStateToProps将state注入到组件中</li>
<li>reducer 到组件经历的过程：<ol>
<li>reducer对action对象处理，更新组件状态，并将新的状态值返回store。</li>
<li>通过connect（mapStateToProps，mapDispatchToProps）（Component）对组件 Component进行升级，此时将状态值从store取出并作为props参数传递到组件</li>
</ol>
</li>
</ol>
</li>
<li>React组件的state和props有什么区别？<ol>
<li>props是一个从外部传进组件的参数，主要作为就是从父组件向子组件传递数据，它具有可读性和不变性，只能通过外部组件主动传入新的props来重新渲染子组件，否则子组件的props以及展现形式不会改变。</li>
<li>state的主要作用是用于组件保存、控制以及修改自己的状态，它只能在constructor中初始化，它算是组件的私有属性，不可通过外部访问和修改，只能通过组件内部的this.setState来修改，修改state属性会导致组件的重新渲染。</li>
<li>区别<ol>
<li>props 是传递给组件的（类似于函数的形参），而state 是在组件内被组件自己管理的（类似于在一个函数内声明的变量）。</li>
<li>props 是不可修改的，所有 React 组件都必须像纯函数一样保护它们的 props 不被更改。</li>
<li>state 是在组件中创建的，一般在 constructor中初始化 state。state 是多变的、可以修改，每次setState都异步更新的。</li>
</ol>
</li>
</ol>
</li>
<li>React中的props为什么是只读的？<ol>
<li>this.props 是组件之间沟通的一个接口，原则上来讲，它只能从父组件流向子组件。React具有浓重的函数式编程的思想。</li>
<li>提到函数式编程就要提一个概念：纯函数。它有几个特点：<ol>
<li>给定相同的输入，总是返回相同的输出。</li>
<li>过程没有副作用。</li>
<li>不依赖外部状态。</li>
</ol>
</li>
<li>this.props就是汲取了纯函数的思想。props的不可以变性就保证的相同的输入，页面显示的内容是一样的，并且不会产生副作用</li>
</ol>
</li>
<li>在React中组件的props改变时更新组件的有哪些方法？<ol>
<li>在一个组件传入的props更新时重新渲染该组件常用的方法是在componentWillReceiveProps中将新的props更新到组件的state中（这种state被成为派生状态（Derived State）），从而实现重新渲染。React 16.3中还引入了一个新的钩子函数getDerivedStateFromProps来专门实现这一需求。</li>
</ol>
</li>
<li>React中怎么检验props？验证props的目的是什么？<ol>
<li>React为我们提供了PropTypes以供验证使用。当我们向Props传入的数据无效（向Props传入的数据类型和验证的数据类型不符）就会在控制台发出警告信息。它可以避免随着应用越来越复杂从而出现的问题。并且，它还可以让程序变得更易读。</li>
</ol>
</li>
<li>Redux 原理及工作流程<ol>
<li>Redux源码主要分为以下几个模块文件<ol>
<li>compose.js 提供从右到左进行函数式编程</li>
<li>createStore.js 提供作为生成唯一store的函数</li>
<li>combineReducers.js 提供合并多个reducer的函数，保证store的唯一性</li>
<li>bindActionCreators.js 可以让开发者在不直接接触dispacth的前提下进行更改state的操作</li>
<li>applyMiddleware.js 这个方法通过中间件来增强dispatch的功能</li>
</ol>
</li>
<li>工作流程<ol>
<li>const store&#x3D; createStore（fn）生成数据;</li>
<li>action: {type: Symble(‘action01), payload:’payload’ }定义行为;</li>
<li>dispatch发起action：store.dispatch(doSomething(‘action001’));</li>
<li>reducer：处理action，返回新的state;</li>
</ol>
</li>
<li>通俗点解释：<ol>
<li>首先，用户（通过View）发出Action，发出方式就用到了dispatch方法</li>
<li>然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer会返回新的State</li>
<li>State—旦有变化，Store就会调用监听函数，来更新View</li>
</ol>
</li>
</ol>
</li>
<li>Redux 中异步的请求怎么处理<ol>
<li>redux-thunk</li>
<li>redux-saga</li>
</ol>
</li>
<li>Redux 怎么实现属性传递，介绍下原理<ol>
<li>react-redux 数据传输∶ view–&gt;action–&gt;reducer–&gt;store–&gt;view。看下点击事件的数据是如何通过redux传到view上：<ol>
<li>view 上的AddClick 事件通过mapDispatchToProps 把数据传到action —&gt; click:()&#x3D;&gt;dispatch(ADD)</li>
<li>action 的ADD 传到reducer上</li>
<li>reducer传到store上 const store &#x3D; createStore(reducer);</li>
<li>store再通过 mapStateToProps 映射穿到view上text:State.text</li>
</ol>
</li>
</ol>
</li>
<li>Redux 中间件是什么？接受几个参数？柯里化函数两端的参数具体是什么？<ol>
<li>Redux 的中间件提供的是位于 action 被发起之后，到达 reducer 之前的扩展点，</li>
<li>换而言之，原本 view -→&gt; action -&gt; reducer -&gt; store 的数据流加上中间件后变成了 view -&gt; action -&gt; middleware -&gt; reducer -&gt; store ，在这一环节可以做一些”副作用”的操作，如异步请求、打印日志等。<ol>
<li>redux中间件接受一个对象作为参数，对象的参数上有两个字段 dispatch 和 getState，分别代表着 Redux Store 上的两个同名函数。</li>
<li>柯里化函数两端一个是 middewares，一个是store.dispatch</li>
</ol>
</li>
</ol>
</li>
<li>Redux 请求中间件如何处理并发<ol>
<li>使用redux-Saga</li>
</ol>
</li>
<li>Redux 状态管理器和变量挂载到 window 中有什么区别<ol>
<li>两者都是存储数据以供后期使用。但是Redux状态更改可回溯——Time travel，数据多了的时候可以很清晰的知道改动在哪里发生，完整的提供了一套状态管理模式。</li>
</ol>
</li>
<li>mobox 和 redux 有什么区别？</li>
<li>Redux 和 Vuex 有什么区别，它们的共同思想</li>
<li>Redux 中间件是怎么拿到store 和 action? 然后怎么处理?<br>1. redux中间件本质就是一个函数柯里化。redux applyMiddleware Api 源码中每个middleware 接受2个参数， Store 的getState 函数和dispatch 函数，分别获得store和action，最终返回一个函数。该函数会被传入 next 的下一个 middleware 的 dispatch 方法，并返回一个接收 action 的新函数，这个函数可以直接调用 next（action），或者在其他需要的时刻调用，甚至根本不去调用它。调用链中最后一个 middleware 会接受真实的 store的 dispatch 方法作为 next 参数，并借此结束调用链。所以，middleware 的函数签名是（{ getState，dispatch })&#x3D;&gt; next &#x3D;&gt; action。</li>
<li>Redux中的connect有什么作用<br>1. connect负责连接React和Redux<ol>
<li>获取state</li>
<li>包装原组件</li>
<li>监听store tree变化</li>
</ol>
</li>
<li><ul>
<li></li>
</ul>
</li>
</ol>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/react/" class="category-chain-item">react</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/react/" class="print-no-link">#react</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>react.js</div>
      <div>https://easywz.github.io/2024/02/28/Interview/React-2/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>汪邹</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年2月28日</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>更新于</div>
          <div>2024年9月9日</div>
        </div>
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
<!-- hexo injector body_end start --><script src="/js/outdate.js"></script><!-- hexo injector body_end end --></body>
</html>
