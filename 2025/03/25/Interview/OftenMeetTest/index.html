

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/icons/bk.png">
  <link rel="icon" href="/img/icons/bk.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="汪邹">
  <meta name="keywords" content="">
  
    <meta name="description" content="前端常见问题总结">
<meta property="og:type" content="article">
<meta property="og:title" content="前端常见问题总结">
<meta property="og:url" content="https://easywz.github.io/2025/03/25/Interview/OftenMeetTest/index.html">
<meta property="og:site_name" content="WZ&#39;s blog">
<meta property="og:description" content="前端常见问题总结">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://easywz.github.io/img/interview/qdms.jpg">
<meta property="article:published_time" content="2025-03-25T02:07:11.000Z">
<meta property="article:modified_time" content="2025-09-04T01:31:26.387Z">
<meta property="article:author" content="汪邹">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://easywz.github.io/img/interview/qdms.jpg">
  
  
  
  <title>前端常见问题总结 - WZ&#39;s blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"easywz.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>人生在勤，不索何获</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/webp/homeBg.webp') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="前端常见问题总结"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-03-25 10:07" pubdate>
          2025年3月25日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          11k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          90 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">前端常见问题总结</h1>
            
              <p id="updated-time" class="note note-info" style="">
                
                  
                    本文最后更新于 2025年9月4日 上午
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <h3 id="1-网站开发中，如何实现图片的懒加载"><a href="#1-网站开发中，如何实现图片的懒加载" class="headerlink" title="1.网站开发中，如何实现图片的懒加载"></a>1.网站开发中，如何实现图片的懒加载</h3><ol>
<li>如何控制图片的加载<ol>
<li>设置一个临时 Data 属性 data-src，控制加载时使用 src 代替 data-src</li>
<li><code>&lt;img data-src=&quot;shanyue.jpg&quot; /&gt;</code></li>
<li><code>img.src = img.datset.src</code></li>
</ol>
</li>
<li>判断图片出现在当前视口<ol>
<li>Element.getBoundingClientRect() 方法返回元素的大小及其相对于视口的位置。 <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart"> <span class="hljs-comment">// clientHeight 代表当前视口的高度</span><br>img.getBoundingClientRect().top &lt; <span class="hljs-built_in">document</span>.documentElement.clientHeight;<br></code></pre></td></tr></table></figure></li>
<li>IntersectionObserver API，一个能够监听元素是否到了当前视口的事件<ol>
<li>entry.isIntersecting 代表目标元素可见</li>
<li>IntersectionObserver 除了给图片做懒加载外，还可以对单页应用资源做预加载。如在 next.js v9 中，会对视口内的资源做预加载 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> observer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntersectionObserver</span>(<span class="hljs-function">(<span class="hljs-params">changes</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// changes: 目标元素集合</span><br>  changes.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">change</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// intersectionRatio</span><br>    <span class="hljs-keyword">if</span> (change.<span class="hljs-property">isIntersecting</span>) &#123;<br>      <span class="hljs-keyword">const</span> img = change.<span class="hljs-property">target</span>;<br>      img.<span class="hljs-property">src</span> = img.<span class="hljs-property">dataset</span>.<span class="hljs-property">src</span>;<br>      observer.<span class="hljs-title function_">unobserve</span>(img);<br>    &#125;<br>  &#125;);<br>&#125;);<br> <br>observer.<span class="hljs-title function_">observe</span>(img);<br></code></pre></td></tr></table></figure></li>
</ol>
</li>
<li>LazyLoading属性<ol>
<li><code>&lt;img src=&quot;shanyue.jpg&quot; loading=&quot;lazy&quot; /&gt;</code></li>
<li>不过目前浏览器兼容性不太好</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="2-什么是防抖和节流，他们的应用场景有哪些"><a href="#2-什么是防抖和节流，他们的应用场景有哪些" class="headerlink" title="2.什么是防抖和节流，他们的应用场景有哪些"></a>2.什么是防抖和节流，他们的应用场景有哪些</h3><ol>
<li>防抖相当于回城，每次被打断，就需要重新执行回城的操作，只有真正不受干扰时才能完成回城</li>
<li>节流相当于技能冷却，在施放了一次技能操作后，只有等到规定时间后才能施放下一次技能</li>
<li>防抖(debounce)<ol>
<li>触发高频事件后n秒内函数只会执行一次，如果n秒内高频事件再次被触发，则重新计算时间</li>
<li>示例代码 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 防抖函数</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">fn, wait</span>) &#123;<br>      <span class="hljs-keyword">let</span> timer;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">let</span> _this = <span class="hljs-variable language_">this</span>;<br>        <span class="hljs-keyword">let</span> args = <span class="hljs-variable language_">arguments</span>;<br>        <span class="hljs-keyword">if</span> (timer) &#123;<br>          <span class="hljs-built_in">clearTimeout</span>(timer);<br>        &#125;<br>        timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>          fn.<span class="hljs-title function_">apply</span>(_this, args);<br>        &#125;, wait);<br>      &#125;;<br>    &#125;<br>    <span class="hljs-comment">// 使用</span><br>    <span class="hljs-variable language_">window</span>.<span class="hljs-property">onresize</span> = <span class="hljs-title function_">debounce</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;resize&quot;</span>);<br>    &#125;, <span class="hljs-number">500</span>);<br></code></pre></td></tr></table></figure></li>
<li>应用场景<ol>
<li>登录、发短信等按钮避免用户点击太快，以致于发送了多次请求，需要防抖</li>
<li>调整浏览器窗口大小时，resize 次数过于频繁，造成计算过多，此时需要一次到位</li>
<li>文本编辑器实时保存，当无任何更改操作一秒后进行保存</li>
</ol>
</li>
</ol>
</li>
<li>节流(throttle)<ol>
<li>高频事件触发，但在n秒内只会执行一次，所以节流会稀释函数的执行频率</li>
<li>示例代码 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 方式1: 使用时间戳</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle1</span>(<span class="hljs-params">fn, wait</span>) &#123;<br>  <span class="hljs-keyword">let</span> time = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> _this = <span class="hljs-variable language_">this</span>;<br>    <span class="hljs-keyword">let</span> args = <span class="hljs-variable language_">arguments</span>;<br>    <span class="hljs-keyword">let</span> now = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>    <span class="hljs-keyword">if</span> (now - time &gt; wait) &#123;<br>      fn.<span class="hljs-title function_">apply</span>(_this, args);<br>      time = now;<br>    &#125;<br>  &#125;;<br>&#125;<br><span class="hljs-comment">// 方式2: 使用定时器</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">thorttle2</span>(<span class="hljs-params">fn, wait</span>) &#123;<br>  <span class="hljs-keyword">let</span> timer;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> _this = <span class="hljs-variable language_">this</span>;<br>    <span class="hljs-keyword">let</span> args = <span class="hljs-variable language_">arguments</span>;<br> <br>    <span class="hljs-keyword">if</span> (!timer) &#123;<br>      timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        timer = <span class="hljs-literal">null</span>;<br>        fn.<span class="hljs-title function_">apply</span>(_this, args);<br>      &#125;, wait);<br>    &#125;<br>  &#125;;<br>&#125;<br><br></code></pre></td></tr></table></figure></li>
<li>场景<ol>
<li>scroll 事件，每隔一秒计算一次位置信息等</li>
<li>浏览器播放事件，每个一秒计算一次进度信息等</li>
<li>input 框实时搜索并发送请求展示下拉列表，每隔一秒发送一次请求 (也可做防抖)</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="3-当新入职一家公司时，如何快速搭建开发环境并让应用跑起来"><a href="#3-当新入职一家公司时，如何快速搭建开发环境并让应用跑起来" class="headerlink" title="3.当新入职一家公司时，如何快速搭建开发环境并让应用跑起来"></a>3.当新入职一家公司时，如何快速搭建开发环境并让应用跑起来</h3><h3 id="4-如何实现一个元素的水平垂直居中"><a href="#4-如何实现一个元素的水平垂直居中" class="headerlink" title="4.如何实现一个元素的水平垂直居中"></a>4.如何实现一个元素的水平垂直居中</h3><ol>
<li>绝对定位方法： <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>  postion: absolute;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">bottom</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">50px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>, -<span class="hljs-number">50%</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>flex方法： <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">justify-content</span>: center;<br>  <span class="hljs-attribute">align-items</span>: center;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>grid <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span>, <span class="hljs-selector-tag">html</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">display</span>: grid;<br>&#125;<br><span class="hljs-selector-tag">span</span> &#123; <span class="hljs-comment">/* thing to center */</span><br>  <span class="hljs-attribute">margin</span>: auto;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="5-了解-React-中的-ErrorBoundary-吗，它有那些使用场景"><a href="#5-了解-React-中的-ErrorBoundary-吗，它有那些使用场景" class="headerlink" title="5.了解 React 中的 ErrorBoundary 吗，它有那些使用场景"></a>5.了解 React 中的 ErrorBoundary 吗，它有那些使用场景</h3><ol>
<li>避免错误渲染白屏做异常中间处理的嵌套组件</li>
</ol>
<h3 id="6-vue3-0-中为什么要使用-Proxy，它相比以前的实现方式有什么改进"><a href="#6-vue3-0-中为什么要使用-Proxy，它相比以前的实现方式有什么改进" class="headerlink" title="6.vue3.0 中为什么要使用 Proxy，它相比以前的实现方式有什么改进"></a>6.vue3.0 中为什么要使用 Proxy，它相比以前的实现方式有什么改进</h3><ol>
<li>改进和优势<ol>
<li><p>更强大和灵活：Proxy 可以代理整个对象，而不仅仅是对象的属性。这意味着您可以监听对象的整个操作，包括属性的增删改查等。而 Object.defineProperty 只能监听对象的属性的读取和赋值操作。</p>
</li>
<li><p>更直观和易用：使用 Proxy 可以更直观地监听对象的操作，而不需要像 Object.defineProperty 那样手动定义 getter 和 setter。这使得代码更加清晰和易于理解。</p>
</li>
<li><p>更好的性能：Proxy 的性能通常比 Object.defineProperty 更好，因为 Proxy 是原生实现的，而 Object.defineProperty 是 JavaScript 引擎的内部实现。Proxy 的底层实现更高效，可以更好地处理大型对象和多次操作。</p>
</li>
<li><p>支持数组变化的检测：使用 Proxy 可以很容易地监听数组的变化，包括数组的 push、pop、splice 等操作。而 Object.defineProperty 难以实现对数组变化的监听。</p>
</li>
</ol>
</li>
<li>Vue2x中使用的是 Object.defineProerty(obj, prop, descriptor)来实现的响应式<ol>
<li>Object.defineProerty<ol>
<li>作用：是在一个对象定义一个新属性，或者修改一个对象的现有属性，并返回一个对象。</li>
<li>参数：<ol>
<li>要添加属性的对象</li>
<li>要定义或修改的属性的名称或 [Symbol]</li>
<li>要定义或修改的属性描述符</li>
</ol>
</li>
<li>这个函数通常是劫持对象中某一个属性，重写该属性的set，get函数，实现对属性的监听。但是在使用的场景中，我们通常需要一次性监听多个属性的变化，甚至需要监听复杂的对象嵌套，这个时候就只能在遍历该对象，并在遍历过程中递归，才可以实现复杂对象的监听。 注意的是这里不能直接遍历监听的obj对象，因为在 get 方法里面，我们在访问 obj身上的属性时，就会触发 get 方法，返回 person[key] ，但是访问 person[key] 也会触发 get 方法，导致异常递归调用，最终栈溢出。 所以这里需要设置一个中转 Observer，来让 get 中 return 的值并不是直接访问 obj[key] 在劫持数组时又有问题，当声明数组后，使用defineProerty只能劫持到声明时候的内容，也就是通过索引访问或者修改数组中已经存在的元素，是可以触发get和set的，但是对于通过push、unshift增加的元素，会增加一个索引，这种情况需要手动初始化，新增加的元素才能被监听到。另外， 通过 pop 或 shift 删除元素，会删除并更新索引，也会触发 setter 和 getter 方法。而且在Vue2.x中，通过重写Array原型上的方法解决了这个问题，此处就不展开说了，有兴趣的可以再去了解下。 事实上，在上面的讲述中，我们还有问题没有解决：那就是当我们要给对象新增加一个属性时，也需要手动去监听这个新增属性。 这也就是vue2为什么要用<code>vm.$set</code>来向数组及对象添加响应式内容，vm.$set简单来说就是重新走一遍上述遍历过程，来保持新增加的属性是响应式。 至此vue2的响应式大概内容说完了，可以看到上述通过 Object.definePorperty() 进行数据监听是比较麻烦的，需要大量的手动处理。</li>
</ol>
</li>
<li>vue3中的Proxy<ol>
<li><code>const p = new Proxy( target, handler );</code></li>
<li>作用：通过Proxy，我们可以对设置代理的对象上的一些操作进行拦截，外界对这个对象的各种操作，都要先通过这层拦截。（和defineProperty差不多）</li>
<li>参数：<ol>
<li>target:要使用 Proxy 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）</li>
<li>handler:一个通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 p 的行为。</li>
</ol>
</li>
<li>Proxy代理的是整个对象，而不是对象的某个特定属性，不需要我们通过遍历来逐个进行数据绑定。 值得注意的是:之前我们在使用Object.defineProperty()给对象添加一个属性之后，我们对对象属性的读写操作仍然在对象本身。 但是一旦使用Proxy，如果想要读写操作生效，我们就要对Proxy的实例对象 p 进行操作。</li>
<li>解决vue2 Object.defineProperty的难题<ol>
<li>一次只能对一个属性进行监听，需要遍历来对所有属性监听。</li>
<li>在遇到一个对象的属性还是一个对象的情况下，需要递归监听</li>
<li>对于对象的新增属性，需要手动监听</li>
<li>对于数组通过push、unshift方法增加的元素，也无法监听 但是看过vue3源码的同学可以发现，vue3的响应式并不是只用了proxy来实现的，还用了一个搭档Reflect。也就是Proxy(代理) 配合 Reflect(反射) 进行设计的。那么就有疑问了 为什么要用上Reflect。</li>
</ol>
</li>
<li>什么是 Reflect ？<ol>
<li>Reflect 其实和 Proxy 一样都是属于 ES6 的高级API，Reflect 也是属于 window 的一个内置类，可以通过 window.Reflect 访问到。</li>
<li>在阅读 Proxy 的 MDN 文档上会发现其实 Proxy 中 get 陷阱中还会存在一个额外的参数 receiver 。 通过上述对 window.Reflect 的打印可以看到，Reflect 的方法、属性和 Proxy 是一样的，所以 Reflect get 也是有这 第三个 receiver 属性的；这个receiver是触发代理对象的劫持时保证正确的 this 上下文指向，它正是可以修改属性访问中的 this 指向为传入的 receiver 对象。也是为了框架健壮性。使用 Object.defineProperty() 重复声明的属性会报错，因为 JavaScript 是单线程语言，一旦抛出异常，后边的任何逻辑都不会执行，所以为了避免这种情况，我们在底层就要写 大量的 try catch 来避免，不够优雅。 但是使用 Reflect.defineProperty() 是有返回值的，所以通过 返回值 来判断你当前操作是否成功。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="7-有没有使用过-react-hooks，它带来了那些便利"><a href="#7-有没有使用过-react-hooks，它带来了那些便利" class="headerlink" title="7.有没有使用过 react hooks，它带来了那些便利"></a>7.有没有使用过 react hooks，它带来了那些便利</h3><ol>
<li>让函数组件拥有状态（useState）<ol>
<li>不需要 this.state，代码更简洁。</li>
</ol>
</li>
<li>代替生命周期函数（useEffect）<ol>
<li>useEffect 代替了 componentDidMount 和 componentWillUnmount，避免写多余的类方法。</li>
<li>支持副作用清理，例如清除定时器、移除事件监听等</li>
</ol>
</li>
<li>复用逻辑（自定义 Hook）<ol>
<li>逻辑复用更简单，不用额外写高阶组件或 render props。</li>
<li>更符合函数式编程。</li>
</ol>
</li>
<li>useRef 让函数组件持有引用<ol>
<li>可以获取 DOM 元素，不需要 document.getElementById()。</li>
<li>存储变量不会触发组件重新渲染（useRef 适用于存储不变的状态）。</li>
</ol>
</li>
<li>useContext 让数据共享更方便<ol>
<li>不需要 props drilling（层层传递 props）。</li>
<li>更轻量级，不用 Redux。</li>
</ol>
</li>
</ol>
<h3 id="8-如何使用-react-hooks-实现一个计数器的组件"><a href="#8-如何使用-react-hooks-实现一个计数器的组件" class="headerlink" title="8.如何使用 react hooks 实现一个计数器的组件"></a>8.如何使用 react hooks 实现一个计数器的组件</h3><h3 id="9-css-如何实现左侧固定300px，右侧自适应的布局"><a href="#9-css-如何实现左侧固定300px，右侧自适应的布局" class="headerlink" title="9.css 如何实现左侧固定300px，右侧自适应的布局"></a>9.css 如何实现左侧固定300px，右侧自适应的布局</h3><ol>
<li>左侧300px；右侧flex: 1; 采用flex的固比模型</li>
<li>Grid 布局<code>.container &#123;   display: grid;   grid-template-columns: 300px 1fr; &#125;</code></li>
<li>使用calc方法 .left{width:330px;} .right{width: calc(100% - 330px)}</li>
</ol>
<h3 id="10-浏览器中如何实现剪切板复制内容的功能"><a href="#10-浏览器中如何实现剪切板复制内容的功能" class="headerlink" title="10.浏览器中如何实现剪切板复制内容的功能"></a>10.浏览器中如何实现剪切板复制内容的功能</h3><ol>
<li>一般可以使用第三方库 clipboard-copy 来实现</li>
<li>推荐的方式是使用 Clipboard API 进行实现<code>navigator.clipboard.writeText(text);</code></li>
<li>对于一些不支持 Clipboard API 的浏览器，使用以下 API 进行复制<ol>
<li>选中: Selection API</li>
<li>复制: document.execCommand (已被废弃)<br>2.复制: execCommand <code>document.execCommand(&quot;copy&quot;);</code></li>
</ol>
</li>
</ol>
<h3 id="11-React-中，cloneElement-与-createElement-各是什么，有什么区别"><a href="#11-React-中，cloneElement-与-createElement-各是什么，有什么区别" class="headerlink" title="11.React 中，cloneElement 与 createElement 各是什么，有什么区别"></a>11.React 中，cloneElement 与 createElement 各是什么，有什么区别</h3><ol>
<li>createElement：React 内部创建虚拟 DOM 的方法，JSX 语法糖的底层实现。<ol>
<li><code>React.createElement(&#39;div&#39;, &#123; className: &#39;box&#39; &#125;, &#39;内容&#39;)</code><ol>
<li>第一个参数是 type 简单来说就是各种 标签名字（包括 HTML 自身的，还有 React 组件名字）</li>
<li>第二个参数是传入的属性</li>
<li>第三个参数以及之后的参数就是作为组件的子组件 JSX 编写的代码就是转换为这个方法，一般用了 JSX 写法都不会再需要自己直接调用 该方法</li>
</ol>
</li>
</ol>
</li>
<li>cloneElement：用于克隆已有组件，并修改 props 或 children，常用于 HOC、插槽模式等。<ol>
<li><code>React.cloneElement(child, &#123; newProp: &#39;value&#39; &#125;)</code><ol>
<li>第一个参数是 一个 React 元素</li>
<li>新添加的属性会并入原有的属性 一般配合 React.children.map使用，如用于动态地给子组件添加更多 props 信息、样式</li>
</ol>
</li>
<li>更深一点的原因在于，React 元素是 不可变对象 例如 props.children 获取到的只是一个 描述符，不能直接修改它的任何属性，只能读取他的信息。 所以我们可以选择拷贝它们，然后再修改、添加</li>
</ol>
</li>
</ol>
<h3 id="12-如何实现一个简单的-Promise"><a href="#12-如何实现一个简单的-Promise" class="headerlink" title="12.如何实现一个简单的 Promise"></a>12.如何实现一个简单的 Promise</h3><ol>
<li>状态管理（pending、fulfilled、rejected）</li>
<li>then 方法（支持异步回调）</li>
<li>resolve 和 reject 机制</li>
<li>支持链式调用</li>
</ol>
<h3 id="13-在前端开发中，如何获取浏览器的唯一标识"><a href="#13-在前端开发中，如何获取浏览器的唯一标识" class="headerlink" title="13.在前端开发中，如何获取浏览器的唯一标识"></a>13.在前端开发中，如何获取浏览器的唯一标识</h3><p>在前端开发中，获取浏览器的唯一标识（Browser Fingerprint）通常用于 用户跟踪、设备识别、防止欺诈 等场景</p>
<ol>
<li><code>navigator.userAgent</code>用户可以修改 userAgent，而且不同浏览器可能返回相似值，不能保证唯一</li>
<li>使用 <code>navigator.deviceMemory + hardwareConcurrency</code>（设备性能特征）,不同浏览器可能返回不同值，仍然不唯一</li>
<li>使用 canvas 指纹（更稳定的浏览器识别方式）<ol>
<li>由于不同的系统显卡绘制 canvas 时渲染参数、抗锯齿等算法不同，因此绘制成图片数据的 CRC 校验也不一样</li>
<li>代码： <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getCanvasFp</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> canvas = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;canvas&quot;</span>);<br>  <span class="hljs-keyword">const</span> ctx = canvas.<span class="hljs-title function_">getContext</span>(<span class="hljs-string">&quot;2d&quot;</span>);<br>  ctx.<span class="hljs-property">font</span> = <span class="hljs-string">&quot;14px Arial&quot;</span>;<br>  ctx.<span class="hljs-property">fillStyle</span> = <span class="hljs-string">&quot;#ccc&quot;</span>;<br>  ctx.<span class="hljs-title function_">fillText</span>(<span class="hljs-string">&quot;hello, shanyue&quot;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>);<br>  <span class="hljs-keyword">return</span> canvas.<span class="hljs-title function_">toDataURL</span>(<span class="hljs-string">&quot;image/jpeg&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
</li>
<li>使用 FingerprintJS（开源库，精确度高）</li>
<li>使用 localStorage 或 indexedDB 存储唯一 ID<ol>
<li>对同一浏览器持久有效</li>
<li>用户清除 localStorage 后会失效</li>
</ol>
</li>
</ol>
<h3 id="14-js-中如何实现-bind"><a href="#14-js-中如何实现-bind" class="headerlink" title="14.js 中如何实现 bind"></a>14.js 中如何实现 bind</h3><ol>
<li>Function.prototype.bind() 的作用是创建一个新的函数，并永久绑定 this 到指定的对象，同时支持预设参数。</li>
<li>作用<ol>
<li>绑定 this</li>
<li>支持柯里化（预设参数）</li>
<li>返回一个新的可调用函数</li>
<li>支持 new 关键字调用</li>
</ol>
</li>
<li>手写bind 核心思路<ol>
<li>返回一个新函数</li>
<li>apply 绑定 this</li>
<li>支持参数预设（柯里化）</li>
<li>支持 new 关键字调用</li>
</ol>
</li>
<li>简易示例 <figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">Function.prototype.myBind = <span class="hljs-keyword">function</span> <span class="hljs-params">(context, <span class="hljs-rest_arg">...args</span>)</span> &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">this</span> !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> TypeError(<span class="hljs-string">&quot;myBind 只能作用于函数&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">const</span> self = <span class="hljs-keyword">this</span>; <span class="hljs-comment">// 保存原函数</span><br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">boundFunction</span><span class="hljs-params">(<span class="hljs-rest_arg">...innerArgs</span>)</span> &#123;<br>    <span class="hljs-comment">// 处理 `new` 关键字调用</span><br>    <span class="hljs-keyword">return</span> self.apply(<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> boundFunction ? <span class="hljs-keyword">this</span> : context, [...args, ...innerArgs]);<br>  &#125;<br><br>  <span class="hljs-comment">// 继承原型，确保 new 调用时不会丢失原函数的 prototype</span><br>  boundFunction.prototype = Object.create(<span class="hljs-keyword">this</span>.prototype);<br><br>  <span class="hljs-keyword">return</span> boundFunction;<br>&#125;;<br></code></pre></td></tr></table></figure></li>
<li>应用场景<ol>
<li>事件监听时绑定 this 默认情况下，this 在事件回调中指向触发事件的 DOM 元素，而不是原始对象。可以用 bind 绑定 this。</li>
<li>在 setTimeout &#x2F; setInterval 里绑定 this JavaScript 的 setTimeout 和 setInterval 默认 this 指向 window，需要用 bind 绑定 this。</li>
<li>在 React 组件中使用 在 React class 组件中，事件回调函数 this 可能会丢失，需要 bind 绑定。</li>
<li>回调函数（如 map()、filter()）</li>
<li>类继承</li>
<li>高阶函数</li>
<li>new 关键字配合 bind</li>
</ol>
</li>
</ol>
<h3 id="15-js-中什么是-softbind，如何实现"><a href="#15-js-中什么是-softbind，如何实现" class="headerlink" title="15.js 中什么是 softbind，如何实现"></a>15.js 中什么是 softbind，如何实现</h3><ol>
<li>bind函数多次调用会已第一次绑定的this为准，softbind已最后一次绑定传入的this为准；</li>
<li>软绑定：首先检查调用时的this，如果this绑定到全局对象或者undefined，那就把this绑定到入参obj，否则不会修改this。也就是this软绑定到obj上，永远有一个obj来兜底，它优先级小于隐式绑定（a.foo）、显式绑定（call&#x2F;apply）和new绑定，但是高于默认绑定（独立函数调用）。</li>
<li>使用场景<ol>
<li>避免 this 绑定到 window（全局对象）</li>
<li>希望默认绑定 this，但仍然允许 call &#x2F; apply 绑定新对象</li>
<li>在 new 调用时，仍然能正确实例化对象</li>
</ol>
</li>
<li><table>
<thead>
<tr>
<th>功能</th>
<th>bind</th>
<th>softBind</th>
</tr>
</thead>
<tbody><tr>
<td>固定this</td>
<td>是</td>
<td>仅在this&#x3D;&#x3D;&#x3D;undefinded</td>
</tr>
<tr>
<td>支持call&#x2F;apply</td>
<td>不能</td>
<td>可以</td>
</tr>
<tr>
<td>支持new调用</td>
<td>不会影响</td>
<td>new优先</td>
</tr>
<tr>
<td>常见用途</td>
<td>硬绑定事件，回调</td>
<td>让this默认绑定到对象，但不影响call</td>
</tr>
</tbody></table>
</li>
</ol>
<h3 id="16-如何实现一个-loading-动画"><a href="#16-如何实现一个-loading-动画" class="headerlink" title="16.如何实现一个 loading 动画"></a>16.如何实现一个 loading 动画</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;loader&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">  <span class="hljs-selector-class">.loader</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">50px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">border</span>: <span class="hljs-number">5px</span> solid <span class="hljs-number">#f3f3f3</span>;</span><br><span class="language-css">    <span class="hljs-attribute">border-top</span>: <span class="hljs-number">5px</span> solid <span class="hljs-number">#3498db</span>;</span><br><span class="language-css">    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">50%</span>;</span><br><span class="language-css">    <span class="hljs-attribute">animation</span>: spin <span class="hljs-number">1s</span> linear infinite;</span><br><span class="language-css">  &#125;</span><br><span class="language-css"></span><br><span class="language-css">  <span class="hljs-keyword">@keyframes</span> spin &#123;</span><br><span class="language-css">    <span class="hljs-number">0%</span> &#123; <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotate</span>(<span class="hljs-number">0deg</span>); &#125;</span><br><span class="language-css">    <span class="hljs-number">100%</span> &#123; <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotate</span>(<span class="hljs-number">360deg</span>); &#125;</span><br><span class="language-css">  &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h3 id="17-http-常见的状态码有哪些"><a href="#17-http-常见的状态码有哪些" class="headerlink" title="17.http 常见的状态码有哪些"></a>17.http 常见的状态码有哪些</h3><ol>
<li>1XX 表示消息<ol>
<li>101 Switch Protocol 升级协议，如从 http 到 ws，此时需要反向代理支持，如 Nginx</li>
</ol>
</li>
<li>2XX 表示成功<ol>
<li>200 请求成功</li>
<li>201 Created 资源创建成功，多用于 POST 请求</li>
<li>204 No Content 响应不会返回 Body，一般由以下两种情况<ol>
<li>与 Options&#x2F;Delete 请求搭配</li>
<li>打点类</li>
</ol>
</li>
<li>206 Partial Content 当请求多媒体数据数据较大时，会进行分片传输。当你在B站观看视频，打开开发者工具，会发现许多 206 状态码以及响应头 Content-Range</li>
</ol>
</li>
<li>3XX 表示重定向<ol>
<li>301 永久重定向 http 转向 https时，有时会使用 301，如 B 站。</li>
<li>302 临时重定向 http 转向 https时，有时也会使用 302，如知乎</li>
<li>304 自上次请求，未修改的文件 与之相关的响应头部有：<ol>
<li>ETag</li>
<li>last-modified&#x2F;if-modified-since</li>
</ol>
</li>
<li>307 Temporary Redirect 暂时重定向。也可作为 http 到 https 的重定向。还有一种用途用作 HSTS，当谷歌浏览器发现某 http 资源已被加入到 HSTS 列表，浏览器内部会通过 307 作重定向</li>
<li>http 状态码中 301，302和307有什么区别<ol>
<li>301，Moved Permanently。永久重定向，该操作比较危险，需要谨慎操作：如果设置了301，但是一段时间后又想取消，但是浏览器中已经有了缓存，还是会重定向。</li>
<li>302，Found。临时重定向，但是会在重定向的时候改变 method: 把 POST 改成 GET，于是有了 307</li>
<li>307，Temporary Redirect。临时重定向，在重定向时不会改变 method</li>
</ol>
</li>
</ol>
</li>
<li>4XX 表示客户端错误<ol>
<li>400 错误的请求 对于服务器无法理解的参数，将会使用 400 作为返回码</li>
<li>401 Unauthorized 当没有权限的用户请求需要带有权限的资源时，会返回 401，此时携带正确的权限凭证再试一次可以解决问题；有时认证失败也会返回 401</li>
<li>403 请求被拒绝 我就是不想让你访问，不管你的权限凭证是否正确！</li>
<li>404 资源不存在</li>
<li>405 Method Not Allowed ： 我需要 POST 这条资源，你去 GET 个锤子</li>
<li>413 Payload Too Large 不要给我扔这么大的 Body，我处理不过来</li>
<li>418 I’m A Teapot 我想要个字符串，你给了我一个整数？</li>
<li>422 Unprocessable Entity 常用来处理不合法的参数校验。</li>
<li>429 Too Many Request 请求过多被限流。</li>
</ol>
</li>
<li>5XX 表示服务端错误<ol>
<li>500 服务器端未知错误</li>
<li>502 网关错误</li>
<li>503 服务暂时无法使用</li>
<li>504 Gateway Timeout 网关超时，上游应用层迟迟未响应</li>
</ol>
</li>
</ol>
<h3 id="18-http-状态码中-301，302和307有什么区别"><a href="#18-http-状态码中-301，302和307有什么区别" class="headerlink" title="18.http 状态码中 301，302和307有什么区别"></a>18.http 状态码中 301，302和307有什么区别</h3><ol>
<li>301，Moved Permanently。永久重定向，该操作比较危险，需要谨慎操作：如果设置了301，但是一段时间后又想取消，但是浏览器中已经有了缓存，还是会重定向。</li>
<li>302，Found。临时重定向，但是会在重定向的时候改变 method: 把 POST 改成 GET，于是有了 307</li>
<li>307，Temporary Redirect。临时重定向，在重定向时不会改变 method</li>
</ol>
<h3 id="19-使用-react-实现一个通用的-message-组件"><a href="#19-使用-react-实现一个通用的-message-组件" class="headerlink" title="19.使用 react 实现一个通用的 message 组件"></a>19.使用 react 实现一个通用的 message 组件</h3><ol>
<li>支持：<ol>
<li>自动消失（可配置时长）</li>
<li>支持不同类型（success、error、info、warning）</li>
<li>支持手动关闭</li>
<li>支持多个消息队列</li>
</ol>
</li>
</ol>
<h3 id="20-http-状态码-502-和-504-有什么区别"><a href="#20-http-状态码-502-和-504-有什么区别" class="headerlink" title="20.http 状态码 502 和 504 有什么区别"></a>20.http 状态码 502 和 504 有什么区别</h3><p>502 &#x3D; 服务器返回了错误的响应<br>504 &#x3D; 服务器等待超时了</p>
<h3 id="21-如何使用-react-hooks-实现-useFetch-请求数据"><a href="#21-如何使用-react-hooks-实现-useFetch-请求数据" class="headerlink" title="21.如何使用 react hooks 实现 useFetch 请求数据"></a>21.如何使用 react hooks 实现 useFetch 请求数据</h3><ol>
<li>useFetch 是一个自定义 Hook，用于在 React 组件中处理数据请求。 核心是<ol>
<li>自动触发请求（在组件加载时）</li>
<li>支持手动刷新数据</li>
<li>支持 loading、error 处理</li>
<li>支持依赖变化重新请求<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// useFetch（支持手动刷新 &amp; 依赖变化）</span><br><span class="hljs-keyword">import</span> &#123; useState, useEffect, useCallback &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-keyword">function</span> useFetch&lt;T&gt;(<span class="hljs-attr">url</span>: <span class="hljs-built_in">string</span>, options?: <span class="hljs-title class_">RequestInit</span>, <span class="hljs-attr">deps</span>: <span class="hljs-built_in">any</span>[] = []) &#123;<br>  <span class="hljs-keyword">const</span> [data, setData] = useState&lt;T | <span class="hljs-literal">null</span>&gt;(<span class="hljs-literal">null</span>);<br>  <span class="hljs-keyword">const</span> [loading, setLoading] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>);<br>  <span class="hljs-keyword">const</span> [error, setError] = useState&lt;<span class="hljs-title class_">Error</span> | <span class="hljs-literal">null</span>&gt;(<span class="hljs-literal">null</span>);<br><br>  <span class="hljs-keyword">const</span> fetchData = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">setLoading</span>(<span class="hljs-literal">true</span>);<br>    <span class="hljs-title function_">setError</span>(<span class="hljs-literal">null</span>);<br><br>    <span class="hljs-title function_">fetch</span>(url, options)<br>      .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (!res.<span class="hljs-property">ok</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`HTTP error! Status: <span class="hljs-subst">$&#123;res.status&#125;</span>`</span>);<br>        <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">json</span>();<br>      &#125;)<br>      .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> <span class="hljs-title function_">setData</span>(data))<br>      .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> <span class="hljs-title function_">setError</span>(err))<br>      .<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">setLoading</span>(<span class="hljs-literal">false</span>));<br>  &#125;, [url, ...deps]);<br><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">fetchData</span>();<br>  &#125;, [fetchData]);<br><br>  <span class="hljs-keyword">return</span> &#123; data, loading, error, <span class="hljs-attr">refetch</span>: fetchData &#125;;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> useFetch;<br><br><span class="hljs-comment">// 用法</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> useFetch <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./useFetch&quot;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">App</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">FC</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> [postId, setPostId] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">const</span> &#123; data, loading, error, refetch &#125; = <span class="hljs-title function_">useFetch</span>(<span class="hljs-string">`https://jsonplaceholder.typicode.com/posts/<span class="hljs-subst">$&#123;postId&#125;</span>`</span>, &#123;&#125;, [postId]);<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setPostId((prev) =&gt; prev + 1)&#125;&gt;加载下一篇文章<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;refetch&#125;</span>&gt;</span>手动刷新<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">      &#123;loading &amp;&amp; <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Loading...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>&#125;</span><br><span class="language-xml">      &#123;error &amp;&amp; <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Error: &#123;error.message&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>&#125;</span><br><span class="language-xml">      &#123;data &amp;&amp; <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;data.title&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;<br></code></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h3 id="22-react-如何使用-render-prop-component-请求数据"><a href="#22-react-如何使用-render-prop-component-请求数据" class="headerlink" title="22.react 如何使用 render prop component 请求数据"></a>22.react 如何使用 render prop component 请求数据</h3><ol>
<li>在 React 中，Render Prop 是一种模式，允许我们通过将函数作为子组件来共享逻辑。使用 Render Prop 组件可以很好地封装数据请求逻辑，同时保持组件的灵活性。<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 使用 Render Prop 组件请求数据</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState, useEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">FetchProps</span> &#123;<br>  <span class="hljs-attr">url</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">children</span>: <span class="hljs-function">(<span class="hljs-params">params: &#123; data: <span class="hljs-built_in">any</span>; loading: <span class="hljs-built_in">boolean</span>; error: <span class="hljs-built_in">Error</span> | <span class="hljs-literal">null</span> &#125;</span>) =&gt;</span> <span class="hljs-title class_">React</span>.<span class="hljs-property">ReactNode</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Fetch</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">FC</span>&lt;<span class="hljs-title class_">FetchProps</span>&gt; = <span class="hljs-function">(<span class="hljs-params">&#123; url, children &#125;</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> [data, setData] = useState&lt;<span class="hljs-built_in">any</span>&gt;(<span class="hljs-literal">null</span>);<br>  <span class="hljs-keyword">const</span> [loading, setLoading] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">true</span>);<br>  <span class="hljs-keyword">const</span> [error, setError] = useState&lt;<span class="hljs-title class_">Error</span> | <span class="hljs-literal">null</span>&gt;(<span class="hljs-literal">null</span>);<br><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">setLoading</span>(<span class="hljs-literal">true</span>);<br>    <span class="hljs-title function_">fetch</span>(url)<br>      .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (!res.<span class="hljs-property">ok</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`HTTP error! Status: <span class="hljs-subst">$&#123;res.status&#125;</span>`</span>);<br>        <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">json</span>();<br>      &#125;)<br>      .<span class="hljs-title function_">then</span>(setData)<br>      .<span class="hljs-title function_">catch</span>(setError)<br>      .<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">setLoading</span>(<span class="hljs-literal">false</span>));<br>  &#125;, [url]);<br><br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span>&#123;children(&#123; data, loading, error &#125;)&#125;<span class="hljs-tag">&lt;/&gt;</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Fetch</span>;<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Fetch</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./Fetch&quot;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">App</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">FC</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>文章详情<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Fetch</span> <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;https://jsonplaceholder.typicode.com/posts/1&quot;</span>&gt;</span></span><br><span class="language-xml">        &#123;(&#123; data, loading, error &#125;) =&gt; &#123;</span><br><span class="language-xml">          if (loading) return <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>加载中...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>;</span><br><span class="language-xml">          if (error) return <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>错误: &#123;error.message&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>;</span><br><span class="language-xml">          return <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;data.title&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>;</span><br><span class="language-xml">        &#125;&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Fetch</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;<br></code></pre></td></tr></table></figure></li>
<li>什么时候用 Render Prop？<ol>
<li>适用于不想被 Hook 规则限制 的情况（比如在 class 组件中使用）</li>
<li>适用于多个组件需要共享数据请求逻辑（避免重复编写 useFetch）</li>
</ol>
</li>
<li>但在现代 React 开发中，自定义 Hook (useFetch) 更受欢迎，Render Prop 主要用于兼容类组件的情况。</li>
</ol>
<h3 id="23-React-Portal-有哪些使用场景"><a href="#23-React-Portal-有哪些使用场景" class="headerlink" title="23.React Portal 有哪些使用场景"></a>23.React Portal 有哪些使用场景</h3><ol>
<li>React Portal 允许你将组件的渲染内容挂载到 DOM 之外的指定节点，但它仍然遵循 React 组件树的结构。</li>
<li>Portal 组件的内容会渲染到 #portal-root，但仍然属于原组件树的一部分。 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">ReactDOM</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-dom&quot;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">MyPortal</span> = (<span class="hljs-params">&#123; children &#125;</span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">createPortal</span>(children, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;portal-root&quot;</span>)!);<br>&#125;;<br></code></pre></td></tr></table></figure></li>
<li>Portal 解决 z-index 和 overflow: hidden 带来的 UI 问题，让浮动元素正确显示！ 🚀</li>
<li>主要应用场景<ol>
<li>模态框（Modal）<ol>
<li>防止被 overflow: hidden 限制</li>
<li>避免 z-index 层级问题</li>
<li>为什么用 Portal？<ol>
<li>如果 Modal 直接放在 body 内部某个 div 里，可能会受到 overflow: hidden 或 z-index 影响。用 Portal 可以让它始终显示在最顶层！</li>
</ol>
</li>
</ol>
</li>
<li>下拉菜单（Dropdown）<ol>
<li>避免 overflow: hidden 限制</li>
<li>保持菜单独立渲染</li>
<li>如果菜单嵌套在某个 overflow: hidden 的容器里，可能会被隐藏。使用 Portal 让它直接渲染到 body，就不会被裁剪！</li>
</ol>
</li>
<li>提示框（Tooltip）<ol>
<li>保证提示框不受父元素裁剪</li>
<li>让 Tooltip 可以自由定位</li>
<li>如果 Tooltip 在 table 或 overflow: hidden 容器里，它可能会被裁剪。Portal 让它可以自由浮动，避免这个问题！</li>
</ol>
</li>
<li>通知（toast）<ol>
<li>确保Toast消息在最顶层</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="24-什么是-virtual-DOM，它的引入带了什么好处"><a href="#24-什么是-virtual-DOM，它的引入带了什么好处" class="headerlink" title="24.什么是 virtual DOM，它的引入带了什么好处"></a>24.什么是 virtual DOM，它的引入带了什么好处</h3><ol>
<li>优点<ol>
<li>虚拟 DOM 最大的优势在于抽象了原本的渲染过程，实现了跨平台的能力，而不仅仅局限于浏览器的 DOM，可以是安卓和 IOS 的原生组件，可以是近期很火热的小程序，也可以是各种 GUI。</li>
<li>vdom 把渲染过程抽象化了，从而使得组件的抽象能力也得到提升，并且可以适配 DOM 以外的渲染目标。</li>
<li>Virtual DOM 在牺牲(牺牲很关键)部分性能的前提下，增加了可维护性，这也是很多框架的通性。 实现了对 DOM 的集中化操作，在数据改变时先对虚拟 DOM 进行修改，再反映到真实的 DOM中，用最小的代价来更新DOM，提高效率</li>
<li>打开了函数式 UI 编程的大门。</li>
<li>可以渲染到 DOM 以外的端，使得框架跨平台，比如 ReactNative，React VR 等。可以更好的实现 SSR，同构渲染等</li>
<li>组件的高度抽象化。</li>
</ol>
</li>
<li>缺点<ol>
<li>首次渲染大量 DOM 时，由于多了一层虚拟 DOM 的计算，会比 innerHTML 插入慢。</li>
<li>虚拟 DOM 需要在内存中的维护一份 DOM 的副本</li>
<li>如果虚拟 DOM 大量更改，这是合适的。但是单一的，频繁的更新的话，虚拟 DOM 将会花费更多的时间处理计算的工作。所以，如果你有一个DOM 节点相对较少页面，用虚拟 DOM，它实际上有可能会更慢。但对于大多数单页面应用，这应该都会更快。</li>
</ol>
</li>
</ol>
<h3 id="25-react-与-vue-数组中-key-的作用是什么"><a href="#25-react-与-vue-数组中-key-的作用是什么" class="headerlink" title="25.react 与 vue 数组中 key 的作用是什么"></a>25.react 与 vue 数组中 key 的作用是什么</h3><ol>
<li>在 React 和 Vue 中，key 是 列表渲染时的唯一标识，它的作用是提高性能、优化 Diffing 算法、减少不必要的 DOM 更新。</li>
<li>diff算法需要比对虚拟dom的修改，然后异步的渲染到页面中，当出现大量相同的标签时，vnode会首先判断key和标签名是否一致，如果一致再去判断子节点一致，使用key可以帮助diff算法提升判断的速度，在页面重新渲染时更快消耗更少</li>
</ol>
<h3 id="26-webpack-是用来做什么的，原理是什么"><a href="#26-webpack-是用来做什么的，原理是什么" class="headerlink" title="26.webpack 是用来做什么的，原理是什么"></a>26.webpack 是用来做什么的，原理是什么</h3><ol>
<li>Webpack 是一个 前端打包工具，用于将 JavaScript、CSS、图片等资源打包、优化，最终生成浏览器可执行的静态文件。</li>
<li>Webpack 的核心功能<ol>
<li>模块化打包：支持 ESModule (ES6)、CommonJS、AMD 等不同模块格式。</li>
<li>代码优化：自动压缩 JS&#x2F;CSS、Tree Shaking（去除无用代码）、代码分割（按需加载）。</li>
<li>处理资源：可打包 CSS、图片、字体等非 JS 资源。</li>
<li>HMR（热更新）：在开发过程中，修改代码后自动刷新页面。</li>
</ol>
</li>
<li>Webpack 的核心概念 ： Webpack 主要基于 入口 (Entry)、输出 (Output)、加载器 (Loader)、插件 (Plugin) 这四个核心概念。<ol>
<li><strong>入口 (entry)</strong> entry 指定 Webpack 打包的入口文件，从这里开始分析依赖关系。<ol>
<li><code>module.exports = &#123; entry: &quot;./src/index.js&quot;,&#125;;</code></li>
<li>Webpack 会从 index.js 开始，找到所有依赖的模块，并进行打包。</li>
</ol>
</li>
<li><strong>输出 (output)</strong> output 指定 Webpack 打包后的文件存放位置： <figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dts">module.<span class="hljs-attr">exports</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">  output:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    filename:</span> <span class="hljs-string">&quot;bundle.js&quot;</span>, <span class="hljs-comment">// 生成的 JS 文件名</span><br><span class="hljs-symbol">    path:</span> __dirname + <span class="hljs-string">&quot;/dist&quot;</span>, <span class="hljs-comment">// 输出目录</span><br>  <span class="hljs-punctuation">&#125;</span>,<br><span class="hljs-punctuation">&#125;;</span><br></code></pre></td></tr></table></figure>
 Webpack 会把打包后的 bundle.js 放到 dist&#x2F; 目录中。</li>
<li>加载器 (loader) Loader 让 Webpack 能够解析非 JS 资源，比如 CSS、图片、TypeScript 等。<ol>
<li>常见的 Loader：<ol>
<li>babel-loader：编译 ES6+ 代码，支持 TypeScript、React JSX</li>
<li>file-loader：处理图片、字体等静态资源</li>
<li>sass-loader：解析 SASS&#x2F;SCSS 文件</li>
</ol>
</li>
</ol>
</li>
<li>插件 (plugins) Plugins 用于扩展 Webpack 功能，比如优化打包、压缩代码、生成 HTML 等。<ol>
<li>常见的 Webpack 插件：<ol>
<li>HtmlWebpackPlugin：自动生成 HTML，并注入打包后的 JS</li>
<li>MiniCssExtractPlugin：将 CSS 抽离成单独文件</li>
<li>TerserPlugin：压缩 JavaScript 代码</li>
<li>CleanWebpackPlugin：清理 dist 目录，防止旧文件残留</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>Webpack 的打包流程 : Webpack 打包的整个过程可以分为 5 步：<ol>
<li>解析配置文件：读取 webpack.config.js，获取 entry&#x2F;output&#x2F;loaders&#x2F;plugins。</li>
<li>构建依赖图：从 entry 入口开始，递归解析依赖模块。</li>
<li>使用 Loader 处理不同类型的文件，如 css-loader 解析 CSS，babel-loader 处理 ES6 代码。</li>
<li>生成优化后的代码：<ol>
<li>Tree Shaking：移除未使用的代码</li>
<li>代码分割：按需加载，提高性能</li>
<li>压缩优化：压缩 JS&#x2F;CSS&#x2F;图片</li>
</ol>
</li>
<li>输出最终文件：将打包后的文件写入 output.path 目录，通常是 dist&#x2F;。</li>
</ol>
</li>
<li>Webpack vs. Vite vs. Rollup<table>
<thead>
<tr>
<th>特性</th>
<th>webpack</th>
<th>vite</th>
<th>Rollup</th>
</tr>
</thead>
<tbody><tr>
<td>场景</td>
<td>通用</td>
<td>热更新快</td>
<td>库&#x2F;组件打包</td>
</tr>
<tr>
<td>打包方式</td>
<td>依赖Tree Shaking、优化</td>
<td>ES Moudule</td>
<td>按需导出</td>
</tr>
<tr>
<td>性能</td>
<td>生产环境优化强</td>
<td>开发环境极快</td>
<td>体积更小</td>
</tr>
</tbody></table>
</li>
</ol>
<h3 id="27-webpack-中的-loader-的作用是什么"><a href="#27-webpack-中的-loader-的作用是什么" class="headerlink" title="27.webpack 中的 loader 的作用是什么"></a>27.webpack 中的 loader 的作用是什么</h3><ol>
<li>在 Webpack 中，Loader（加载器）用于处理 Webpack 默认无法解析的文件类型，比如 CSS、图片、字体、SASS、TypeScript 等，让这些文件也能被 Webpack 识别并打包。</li>
<li>Loader 需要在 Webpack 配置文件 webpack.config.js 里通过 module.rules 指定： <figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs dts">module.<span class="hljs-attr">exports</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">  module:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    rules:</span> [<br>      <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">        test:</span> /\.ext$/, <span class="hljs-comment">// 匹配的文件类型（正则表达式）</span><br><span class="hljs-symbol">        use:</span> [<span class="hljs-string">&quot;loader-name&quot;</span>], <span class="hljs-comment">// 需要使用的 Loader</span><br>      <span class="hljs-punctuation">&#125;</span>,<br>    ],<br>  <span class="hljs-punctuation">&#125;</span>,<br><span class="hljs-punctuation">&#125;;</span><br><br><span class="hljs-comment">// 处理 JavaScript（使用 Babel 转译 ES6+）</span><br><br>module.<span class="hljs-attr">exports</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">  module:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    rules:</span> [<br>      <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">        test:</span> /\.js$/, <span class="hljs-comment">// 匹配 .js 文件</span><br><span class="hljs-symbol">        exclude:</span> /node_modules/, <span class="hljs-comment">// 排除 node_modules</span><br><span class="hljs-symbol">        use:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">          loader:</span> <span class="hljs-string">&quot;babel-loader&quot;</span>,<br><span class="hljs-symbol">          options:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">            presets:</span> [<span class="hljs-string">&quot;@babel/preset-env&quot;</span>], <span class="hljs-comment">// 转换 ES6+ 语法</span><br>          <span class="hljs-punctuation">&#125;</span>,<br>        <span class="hljs-punctuation">&#125;</span>,<br>      <span class="hljs-punctuation">&#125;</span>,<br>    ],<br>  <span class="hljs-punctuation">&#125;</span>,<br><span class="hljs-punctuation">&#125;;</span><br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="28-有没有自己写过一个webpack的loader"><a href="#28-有没有自己写过一个webpack的loader" class="headerlink" title="28.有没有自己写过一个webpack的loader"></a>28.有没有自己写过一个webpack的loader</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span><span class="hljs-variable">.exports</span> = <span class="hljs-keyword">function</span> (source) &#123;<br>  <span class="hljs-keyword">return</span> source<span class="hljs-variable">.toUpperCase</span>(); <span class="hljs-comment">// 转换为大写</span><br>&#125;;<br><br><span class="hljs-keyword">module</span><span class="hljs-variable">.exports</span> = &#123;<br>  <span class="hljs-keyword">module</span>: &#123;<br>    rules: [<br>      &#123;<br>        test: /\<span class="hljs-variable">.txt</span>$/, <span class="hljs-comment">// 处理 .txt 文件</span><br>        <span class="hljs-keyword">use</span>: <span class="hljs-string">&quot;./loaders/uppercase-loader.js&quot;</span>,<br>      &#125;,<br>    ],<br>  &#125;,<br>&#125;;<br>效果：如果 <span class="hljs-keyword">input</span><span class="hljs-variable">.txt</span> 内容是 hello world，经过 uppercase-loader 处理后，它变成 HELLO WORLD。<br></code></pre></td></tr></table></figure>
<h3 id="29-webpack-中plugin的作用是什么，有没有自己写过"><a href="#29-webpack-中plugin的作用是什么，有没有自己写过" class="headerlink" title="29.webpack 中plugin的作用是什么，有没有自己写过"></a>29.webpack 中plugin的作用是什么，有没有自己写过</h3><ol>
<li>在 Webpack 中，Plugin（插件）用于扩展 Webpack 的功能，比如优化打包、自动生成 HTML、压缩文件、清理目录等。简单来说，Loader 用于处理文件（CSS、JS、图片），Plugin 用于优化、增强 Webpack 本身的能力</li>
<li>Webpack Plugin 主要用于以下场景：<ol>
<li>优化构建输出<ol>
<li>HtmlWebpackPlugin：自动生成 index.html 并注入打包后的 JS 文件</li>
<li>MiniCssExtractPlugin：把 CSS 抽离成单独的文件，减少 JS 体积。</li>
<li>TerserPlugin：压缩 JavaScript 代码，减少体积。</li>
</ol>
</li>
<li>增强 Webpack 构建能力<ol>
<li>DefinePlugin：在编译时定义环境变量，例如 process.env.NODE_ENV。</li>
<li>HotModuleReplacementPlugin：启用 HMR（热更新），提升开发体验。</li>
</ol>
</li>
<li>资源管理<ol>
<li>CopyWebpackPlugin：把静态资源复制到 dist&#x2F; 目录，例如 public&#x2F; 文件夹里的内容。</li>
<li>CleanWebpackPlugin：每次打包前清理 dist&#x2F; 目录，防止残留旧文件。</li>
</ol>
</li>
</ol>
</li>
<li>如何使用 Webpack Plugin<ol>
<li>Webpack Plugin 需要在 webpack.config.js 的 plugins 数组中配置，通常需要 new 关键字创建实例。<ol>
<li>生成 HTML 文件 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 会在 dist/ 目录下生成 index.html，并自动引入打包后的 bundle.js。</span><br><br><span class="hljs-type">const</span> HtmlWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;html-webpack-plugin&quot;</span>);<br>    <br><span class="hljs-keyword">module</span>.exports = &#123;<br>  plugins: [<br>    <span class="hljs-keyword">new</span> <span class="hljs-built_in">HtmlWebpackPlugin</span>(&#123;<br>      <span class="hljs-keyword">template</span>: <span class="hljs-string">&quot;./src/index.html&quot;</span>, <span class="hljs-comment">// 指定模板文件</span><br>      filename: <span class="hljs-string">&quot;index.html&quot;</span>, <span class="hljs-comment">// 生成的 HTML 文件名</span><br>      inject: <span class="hljs-string">&quot;body&quot;</span>, <span class="hljs-comment">// 自动注入打包后的 JS</span><br>    &#125;),<br>  ],<br>&#125;;<br></code></pre></td></tr></table></figure></li>
<li>抽离 CSS <figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-comment">// 将 CSS 文件从 JS 中提取出来，避免 CSS 被 JS 依赖，提升加载速度。</span><br><br>const MiniCssExtractP<span class="hljs-attr">lugin</span> <span class="hljs-operator">=</span> require(<span class="hljs-string">&quot;mini-css-extract-plugin&quot;</span>)<span class="hljs-punctuation">;</span><br>    <br>module.<span class="hljs-attr">exports</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">  module:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    rules:</span> [<br>      <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">        test:</span> /\.css$/,<br><span class="hljs-symbol">        use:</span> [MiniCssExtractPlugin.loader, <span class="hljs-string">&quot;css-loader&quot;</span>],<br>      <span class="hljs-punctuation">&#125;</span>,<br>    ],<br>  <span class="hljs-punctuation">&#125;</span>,<br><span class="hljs-symbol">  plugins:</span> [<br>    new MiniCssExtractPlugin(<span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">      filename:</span> <span class="hljs-string">&quot;[name].[contenthash].css&quot;</span>, <span class="hljs-comment">// 生成的 CSS 文件</span><br>    <span class="hljs-punctuation">&#125;</span>),<br>  ],<br><span class="hljs-punctuation">&#125;;</span><br></code></pre></td></tr></table></figure></li>
<li>定义全局变量 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 在代码中可以用 process.env.NODE_ENV 判断当前环境：</span><br><br><span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;webpack&quot;</span>);<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-keyword">new</span> webpack.<span class="hljs-title class_">DefinePlugin</span>(&#123;<br>      <span class="hljs-string">&quot;process.env.NODE_ENV&quot;</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-string">&quot;production&quot;</span>), <span class="hljs-comment">// 定义环境变量</span><br>    &#125;),<br>  ],<br>&#125;;<br></code></pre></td></tr></table></figure></li>
<li>复制静态文件 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 比如 public/ 目录下有 favicon.ico，它会被复制到 dist/，适合部署时保留静态文件</span><br><br><span class="hljs-type">const</span> <span class="hljs-variable">CopyWebpackPlugin</span> <span class="hljs-operator">=</span> require(<span class="hljs-string">&quot;copy-webpack-plugin&quot;</span>);<br><br><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;<br>  plugins: [<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">CopyWebpackPlugin</span>(&#123;<br>      patterns: [&#123; from: <span class="hljs-string">&quot;public&quot;</span>, to: <span class="hljs-string">&quot;dist&quot;</span> &#125;], <span class="hljs-comment">// 把 public 目录复制到 dist</span><br>    &#125;),<br>  ],<br>&#125;;<br></code></pre></td></tr></table></figure></li>
<li>清理 dist 目录 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 防止 dist/ 里残留旧文件，确保打包后是最新内容。</span><br><br><span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">CleanWebpackPlugin</span> &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;clean-webpack-plugin&quot;</span>);<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">CleanWebpackPlugin</span>(), <span class="hljs-comment">// 每次构建前清理 dist 目录</span><br>  ],<br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
<li>如何编写自定义 Webpack Plugin<ol>
<li>当 Webpack 构建完成后，控制台显示 🎉 Build Done! <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// MyPlugin.js</span><br><span class="hljs-comment">// apply(compiler)：插件的核心方法，compiler 是 Webpack 编译器对象。</span><br><span class="hljs-comment">// compiler.hooks.done.tap：Webpack 构建完成时触发。</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPlugin</span> &#123;<br>  <span class="hljs-title function_">apply</span>(<span class="hljs-params">compiler</span>) &#123;<br>    compiler.<span class="hljs-property">hooks</span>.<span class="hljs-property">done</span>.<span class="hljs-title function_">tap</span>(<span class="hljs-string">&quot;MyPlugin&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;🎉 Build Done!&quot;</span>);<br>    &#125;);<br>  &#125;<br>&#125;<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title class_">MyPlugin</span>;<br><br><span class="hljs-comment">// 使用</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">MyPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./MyPlugin&quot;</span>);<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">plugins</span>: [<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPlugin</span>()],<br>&#125;;<br></code></pre></td></tr></table></figure></li>
<li>更复杂的 Plugin（记录编译时间）: 在 Webpack 开始编译时，记录时间,在 Webpack 编译结束时，计算耗时。 <figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BuildTimePlugin</span> &#123;<br>  apply(compiler) &#123;<br>    compiler.hooks.compile.tap(<span class="hljs-string">&quot;BuildTimePlugin&quot;</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>      console.time(<span class="hljs-string">&quot;⏳ Build Time&quot;</span>);<br>    &#125;);<br><br>    compiler.hooks.done.tap(<span class="hljs-string">&quot;BuildTimePlugin&quot;</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>      console.timeEnd(<span class="hljs-string">&quot;⏳ Build Time&quot;</span>);<br>    &#125;);<br>  &#125;<br>&#125;<br><br>module.<span class="hljs-built_in">exports</span> = BuildTimePlugin;<br></code></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h3 id="30-使用-webpack-时如何优化项目体积"><a href="#30-使用-webpack-时如何优化项目体积" class="headerlink" title="30.使用 webpack 时如何优化项目体积"></a>30.使用 webpack 时如何优化项目体积</h3><ol>
<li>代码拆分（Code Splitting）<ol>
<li><strong>拆分 node_modules（第三方库分包）</strong><ol>
<li>使用 Webpack 内置的 SplitChunksPlugin，将 node_modules 里的依赖单独打包。 <figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs dts">module.<span class="hljs-attr">exports</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">  optimization:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    splitChunks:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">      chunks:</span> <span class="hljs-string">&quot;all&quot;</span>, <span class="hljs-comment">// 对所有代码进行分包</span><br><span class="hljs-symbol">      cacheGroups:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">        vendors:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">          test:</span> /[\\/]node_modules[\\/]/,<br><span class="hljs-symbol">          name:</span> <span class="hljs-string">&quot;vendors&quot;</span>,<br><span class="hljs-symbol">          chunks:</span> <span class="hljs-string">&quot;all&quot;</span>,<br>        <span class="hljs-punctuation">&#125;</span>,<br>      <span class="hljs-punctuation">&#125;</span>,<br>    <span class="hljs-punctuation">&#125;</span>,<br>  <span class="hljs-punctuation">&#125;</span>,<br><span class="hljs-punctuation">&#125;;</span><br></code></pre></td></tr></table></figure></li>
<li>效果：vendors.js（第三方库） main.js（业务代码）；这样 用户访问时，可以缓存 vendors.js，下次加载更快</li>
</ol>
</li>
<li><strong>按需加载（Lazy Loading）</strong></li>
</ol>
</li>
<li>压缩 JavaScript 代码<ol>
<li>使用 TerserPlugin（Webpack 内置 JS 压缩工具）:<ol>
<li>删除未使用的代码（Tree Shaking）。</li>
<li>移除 console.log、debugger 等开发代码。</li>
<li>变量名、函数名压缩，减少 JS 体积。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">const</span> <span class="hljs-variable">TerserPlugin</span> <span class="hljs-operator">=</span> require(<span class="hljs-string">&quot;terser-webpack-plugin&quot;</span>);<br><br><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;<br>  optimization: &#123;<br>    minimize: <span class="hljs-literal">true</span>,<br>    minimizer: [<span class="hljs-keyword">new</span> <span class="hljs-title class_">TerserPlugin</span>()],<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
<li>Tree Shaking（删除未使用代码）<ol>
<li><p>目标：移除 JavaScript 中未使用的代码，只打包实际用到的部分。</p>
</li>
<li><p>确保 package.json 中 sideEffects: false ; 作用：告诉 Webpack 可以安全移除未使用的 ES6 模块（比如未调用的函数）。</p>
 <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;project&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1.0.0&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;sideEffects&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li>
<li><p>仅导入需要的函数 </p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// ❌ 不推荐（会引入整个 lodash）</span><br><span class="hljs-keyword">import</span> _ <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;lodash&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(_.<span class="hljs-title function_">map</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], <span class="hljs-function">(<span class="hljs-params">n</span>) =&gt;</span> n * <span class="hljs-number">2</span>));<br><br><span class="hljs-comment">// ✅ 推荐（只导入 map）</span><br><span class="hljs-keyword">import</span> &#123; map &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;lodash-es&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">map</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], <span class="hljs-function">(<span class="hljs-params">n</span>) =&gt;</span> n * <span class="hljs-number">2</span>));<br></code></pre></td></tr></table></figure>
<p> lodash-es 版本支持 Tree Shaking，而 lodash 需要 babel-plugin-lodash 处理。</p>
</li>
</ol>
</li>
<li>压缩 CSS <ol>
<li>目标：移除无用 CSS，减少 CSS 文件体积。</li>
<li>使用 css-minimizer-webpack-plugin</li>
</ol>
</li>
<li>Gzip 压缩<ol>
<li>目标：服务器返回 压缩后的文件，提高加载速度。</li>
<li>使用 compression-webpack-plugin <figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dts">const CompressionP<span class="hljs-attr">lugin</span> <span class="hljs-operator">=</span> require(<span class="hljs-string">&quot;compression-webpack-plugin&quot;</span>)<span class="hljs-punctuation">;</span><br>    <br>module.<span class="hljs-attr">exports</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">  plugins:</span> [<br>    new CompressionPlugin(<span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">      algorithm:</span> <span class="hljs-string">&quot;gzip&quot;</span>,<br><span class="hljs-symbol">      test:</span> /\.(js|css)$/, <span class="hljs-comment">// 仅压缩 JS 和 CSS</span><br><span class="hljs-symbol">      threshold:</span> <span class="hljs-number">10240</span>, <span class="hljs-comment">// 文件大于 10KB 时才进行压缩</span><br><span class="hljs-symbol">      minRatio:</span> <span class="hljs-number">0.8</span>, <span class="hljs-comment">// 仅压缩比 &lt; 0.8 的文件</span><br>    <span class="hljs-punctuation">&#125;</span>),<br>  ],<br><span class="hljs-punctuation">&#125;;</span><br></code></pre></td></tr></table></figure>
  效果：<br>•	服务器会返回 .gz 文件，比如 bundle.js.gz，大大减少体积。<br>•	浏览器自动解压，不影响运行。</li>
</ol>
</li>
<li>图片优化<ol>
<li>WebP 格式（比 PNG&#x2F;JPG 体积小）使用 image-webpack-loader</li>
</ol>
</li>
<li>生产环境优化<ol>
<li>确保 Webpack 运行在 production 模式 <code>NODE_ENV=production webpack --mode production</code></li>
<li>Webpack 内部会自动执行优化：<ol>
<li>启用 Tree Shaking。</li>
<li>开启 TerserPlugin 进行压缩。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="31-webpack-中什么是-HMR，原理是什么"><a href="#31-webpack-中什么是-HMR，原理是什么" class="headerlink" title="31.webpack 中什么是 HMR，原理是什么"></a>31.webpack 中什么是 HMR，原理是什么</h3><ol>
<li>HMR（Hot Module Replacement，热模块替换）是 Webpack 的一个开发模式功能，用于 在不刷新整个页面的情况下更新代码，从而提升开发效率。</li>
<li>HMR 通过 Webpack DevServer（webpack-dev-server）或 webpack-hot-middleware 实现，它的核心原理如下：<ol>
<li>webpack 对文件系统进行 watch 打包到内存中</li>
<li>devServer 通知浏览器端文件发生改变，在这一阶段，sockjs 是服务端和浏览器端之间的桥梁，在启动 devServer 的时候，sockjs 在服务端和浏览器端建立了一个 webSocket 长连接，以便将 webpack 编译和打包的各个阶段状态告知浏览器</li>
<li>webpack-dev-server&#x2F;client 接收到服务端消息做出响应</li>
<li>webpack 接收到最新 hash 值验证并请求模块代码</li>
<li>HotModuleReplacement.runtime 对模块进行热更新 </li>
<li>调用accept 方法，及时将新后的内容插入到页面中</li>
</ol>
</li>
<li>如何在 Webpack 中启用 HMR<ol>
<li><code>npm install webpack-dev-server --save-dev</code></li>
<li>在 webpack.config.js 中启用 HMR： <figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs dts">const <span class="hljs-attr">webpack</span> <span class="hljs-operator">=</span> require(<span class="hljs-string">&quot;webpack&quot;</span>)<span class="hljs-punctuation">;</span><br>const <span class="hljs-attr">path</span> <span class="hljs-operator">=</span> require(<span class="hljs-string">&quot;path&quot;</span>)<span class="hljs-punctuation">;</span><br><br>module.<span class="hljs-attr">exports</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">  mode:</span> <span class="hljs-string">&quot;development&quot;</span>,<br><span class="hljs-symbol">  entry:</span> <span class="hljs-string">&quot;./src/index.js&quot;</span>,<br><span class="hljs-symbol">  devServer:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    hot:</span> true, <span class="hljs-comment">// 开启 HMR</span><br><span class="hljs-symbol">    static:</span> path.resolve(__dirname, <span class="hljs-string">&quot;dist&quot;</span>), <span class="hljs-comment">// 服务器访问路径</span><br><span class="hljs-symbol">    port:</span> <span class="hljs-number">3000</span>, <span class="hljs-comment">// 端口</span><br>  <span class="hljs-punctuation">&#125;</span>,<br><span class="hljs-symbol">  plugins:</span> [<br>    new webpack.HotModuleReplacementPlugin(), <span class="hljs-comment">// 启用 HMR</span><br>  ],<br><span class="hljs-punctuation">&#125;;</span><br></code></pre></td></tr></table></figure></li>
<li>JS 默认不会自动热替换，需要手动处理： <figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs moonscript"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">module</span>.hot) &#123;<br>      <span class="hljs-built_in">module</span>.hot.accept(<span class="hljs-string">&quot;./app.js&quot;</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>        console.log(<span class="hljs-string">&quot;🔥 模块更新了！&quot;</span>);<br>      &#125;);<br>    &#125;<br></code></pre></td></tr></table></figure></li>
<li>处理 React React 组件默认不会自动 HMR，需要 react-refresh-webpack-plugin：<ol>
<li><code>npm install @pmmmwh/react-refresh-webpack-plugin react-refresh --save-dev</code></li>
<li>修改 webpack.config.js： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">const</span> <span class="hljs-variable">ReactRefreshWebpackPlugin</span> <span class="hljs-operator">=</span> require(<span class="hljs-string">&quot;@pmmmwh/react-refresh-webpack-plugin&quot;</span>);<br><br><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;<br>  mode: <span class="hljs-string">&quot;development&quot;</span>,<br>  plugins: [<span class="hljs-keyword">new</span> <span class="hljs-title class_">ReactRefreshWebpackPlugin</span>()],<br>&#125;;<br></code></pre></td></tr></table></figure></li>
<li>css 直接支持热更新替换 无需刷新</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="32-简述-http-的缓存机制"><a href="#32-简述-http-的缓存机制" class="headerlink" title="32.简述 http 的缓存机制"></a>32.简述 http 的缓存机制</h3><ol>
<li>强制缓存<ol>
<li>浏览器直接使用缓存，不向服务器发送请求。</li>
<li>关键字段：<ol>
<li>Cache-Control<ol>
<li>Cache-Control 是 HTTP&#x2F;1.1 的缓存控制字段，优先级高于 Expires：</li>
<li><code>Cache-Control: max-age=3600, public</code><ol>
<li>max-age&#x3D;3600：表示缓存 3600 秒（1 小时），1 小时内不请求服务器。</li>
<li>public：所有用户（包括 CDN）都可以缓存。</li>
<li>private：仅浏览器可以缓存，代理服务器不缓存。</li>
<li>no-cache：需要走协商缓存（不代表完全不缓存）。</li>
<li>no-store：完全不缓存，每次都请求服务器。</li>
</ol>
</li>
</ol>
</li>
<li>Expires（已过时）<ol>
<li>Expires 是 HTTP&#x2F;1.0 的缓存控制字段，表示缓存过期时间：</li>
<li><code>Expires: Wed, 25 Mar 2025 10:00:00 GMT</code></li>
<li>由于 Expires 依赖于客户端时间，可能会受本地时间影响，一般用 Cache-Control 代替。</li>
</ol>
</li>
</ol>
</li>
<li>工作流程：<ol>
<li>浏览器检查缓存。</li>
<li>若缓存未过期，直接从缓存中取数据，不发请求。</li>
<li>若缓存过期，则走协商缓存或重新请求资源。</li>
</ol>
</li>
<li>场景：静态资源（css、Js、img）</li>
</ol>
</li>
<li>协商缓存<ol>
<li>如果缓存过期，浏览器会向服务器发送请求，但服务器可能不会返回完整数据，而是返回304 Not Modified，告诉浏览器使用缓存。</li>
<li>关键字段：<ol>
<li>ETag &#x2F; If-None-Match<ol>
<li><strong>ETag</strong>（优先级高） 服务器返回的 ETag 是文件的唯一标识符，例如：<code>ETag: &quot;5d8c72a5d789&quot;</code><ol>
<li>浏览器下次请求时，会带上 If-None-Match: “5d8c72a5d789”。</li>
<li>服务器对比 ETag，如果一样，返回 304，否则返回 200 并更新 ETag。</li>
</ol>
</li>
</ol>
</li>
<li><strong>Last-Modified</strong> &#x2F; If-Modified-Since<ol>
<li>Last-Modified 记录的是文件最后修改时间：<code>Last-Modified: Mon, 24 Mar 2025 12:00:00 GMT</code><ol>
<li>浏览器请求时，会带 If-Modified-Since: Mon, 24 Mar 2025 12:00:00 GMT</li>
<li>服务器对比文件是否修改：<ol>
<li>没变：返回 304，浏览器使用缓存。</li>
<li>修改了：返回 200 并更新 Last-Modified。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>如果文件修改频率很高，Last-Modified 可能不够精确，所以 ETag 优先级更高。</li>
</ol>
</li>
<li>工作流程：<ol>
<li>浏览器发送请求时，携带上次的缓存标识（If-None-Match 或 If-Modified-Since）</li>
<li>服务器比对是否更新：<ol>
<li>若资源未变化，返回 304 Not Modified，浏览器使用缓存。</li>
<li>若资源变化，返回 200 OK 并附带最新内容。</li>
</ol>
</li>
</ol>
</li>
<li>场景：可能频繁更新的资源</li>
</ol>
</li>
<li>缓存优先级：<ol>
<li>先检查强缓存（Cache-Control: max-age）</li>
<li>强缓存失效后，检查协商缓存（ETag 或 Last-Modified）</li>
<li>如果协商缓存也失效，则重新请求服务器</li>
</ol>
</li>
</ol>
<h3 id="33-使用-webpack-打包时，如何更好地利用-long-term-cache"><a href="#33-使用-webpack-打包时，如何更好地利用-long-term-cache" class="headerlink" title="33.使用 webpack 打包时，如何更好地利用 long term cache"></a>33.使用 webpack 打包时，如何更好地利用 long term cache</h3><p>Long Term Cache（长期缓存）主要用于 提升网站性能，减少用户每次访问时加载的资源量，让浏览器尽可能使用缓存，只更新真正修改的部分。Webpack 通过 文件哈希、代码分割、CDN 配合等 手段，实现高效的缓存管理。</p>
<h3 id="34-http-proxy-的原理是什么"><a href="#34-http-proxy-的原理是什么" class="headerlink" title="34.http proxy 的原理是什么"></a>34.http proxy 的原理是什么</h3><p>HTTP 代理（Proxy）是一种中间服务器，它位于 客户端（浏览器） 和 目标服务器 之间，帮助转发 HTTP 请求和响应，用于加速访问、隐藏 IP、负载均衡、缓存、请求过滤等。</p>
<h3 id="35-随着-http2-的发展，webpack-有没有更好的打包方案"><a href="#35-随着-http2-的发展，webpack-有没有更好的打包方案" class="headerlink" title="35.随着 http2 的发展，webpack 有没有更好的打包方案"></a>35.随着 http2 的发展，webpack 有没有更好的打包方案</h3><p>Webpack 支持通过 splitChunks 配置项进行代码分割,可以将公共模块提取为独立的 chunk,利用 HTTP&#x2F;2 的多路复用特性提高资源加载效率。Webpack 支持动态导入,可以实现按需加载,减小初次加载的包大小,利用 HTTP&#x2F;2 的多路复用进行并发加载。 Webpack 可以与支持 HTTP&#x2F;2 Server Push 的服务器配合使用,自动推送关联资源,提高首屏加载速度</p>
<h3 id="36-网站性能优化都有哪些点"><a href="#36-网站性能优化都有哪些点" class="headerlink" title="36.网站性能优化都有哪些点"></a>36.网站性能优化都有哪些点</h3><p>减少http请求次数： CSS Sprites, JS、CSS源码压缩、图片大小适当控制； 网页Gzip，CDN托管，data缓存 ，图片服务器。 尽量减少内联样式 将脚本放在底部 少用全局变量、缓存DOM节点查找的结果 图片预加载 按需加载</p>
<h3 id="37-随着-http2-的发展，前端性能优化中的哪些传统方案可以被替代"><a href="#37-随着-http2-的发展，前端性能优化中的哪些传统方案可以被替代" class="headerlink" title="37.随着 http2 的发展，前端性能优化中的哪些传统方案可以被替代"></a>37.随着 http2 的发展，前端性能优化中的哪些传统方案可以被替代</h3><h3 id="38-http2-与-http1-1-有什么改进"><a href="#38-http2-与-http1-1-有什么改进" class="headerlink" title="38.http2 与 http1.1 有什么改进"></a>38.http2 与 http1.1 有什么改进</h3><ol>
<li>二进制分帧</li>
<li>请求多路复用 (Stream&#x2F;Frame)</li>
<li>头部压缩: (HPack)</li>
<li>服务端推送: (PUSH_PROMISE)</li>
</ol>
<h3 id="39-Tree-Shaking-的原理是什么"><a href="#39-Tree-Shaking-的原理是什么" class="headerlink" title="39.Tree Shaking 的原理是什么"></a>39.Tree Shaking 的原理是什么</h3><p>Tree Shaking 是 JavaScript 代码优化技术，主要用于 删除未使用的代码（Dead Code Elimination），从而减少最终打包的文件体积。<br>Tree Shaking 依赖 ES Module 的静态分析，通过 消除未使用的代码 来优化打包。主要涉及以下技术点：</p>
<h3 id="40-如何实现-promise-map，限制-promise-并发数"><a href="#40-如何实现-promise-map，限制-promise-并发数" class="headerlink" title="40.如何实现 promise.map，限制 promise 并发数"></a>40.如何实现 promise.map，限制 promise 并发数</h3><h3 id="41-vue-中-v-if-和-v-show-的区别是什么"><a href="#41-vue-中-v-if-和-v-show-的区别是什么" class="headerlink" title="41.vue 中 v-if 和 v-show 的区别是什么"></a>41.vue 中 v-if 和 v-show 的区别是什么</h3><p>v-if 是 “真正的条件渲染”，元素 会被销毁和重新创建。每次显示会重新触发生命周期（created 等）<br>v-show 是 “简单的显示&#x2F;隐藏”，元素 始终在 DOM 中，只是切换 display: none。生命周期只触发一次</p>
<h3 id="42-vue-中-computed-的原理是什么"><a href="#42-vue-中-computed-的原理是什么" class="headerlink" title="42.vue 中 computed 的原理是什么"></a>42.vue 中 computed 的原理是什么</h3><h3 id="43-vue-loader-的实现原理是什么"><a href="#43-vue-loader-的实现原理是什么" class="headerlink" title="43.vue-loader 的实现原理是什么"></a>43.vue-loader 的实现原理是什么</h3><h3 id="44-react-中-ref-是干什么用的，有哪些使用场景"><a href="#44-react-中-ref-是干什么用的，有哪些使用场景" class="headerlink" title="44.react 中 ref 是干什么用的，有哪些使用场景"></a>44.react 中 ref 是干什么用的，有哪些使用场景</h3><h3 id="45-你们的前端代码上线部署一次需要多长时间，需要人为干预吗"><a href="#45-你们的前端代码上线部署一次需要多长时间，需要人为干预吗" class="headerlink" title="45.你们的前端代码上线部署一次需要多长时间，需要人为干预吗"></a>45.你们的前端代码上线部署一次需要多长时间，需要人为干预吗</h3><h3 id="46-如何使用-react-vue-实现一个-message-API"><a href="#46-如何使用-react-vue-实现一个-message-API" class="headerlink" title="46.如何使用 react&#x2F;vue 实现一个 message API"></a>46.如何使用 react&#x2F;vue 实现一个 message API</h3><h3 id="47-有没有用-npm-发布过-package，如何发布"><a href="#47-有没有用-npm-发布过-package，如何发布" class="headerlink" title="47.有没有用 npm 发布过 package，如何发布"></a>47.有没有用 npm 发布过 package，如何发布</h3><h3 id="48-什么是-Basic-Auth-和-Digest-Auth"><a href="#48-什么是-Basic-Auth-和-Digest-Auth" class="headerlink" title="48.什么是 Basic Auth 和 Digest Auth"></a>48.什么是 Basic Auth 和 Digest Auth</h3><h3 id="49-gzip-的原理是什么，如何配置"><a href="#49-gzip-的原理是什么，如何配置" class="headerlink" title="49.gzip 的原理是什么，如何配置"></a>49.gzip 的原理是什么，如何配置</h3><h3 id="50-可以对图片开启-gzip-压缩吗，为什么"><a href="#50-可以对图片开启-gzip-压缩吗，为什么" class="headerlink" title="50.可以对图片开启 gzip 压缩吗，为什么"></a>50.可以对图片开启 gzip 压缩吗，为什么</h3><h3 id="51-http-的请求报文与响应报文的格式是什么"><a href="#51-http-的请求报文与响应报文的格式是什么" class="headerlink" title="51.http 的请求报文与响应报文的格式是什么"></a>51.http 的请求报文与响应报文的格式是什么</h3><h3 id="52-http-响应头中的-ETag-值是如何生成的"><a href="#52-http-响应头中的-ETag-值是如何生成的" class="headerlink" title="52.http 响应头中的 ETag 值是如何生成的"></a>52.http 响应头中的 ETag 值是如何生成的</h3><h3 id="53-如果-http-响应头中-ETag-值改变了，是否意味着文件内容一定已经更改"><a href="#53-如果-http-响应头中-ETag-值改变了，是否意味着文件内容一定已经更改" class="headerlink" title="53.如果 http 响应头中 ETag 值改变了，是否意味着文件内容一定已经更改"></a>53.如果 http 响应头中 ETag 值改变了，是否意味着文件内容一定已经更改</h3><h3 id="54-http-服务中静态文件的-Last-Modified-是根据什么生成的"><a href="#54-http-服务中静态文件的-Last-Modified-是根据什么生成的" class="headerlink" title="54.http 服务中静态文件的 Last-Modified 是根据什么生成的"></a>54.http 服务中静态文件的 Last-Modified 是根据什么生成的</h3><h3 id="55-既然-http-是无状态协议，那它是如何保持登录状态"><a href="#55-既然-http-是无状态协议，那它是如何保持登录状态" class="headerlink" title="55.既然 http 是无状态协议，那它是如何保持登录状态"></a>55.既然 http 是无状态协议，那它是如何保持登录状态</h3><h3 id="56-有没有读过-koa-的源码，什么是洋葱模型呢"><a href="#56-有没有读过-koa-的源码，什么是洋葱模型呢" class="headerlink" title="56.有没有读过 koa 的源码，什么是洋葱模型呢"></a>56.有没有读过 koa 的源码，什么是洋葱模型呢</h3><h3 id="57-https-是如何保证报文安全的"><a href="#57-https-是如何保证报文安全的" class="headerlink" title="57.https 是如何保证报文安全的"></a>57.https 是如何保证报文安全的</h3><h3 id="58-我们如何从-http-的报文中得知该服务使用的技术栈"><a href="#58-我们如何从-http-的报文中得知该服务使用的技术栈" class="headerlink" title="58.我们如何从 http 的报文中得知该服务使用的技术栈"></a>58.我们如何从 http 的报文中得知该服务使用的技术栈</h3><h3 id="59-在发送-http-请求报文时，Host-是必要的吗"><a href="#59-在发送-http-请求报文时，Host-是必要的吗" class="headerlink" title="59.在发送 http 请求报文时，Host 是必要的吗"></a>59.在发送 http 请求报文时，Host 是必要的吗</h3><h3 id="60-如何监控文件的变动"><a href="#60-如何监控文件的变动" class="headerlink" title="60.如何监控文件的变动"></a>60.如何监控文件的变动</h3><h3 id="61-localhost-3000-与-localhost-5000-的-cookie-信息是否共享"><a href="#61-localhost-3000-与-localhost-5000-的-cookie-信息是否共享" class="headerlink" title="61.localhost:3000 与 localhost:5000 的 cookie 信息是否共享"></a>61.localhost:3000 与 localhost:5000 的 cookie 信息是否共享</h3><h3 id="62-http-响应头中如果-content-type-为-application-octet-stream，则代表什么意思"><a href="#62-http-响应头中如果-content-type-为-application-octet-stream，则代表什么意思" class="headerlink" title="62.http 响应头中如果 content-type 为 application&#x2F;octet-stream，则代表什么意思"></a>62.http 响应头中如果 content-type 为 application&#x2F;octet-stream，则代表什么意思</h3><h3 id="63-http-向-https-做重定向应该使用哪个状态码"><a href="#63-http-向-https-做重定向应该使用哪个状态码" class="headerlink" title="63.http 向 https 做重定向应该使用哪个状态码"></a>63.http 向 https 做重定向应该使用哪个状态码</h3><h3 id="64-js-代码压缩-minify-的原理是什么"><a href="#64-js-代码压缩-minify-的原理是什么" class="headerlink" title="64.js 代码压缩 minify 的原理是什么"></a>64.js 代码压缩 minify 的原理是什么</h3><h3 id="65-在-Node-应用中如何利用多核心CPU的优势"><a href="#65-在-Node-应用中如何利用多核心CPU的优势" class="headerlink" title="65.在 Node 应用中如何利用多核心CPU的优势"></a>65.在 Node 应用中如何利用多核心CPU的优势</h3><h3 id="66-Node-中-cluster-的原理是什么"><a href="#66-Node-中-cluster-的原理是什么" class="headerlink" title="66.Node 中 cluster 的原理是什么"></a>66.Node 中 cluster 的原理是什么</h3><h3 id="67-http-响应头中的-Date-与-Last-Modified-有什么不同，网站部署时需要注意什么"><a href="#67-http-响应头中的-Date-与-Last-Modified-有什么不同，网站部署时需要注意什么" class="headerlink" title="67.http 响应头中的 Date 与 Last-Modified 有什么不同，网站部署时需要注意什么"></a>67.http 响应头中的 Date 与 Last-Modified 有什么不同，网站部署时需要注意什么</h3><h3 id="68-react-hooks-中如何模拟-componentDidMount"><a href="#68-react-hooks-中如何模拟-componentDidMount" class="headerlink" title="68.react hooks 中如何模拟 componentDidMount"></a>68.react hooks 中如何模拟 componentDidMount</h3><h3 id="69-http-1-1-中的-keep-alive-有什么作用"><a href="#69-http-1-1-中的-keep-alive-有什么作用" class="headerlink" title="69.http 1.1 中的 keep-alive 有什么作用"></a>69.http 1.1 中的 keep-alive 有什么作用</h3><h3 id="70-如果使用-SSR，可以在-created-componentWillMount-中访问-localStorage-吗"><a href="#70-如果使用-SSR，可以在-created-componentWillMount-中访问-localStorage-吗" class="headerlink" title="70.如果使用 SSR，可以在 created&#x2F;componentWillMount 中访问 localStorage 吗"></a>70.如果使用 SSR，可以在 created&#x2F;componentWillMount 中访问 localStorage 吗</h3><h3 id="71-当在浏览器中看到某资源使用了-http2-后，使用-curl-为什么看到的仍是-http-1-1"><a href="#71-当在浏览器中看到某资源使用了-http2-后，使用-curl-为什么看到的仍是-http-1-1" class="headerlink" title="71.当在浏览器中看到某资源使用了 http2 后，使用 curl 为什么看到的仍是 http 1.1"></a>71.当在浏览器中看到某资源使用了 http2 后，使用 curl 为什么看到的仍是 http 1.1</h3><h3 id="72-关于-JSON，以下代码输出什么"><a href="#72-关于-JSON，以下代码输出什么" class="headerlink" title="72.关于 JSON，以下代码输出什么"></a>72.关于 JSON，以下代码输出什么</h3><h3 id="73-什么是队首阻塞，如何解决，原理如何"><a href="#73-什么是队首阻塞，如何解决，原理如何" class="headerlink" title="73.什么是队首阻塞，如何解决，原理如何"></a>73.什么是队首阻塞，如何解决，原理如何</h3><h3 id="74-react-hooks-如何替代或部分替代-redux-功能"><a href="#74-react-hooks-如何替代或部分替代-redux-功能" class="headerlink" title="74.react hooks 如何替代或部分替代 redux 功能"></a>74.react hooks 如何替代或部分替代 redux 功能</h3><h3 id="75-如何实现一个-react-hook，你有没有自己写过一个"><a href="#75-如何实现一个-react-hook，你有没有自己写过一个" class="headerlink" title="75.如何实现一个 react hook，你有没有自己写过一个"></a>75.如何实现一个 react hook，你有没有自己写过一个</h3><h3 id="76-权限设计中的-RABC-是指什么"><a href="#76-权限设计中的-RABC-是指什么" class="headerlink" title="76.权限设计中的 RABC 是指什么"></a>76.权限设计中的 RABC 是指什么</h3><h3 id="77-在-react-vue-中数组是否可以以在数组中的次序为-key"><a href="#77-在-react-vue-中数组是否可以以在数组中的次序为-key" class="headerlink" title="77.在 react&#x2F;vue 中数组是否可以以在数组中的次序为 key"></a>77.在 react&#x2F;vue 中数组是否可以以在数组中的次序为 key</h3><h3 id="78-如何进行代码质量检测"><a href="#78-如何进行代码质量检测" class="headerlink" title="78.如何进行代码质量检测"></a>78.如何进行代码质量检测</h3><h3 id="79-什么是-CSRF-攻击"><a href="#79-什么是-CSRF-攻击" class="headerlink" title="79.什么是 CSRF 攻击"></a>79.什么是 CSRF 攻击</h3><h3 id="80-如何设置一个-cookie"><a href="#80-如何设置一个-cookie" class="headerlink" title="80.如何设置一个 cookie"></a>80.如何设置一个 cookie</h3><h3 id="81-如何删除一个-cookie"><a href="#81-如何删除一个-cookie" class="headerlink" title="81.如何删除一个 cookie"></a>81.如何删除一个 cookie</h3><h3 id="82-React-中-fiber-是用来做什么的"><a href="#82-React-中-fiber-是用来做什么的" class="headerlink" title="82.React 中 fiber 是用来做什么的"></a>82.React 中 fiber 是用来做什么的</h3><h3 id="83-在-js-中如何把类数组转化为数组"><a href="#83-在-js-中如何把类数组转化为数组" class="headerlink" title="83.在 js 中如何把类数组转化为数组"></a>83.在 js 中如何把类数组转化为数组</h3><h3 id="84-Array-100-map-x-1-结果是多少"><a href="#84-Array-100-map-x-1-结果是多少" class="headerlink" title="84.Array(100).map(x &#x3D;&gt; 1) 结果是多少"></a>84.Array(100).map(x &#x3D;&gt; 1) 结果是多少</h3><h3 id="85-如何使用-css-写一个魔方"><a href="#85-如何使用-css-写一个魔方" class="headerlink" title="85.如何使用 css 写一个魔方"></a>85.如何使用 css 写一个魔方</h3><h3 id="86-如何在-url-中传递数组"><a href="#86-如何在-url-中传递数组" class="headerlink" title="86.如何在 url 中传递数组"></a>86.如何在 url 中传递数组</h3><h3 id="87-如何使用-css-写一个有-3D-效果的立方体"><a href="#87-如何使用-css-写一个有-3D-效果的立方体" class="headerlink" title="87.如何使用 css 写一个有 3D 效果的立方体"></a>87.如何使用 css 写一个有 3D 效果的立方体</h3><h3 id="88-如何实现-compose-函数，进行函数合成"><a href="#88-如何实现-compose-函数，进行函数合成" class="headerlink" title="88.如何实现 compose 函数，进行函数合成"></a>88.如何实现 compose 函数，进行函数合成</h3><h3 id="89-有没有使用过-css-variable，它解决了哪些问题"><a href="#89-有没有使用过-css-variable，它解决了哪些问题" class="headerlink" title="89.有没有使用过 css variable，它解决了哪些问题"></a>89.有没有使用过 css variable，它解决了哪些问题</h3><h3 id="90-谈谈你对-styled-component-的看法"><a href="#90-谈谈你对-styled-component-的看法" class="headerlink" title="90.谈谈你对 styled-component 的看法"></a>90.谈谈你对 styled-component 的看法</h3><h3 id="91-performance-API-中什么指标可以衡量首屏时间"><a href="#91-performance-API-中什么指标可以衡量首屏时间" class="headerlink" title="91.performance API 中什么指标可以衡量首屏时间"></a>91.performance API 中什么指标可以衡量首屏时间</h3><h3 id="92-使用-CSS-如何画一个三角形"><a href="#92-使用-CSS-如何画一个三角形" class="headerlink" title="92.使用 CSS 如何画一个三角形"></a>92.使用 CSS 如何画一个三角形</h3><h3 id="93-什么是-Open-Graph-协议，用来做什么"><a href="#93-什么是-Open-Graph-协议，用来做什么" class="headerlink" title="93.什么是 Open Graph 协议，用来做什么"></a>93.什么是 Open Graph 协议，用来做什么</h3><h3 id="94-简述你们前端项目中资源的缓存配置策略"><a href="#94-简述你们前端项目中资源的缓存配置策略" class="headerlink" title="94.简述你们前端项目中资源的缓存配置策略"></a>94.简述你们前端项目中资源的缓存配置策略</h3><h3 id="95-如何加速-npm-install"><a href="#95-如何加速-npm-install" class="headerlink" title="95.如何加速 npm install"></a>95.如何加速 npm install</h3><h3 id="96-npm-i-与-npm-ci-的区别是什么"><a href="#96-npm-i-与-npm-ci-的区别是什么" class="headerlink" title="96.npm i 与 npm ci 的区别是什么"></a>96.npm i 与 npm ci 的区别是什么</h3><h3 id="97-package-lock-json-有什么作用，如果项目中没有它会怎么样，举例说明"><a href="#97-package-lock-json-有什么作用，如果项目中没有它会怎么样，举例说明" class="headerlink" title="97.package-lock.json 有什么作用，如果项目中没有它会怎么样，举例说明"></a>97.package-lock.json 有什么作用，如果项目中没有它会怎么样，举例说明</h3><h3 id="98-前端中遇到过处理二进制的场景吗"><a href="#98-前端中遇到过处理二进制的场景吗" class="headerlink" title="98.前端中遇到过处理二进制的场景吗"></a>98.前端中遇到过处理二进制的场景吗</h3><h3 id="99-什么是-TypedArray"><a href="#99-什么是-TypedArray" class="headerlink" title="99.什么是 TypedArray"></a>99.什么是 TypedArray</h3><h3 id="100-如何实现类似-lodash-get-函数"><a href="#100-如何实现类似-lodash-get-函数" class="headerlink" title="100.如何实现类似 lodash.get 函数"></a>100.如何实现类似 lodash.get 函数</h3><h3 id="101-前端如何进行多分支部署"><a href="#101-前端如何进行多分支部署" class="headerlink" title="101.前端如何进行多分支部署"></a>101.前端如何进行多分支部署</h3><h3 id="102"><a href="#102" class="headerlink" title="102."></a>102.</h3><h3 id="103"><a href="#103" class="headerlink" title="103."></a>103.</h3><h3 id="104"><a href="#104" class="headerlink" title="104."></a>104.</h3><h3 id="105"><a href="#105" class="headerlink" title="105."></a>105.</h3><h3 id="106"><a href="#106" class="headerlink" title="106."></a>106.</h3><h3 id="107"><a href="#107" class="headerlink" title="107."></a>107.</h3><h3 id="108"><a href="#108" class="headerlink" title="108."></a>108.</h3><h3 id="109"><a href="#109" class="headerlink" title="109."></a>109.</h3><h3 id="110"><a href="#110" class="headerlink" title="110."></a>110.</h3>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>前端常见问题总结</div>
      <div>https://easywz.github.io/2025/03/25/Interview/OftenMeetTest/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>汪邹</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年3月25日</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>更新于</div>
          <div>2025年9月4日</div>
        </div>
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
<!-- hexo injector body_end start --><script src="/js/scrollTop.js"></script><!-- hexo injector body_end end --></body>
</html>
