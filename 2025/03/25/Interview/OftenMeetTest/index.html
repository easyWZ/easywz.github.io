

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/index/bk.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="wang zou">
  <meta name="keywords" content="">
  
    <meta name="description" content="前端常见面试题总结">
<meta property="og:type" content="article">
<meta property="og:title" content="前端常见面试题总结">
<meta property="og:url" content="https://easywz.github.io/2025/03/25/Interview/OftenMeetTest/index.html">
<meta property="og:site_name" content="WZ&#39;s blog">
<meta property="og:description" content="前端常见面试题总结">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://easywz.github.io/img/interview/qdms.jpg">
<meta property="article:published_time" content="2025-03-25T02:07:11.000Z">
<meta property="article:modified_time" content="2025-03-26T03:57:18.488Z">
<meta property="article:author" content="wang zou">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://easywz.github.io/img/interview/qdms.jpg">
  
  
  
  <title>前端常见面试题总结 - WZ&#39;s blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"easywz.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>人生在勤，不索何获</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/index/home-1.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="前端常见面试题总结"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-03-25 10:07" pubdate>
          2025年3月25日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          3.7k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          31 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">前端常见面试题总结</h1>
            
            
              <div class="markdown-body">
                
                <h3 id="1-网站开发中，如何实现图片的懒加载"><a href="#1-网站开发中，如何实现图片的懒加载" class="headerlink" title="1.网站开发中，如何实现图片的懒加载"></a>1.网站开发中，如何实现图片的懒加载</h3><ol>
<li>如何控制图片的加载<ol>
<li>设置一个临时 Data 属性 data-src，控制加载时使用 src 代替 data-src</li>
<li><code>&lt;img data-src=&quot;shanyue.jpg&quot; /&gt;</code></li>
<li><code>img.src = img.datset.src</code></li>
</ol>
</li>
<li>判断图片出现在当前视口<ol>
<li>Element.getBoundingClientRect() 方法返回元素的大小及其相对于视口的位置。 <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart"> <span class="hljs-comment">// clientHeight 代表当前视口的高度</span><br>img.getBoundingClientRect().top &lt; <span class="hljs-built_in">document</span>.documentElement.clientHeight;<br></code></pre></td></tr></table></figure></li>
<li>IntersectionObserver API，一个能够监听元素是否到了当前视口的事件<ol>
<li>entry.isIntersecting 代表目标元素可见</li>
<li>IntersectionObserver 除了给图片做懒加载外，还可以对单页应用资源做预加载。如在 next.js v9 中，会对视口内的资源做预加载 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> observer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntersectionObserver</span>(<span class="hljs-function">(<span class="hljs-params">changes</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// changes: 目标元素集合</span><br>  changes.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">change</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// intersectionRatio</span><br>    <span class="hljs-keyword">if</span> (change.<span class="hljs-property">isIntersecting</span>) &#123;<br>      <span class="hljs-keyword">const</span> img = change.<span class="hljs-property">target</span>;<br>      img.<span class="hljs-property">src</span> = img.<span class="hljs-property">dataset</span>.<span class="hljs-property">src</span>;<br>      observer.<span class="hljs-title function_">unobserve</span>(img);<br>    &#125;<br>  &#125;);<br>&#125;);<br> <br>observer.<span class="hljs-title function_">observe</span>(img);<br></code></pre></td></tr></table></figure></li>
</ol>
</li>
<li>LazyLoading属性<ol>
<li><code>&lt;img src=&quot;shanyue.jpg&quot; loading=&quot;lazy&quot; /&gt;</code></li>
<li>不过目前浏览器兼容性不太好</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="2-什么是防抖和节流，他们的应用场景有哪些"><a href="#2-什么是防抖和节流，他们的应用场景有哪些" class="headerlink" title="2.什么是防抖和节流，他们的应用场景有哪些"></a>2.什么是防抖和节流，他们的应用场景有哪些</h3><ol>
<li>防抖相当于回城，每次被打断，就需要重新执行回城的操作，只有真正不受干扰时才能完成回城</li>
<li>节流相当于技能冷却，在施放了一次技能操作后，只有等到规定时间后才能施放下一次技能</li>
<li>防抖(debounce)<ol>
<li>触发高频事件后n秒内函数只会执行一次，如果n秒内高频事件再次被触发，则重新计算时间</li>
<li>示例代码 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 防抖函数</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">fn, wait</span>) &#123;<br>      <span class="hljs-keyword">let</span> timer;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">let</span> _this = <span class="hljs-variable language_">this</span>;<br>        <span class="hljs-keyword">let</span> args = <span class="hljs-variable language_">arguments</span>;<br>        <span class="hljs-keyword">if</span> (timer) &#123;<br>          <span class="hljs-built_in">clearTimeout</span>(timer);<br>        &#125;<br>        timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>          fn.<span class="hljs-title function_">apply</span>(_this, args);<br>        &#125;, wait);<br>      &#125;;<br>    &#125;<br>    <span class="hljs-comment">// 使用</span><br>    <span class="hljs-variable language_">window</span>.<span class="hljs-property">onresize</span> = <span class="hljs-title function_">debounce</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;resize&quot;</span>);<br>    &#125;, <span class="hljs-number">500</span>);<br></code></pre></td></tr></table></figure></li>
<li>应用场景<ol>
<li>登录、发短信等按钮避免用户点击太快，以致于发送了多次请求，需要防抖</li>
<li>调整浏览器窗口大小时，resize 次数过于频繁，造成计算过多，此时需要一次到位</li>
<li>文本编辑器实时保存，当无任何更改操作一秒后进行保存</li>
</ol>
</li>
</ol>
</li>
<li>节流(throttle)<ol>
<li>高频事件触发，但在n秒内只会执行一次，所以节流会稀释函数的执行频率</li>
<li>示例代码 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 方式1: 使用时间戳</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle1</span>(<span class="hljs-params">fn, wait</span>) &#123;<br>  <span class="hljs-keyword">let</span> time = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> _this = <span class="hljs-variable language_">this</span>;<br>    <span class="hljs-keyword">let</span> args = <span class="hljs-variable language_">arguments</span>;<br>    <span class="hljs-keyword">let</span> now = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>    <span class="hljs-keyword">if</span> (now - time &gt; wait) &#123;<br>      fn.<span class="hljs-title function_">apply</span>(_this, args);<br>      time = now;<br>    &#125;<br>  &#125;;<br>&#125;<br><span class="hljs-comment">// 方式2: 使用定时器</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">thorttle2</span>(<span class="hljs-params">fn, wait</span>) &#123;<br>  <span class="hljs-keyword">let</span> timer;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> _this = <span class="hljs-variable language_">this</span>;<br>    <span class="hljs-keyword">let</span> args = <span class="hljs-variable language_">arguments</span>;<br> <br>    <span class="hljs-keyword">if</span> (!timer) &#123;<br>      timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        timer = <span class="hljs-literal">null</span>;<br>        fn.<span class="hljs-title function_">apply</span>(_this, args);<br>      &#125;, wait);<br>    &#125;<br>  &#125;;<br>&#125;<br><br></code></pre></td></tr></table></figure></li>
<li>场景<ol>
<li>scroll 事件，每隔一秒计算一次位置信息等</li>
<li>浏览器播放事件，每个一秒计算一次进度信息等</li>
<li>input 框实时搜索并发送请求展示下拉列表，每隔一秒发送一次请求 (也可做防抖)</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="3-当新入职一家公司时，如何快速搭建开发环境并让应用跑起来"><a href="#3-当新入职一家公司时，如何快速搭建开发环境并让应用跑起来" class="headerlink" title="3.当新入职一家公司时，如何快速搭建开发环境并让应用跑起来"></a>3.当新入职一家公司时，如何快速搭建开发环境并让应用跑起来</h3><h3 id="4-如何实现一个元素的水平垂直居中"><a href="#4-如何实现一个元素的水平垂直居中" class="headerlink" title="4.如何实现一个元素的水平垂直居中"></a>4.如何实现一个元素的水平垂直居中</h3><ol>
<li>绝对定位方法： <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>  postion: absolute;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">bottom</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">50px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>, -<span class="hljs-number">50%</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>flex方法： <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">justify-content</span>: center;<br>  <span class="hljs-attribute">align-items</span>: center;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>grid <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span>, <span class="hljs-selector-tag">html</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">display</span>: grid;<br>&#125;<br><span class="hljs-selector-tag">span</span> &#123; <span class="hljs-comment">/* thing to center */</span><br>  <span class="hljs-attribute">margin</span>: auto;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="5-了解-React-中的-ErrorBoundary-吗，它有那些使用场景"><a href="#5-了解-React-中的-ErrorBoundary-吗，它有那些使用场景" class="headerlink" title="5.了解 React 中的 ErrorBoundary 吗，它有那些使用场景"></a>5.了解 React 中的 ErrorBoundary 吗，它有那些使用场景</h3><ol>
<li>避免错误渲染白屏做异常中间处理的嵌套组件</li>
</ol>
<h3 id="6-vue3-0-中为什么要使用-Proxy，它相比以前的实现方式有什么改进"><a href="#6-vue3-0-中为什么要使用-Proxy，它相比以前的实现方式有什么改进" class="headerlink" title="6.vue3.0 中为什么要使用 Proxy，它相比以前的实现方式有什么改进"></a>6.vue3.0 中为什么要使用 Proxy，它相比以前的实现方式有什么改进</h3><ol>
<li>改进和优势<ol>
<li><p>更强大和灵活：Proxy 可以代理整个对象，而不仅仅是对象的属性。这意味着您可以监听对象的整个操作，包括属性的增删改查等。而 Object.defineProperty 只能监听对象的属性的读取和赋值操作。</p>
</li>
<li><p>更直观和易用：使用 Proxy 可以更直观地监听对象的操作，而不需要像 Object.defineProperty 那样手动定义 getter 和 setter。这使得代码更加清晰和易于理解。</p>
</li>
<li><p>更好的性能：Proxy 的性能通常比 Object.defineProperty 更好，因为 Proxy 是原生实现的，而 Object.defineProperty 是 JavaScript 引擎的内部实现。Proxy 的底层实现更高效，可以更好地处理大型对象和多次操作。</p>
</li>
<li><p>支持数组变化的检测：使用 Proxy 可以很容易地监听数组的变化，包括数组的 push、pop、splice 等操作。而 Object.defineProperty 难以实现对数组变化的监听。</p>
</li>
</ol>
</li>
<li>Vue2x中使用的是 Object.defineProerty(obj, prop, descriptor)来实现的响应式<ol>
<li>Object.defineProerty<ol>
<li>作用：是在一个对象定义一个新属性，或者修改一个对象的现有属性，并返回一个对象。</li>
<li>参数：<ol>
<li>要添加属性的对象</li>
<li>要定义或修改的属性的名称或 [Symbol]</li>
<li>要定义或修改的属性描述符</li>
</ol>
</li>
<li>这个函数通常是劫持对象中某一个属性，重写该属性的set，get函数，实现对属性的监听。但是在使用的场景中，我们通常需要一次性监听多个属性的变化，甚至需要监听复杂的对象嵌套，这个时候就只能在遍历该对象，并在遍历过程中递归，才可以实现复杂对象的监听。 注意的是这里不能直接遍历监听的obj对象，因为在 get 方法里面，我们在访问 obj身上的属性时，就会触发 get 方法，返回 person[key] ，但是访问 person[key] 也会触发 get 方法，导致异常递归调用，最终栈溢出。 所以这里需要设置一个中转 Observer，来让 get 中 return 的值并不是直接访问 obj[key] 在劫持数组时又有问题，当声明数组后，使用defineProerty只能劫持到声明时候的内容，也就是通过索引访问或者修改数组中已经存在的元素，是可以触发get和set的，但是对于通过push、unshift增加的元素，会增加一个索引，这种情况需要手动初始化，新增加的元素才能被监听到。另外， 通过 pop 或 shift 删除元素，会删除并更新索引，也会触发 setter 和 getter 方法。而且在Vue2.x中，通过重写Array原型上的方法解决了这个问题，此处就不展开说了，有兴趣的可以再去了解下。 事实上，在上面的讲述中，我们还有问题没有解决：那就是当我们要给对象新增加一个属性时，也需要手动去监听这个新增属性。 这也就是vue2为什么要用<code>vm.$set</code>来向数组及对象添加响应式内容，vm.$set简单来说就是重新走一遍上述遍历过程，来保持新增加的属性是响应式。 至此vue2的响应式大概内容说完了，可以看到上述通过 Object.definePorperty() 进行数据监听是比较麻烦的，需要大量的手动处理。</li>
</ol>
</li>
<li>vue3中的Proxy<ol>
<li><code>const p = new Proxy( target, handler );</code></li>
<li>作用：通过Proxy，我们可以对设置代理的对象上的一些操作进行拦截，外界对这个对象的各种操作，都要先通过这层拦截。（和defineProperty差不多）</li>
<li>参数：<ol>
<li>target:要使用 Proxy 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）</li>
<li>handler:一个通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 p 的行为。</li>
</ol>
</li>
<li>Proxy代理的是整个对象，而不是对象的某个特定属性，不需要我们通过遍历来逐个进行数据绑定。 值得注意的是:之前我们在使用Object.defineProperty()给对象添加一个属性之后，我们对对象属性的读写操作仍然在对象本身。 但是一旦使用Proxy，如果想要读写操作生效，我们就要对Proxy的实例对象 p 进行操作。</li>
<li>解决vue2 Object.defineProperty的难题<ol>
<li>一次只能对一个属性进行监听，需要遍历来对所有属性监听。</li>
<li>在遇到一个对象的属性还是一个对象的情况下，需要递归监听</li>
<li>对于对象的新增属性，需要手动监听</li>
<li>对于数组通过push、unshift方法增加的元素，也无法监听 但是看过vue3源码的同学可以发现，vue3的响应式并不是只用了proxy来实现的，还用了一个搭档Reflect。也就是Proxy(代理) 配合 Reflect(反射) 进行设计的。那么就有疑问了 为什么要用上Reflect。</li>
</ol>
</li>
<li>什么是 Reflect ？<ol>
<li>Reflect 其实和 Proxy 一样都是属于 ES6 的高级API，Reflect 也是属于 window 的一个内置类，可以通过 window.Reflect 访问到。</li>
<li>在阅读 Proxy 的 MDN 文档上会发现其实 Proxy 中 get 陷阱中还会存在一个额外的参数 receiver 。 通过上述对 window.Reflect 的打印可以看到，Reflect 的方法、属性和 Proxy 是一样的，所以 Reflect get 也是有这 第三个 receiver 属性的；这个receiver是触发代理对象的劫持时保证正确的 this 上下文指向，它正是可以修改属性访问中的 this 指向为传入的 receiver 对象。也是为了框架健壮性。使用 Object.defineProperty() 重复声明的属性会报错，因为 JavaScript 是单线程语言，一旦抛出异常，后边的任何逻辑都不会执行，所以为了避免这种情况，我们在底层就要写 大量的 try catch 来避免，不够优雅。 但是使用 Reflect.defineProperty() 是有返回值的，所以通过 返回值 来判断你当前操作是否成功。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="7-有没有使用过-react-hooks，它带来了那些便利"><a href="#7-有没有使用过-react-hooks，它带来了那些便利" class="headerlink" title="7.有没有使用过 react hooks，它带来了那些便利"></a>7.有没有使用过 react hooks，它带来了那些便利</h3><ol>
<li>让函数组件拥有状态（useState）<ol>
<li>不需要 this.state，代码更简洁。</li>
</ol>
</li>
<li>代替生命周期函数（useEffect）<ol>
<li>useEffect 代替了 componentDidMount 和 componentWillUnmount，避免写多余的类方法。</li>
<li>支持副作用清理，例如清除定时器、移除事件监听等</li>
</ol>
</li>
<li>复用逻辑（自定义 Hook）<ol>
<li>逻辑复用更简单，不用额外写高阶组件或 render props。</li>
<li>更符合函数式编程。</li>
</ol>
</li>
<li>useRef 让函数组件持有引用<ol>
<li>可以获取 DOM 元素，不需要 document.getElementById()。</li>
<li>存储变量不会触发组件重新渲染（useRef 适用于存储不变的状态）。</li>
</ol>
</li>
<li>useContext 让数据共享更方便<ol>
<li>不需要 props drilling（层层传递 props）。</li>
<li>更轻量级，不用 Redux。</li>
</ol>
</li>
</ol>
<h3 id="8-如何使用-react-hooks-实现一个计数器的组件"><a href="#8-如何使用-react-hooks-实现一个计数器的组件" class="headerlink" title="8.如何使用 react hooks 实现一个计数器的组件"></a>8.如何使用 react hooks 实现一个计数器的组件</h3><h3 id="9-css-如何实现左侧固定300px，右侧自适应的布局"><a href="#9-css-如何实现左侧固定300px，右侧自适应的布局" class="headerlink" title="9.css 如何实现左侧固定300px，右侧自适应的布局"></a>9.css 如何实现左侧固定300px，右侧自适应的布局</h3><ol>
<li>左侧300px；右侧flex: 1; 采用flex的固比模型</li>
<li>Grid 布局<code>.container &#123;   display: grid;   grid-template-columns: 300px 1fr; &#125;</code></li>
<li>使用calc方法 .left{width:330px;} .right{width: calc(100% - 330px)}</li>
</ol>
<h3 id="10-浏览器中如何实现剪切板复制内容的功能"><a href="#10-浏览器中如何实现剪切板复制内容的功能" class="headerlink" title="10.浏览器中如何实现剪切板复制内容的功能"></a>10.浏览器中如何实现剪切板复制内容的功能</h3><ol>
<li>一般可以使用第三方库 clipboard-copy 来实现</li>
<li>推荐的方式是使用 Clipboard API 进行实现<code>navigator.clipboard.writeText(text);</code></li>
<li>对于一些不支持 Clipboard API 的浏览器，使用以下 API 进行复制<ol>
<li>选中: Selection API</li>
<li>复制: document.execCommand (已被废弃)<br>2.复制: execCommand <code>document.execCommand(&quot;copy&quot;);</code></li>
</ol>
</li>
</ol>
<h3 id="11-React-中，cloneElement-与-createElement-各是什么，有什么区别"><a href="#11-React-中，cloneElement-与-createElement-各是什么，有什么区别" class="headerlink" title="11.React 中，cloneElement 与 createElement 各是什么，有什么区别"></a>11.React 中，cloneElement 与 createElement 各是什么，有什么区别</h3><ol>
<li>createElement：React 内部创建虚拟 DOM 的方法，JSX 语法糖的底层实现。<ol>
<li><code>React.createElement(&#39;div&#39;, &#123; className: &#39;box&#39; &#125;, &#39;内容&#39;)</code><ol>
<li>第一个参数是 type 简单来说就是各种 标签名字（包括 HTML 自身的，还有 React 组件名字）</li>
<li>第二个参数是传入的属性</li>
<li>第三个参数以及之后的参数就是作为组件的子组件 JSX 编写的代码就是转换为这个方法，一般用了 JSX 写法都不会再需要自己直接调用 该方法</li>
</ol>
</li>
</ol>
</li>
<li>cloneElement：用于克隆已有组件，并修改 props 或 children，常用于 HOC、插槽模式等。<ol>
<li><code>React.cloneElement(child, &#123; newProp: &#39;value&#39; &#125;)</code><ol>
<li>第一个参数是 一个 React 元素</li>
<li>新添加的属性会并入原有的属性 一般配合 React.children.map使用，如用于动态地给子组件添加更多 props 信息、样式</li>
</ol>
</li>
<li>更深一点的原因在于，React 元素是 不可变对象 例如 props.children 获取到的只是一个 描述符，不能直接修改它的任何属性，只能读取他的信息。 所以我们可以选择拷贝它们，然后再修改、添加</li>
</ol>
</li>
</ol>
<h3 id="12-如何实现一个简单的-Promise"><a href="#12-如何实现一个简单的-Promise" class="headerlink" title="12.如何实现一个简单的 Promise"></a>12.如何实现一个简单的 Promise</h3><ol>
<li>状态管理（pending、fulfilled、rejected）</li>
<li>then 方法（支持异步回调）</li>
<li>resolve 和 reject 机制</li>
<li>支持链式调用</li>
</ol>
<h3 id="13-在前端开发中，如何获取浏览器的唯一标识"><a href="#13-在前端开发中，如何获取浏览器的唯一标识" class="headerlink" title="13.在前端开发中，如何获取浏览器的唯一标识"></a>13.在前端开发中，如何获取浏览器的唯一标识</h3><p>在前端开发中，获取浏览器的唯一标识（Browser Fingerprint）通常用于 用户跟踪、设备识别、防止欺诈 等场景</p>
<ol>
<li><code>navigator.userAgent</code>用户可以修改 userAgent，而且不同浏览器可能返回相似值，不能保证唯一</li>
<li>使用 <code>navigator.deviceMemory + hardwareConcurrency</code>（设备性能特征）,不同浏览器可能返回不同值，仍然不唯一</li>
<li>使用 canvas 指纹（更稳定的浏览器识别方式）<ol>
<li>由于不同的系统显卡绘制 canvas 时渲染参数、抗锯齿等算法不同，因此绘制成图片数据的 CRC 校验也不一样</li>
<li>代码： <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getCanvasFp</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> canvas = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;canvas&quot;</span>);<br>  <span class="hljs-keyword">const</span> ctx = canvas.<span class="hljs-title function_">getContext</span>(<span class="hljs-string">&quot;2d&quot;</span>);<br>  ctx.<span class="hljs-property">font</span> = <span class="hljs-string">&quot;14px Arial&quot;</span>;<br>  ctx.<span class="hljs-property">fillStyle</span> = <span class="hljs-string">&quot;#ccc&quot;</span>;<br>  ctx.<span class="hljs-title function_">fillText</span>(<span class="hljs-string">&quot;hello, shanyue&quot;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>);<br>  <span class="hljs-keyword">return</span> canvas.<span class="hljs-title function_">toDataURL</span>(<span class="hljs-string">&quot;image/jpeg&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
</li>
<li>使用 FingerprintJS（开源库，精确度高）</li>
<li>使用 localStorage 或 indexedDB 存储唯一 ID<ol>
<li>对同一浏览器持久有效</li>
<li>用户清除 localStorage 后会失效</li>
</ol>
</li>
</ol>
<h3 id="14-js-中如何实现-bind"><a href="#14-js-中如何实现-bind" class="headerlink" title="14.js 中如何实现 bind"></a>14.js 中如何实现 bind</h3><ol>
<li>Function.prototype.bind() 的作用是创建一个新的函数，并永久绑定 this 到指定的对象，同时支持预设参数。</li>
<li>作用<ol>
<li>绑定 this</li>
<li>支持柯里化（预设参数）</li>
<li>返回一个新的可调用函数</li>
<li>支持 new 关键字调用</li>
</ol>
</li>
<li>手写bind 核心思路<ol>
<li>返回一个新函数</li>
<li>apply 绑定 this</li>
<li>支持参数预设（柯里化）</li>
<li>支持 new 关键字调用</li>
</ol>
</li>
<li>简易示例 <figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">Function.prototype.myBind = <span class="hljs-keyword">function</span> <span class="hljs-params">(context, <span class="hljs-rest_arg">...args</span>)</span> &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">this</span> !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> TypeError(<span class="hljs-string">&quot;myBind 只能作用于函数&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">const</span> self = <span class="hljs-keyword">this</span>; <span class="hljs-comment">// 保存原函数</span><br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">boundFunction</span><span class="hljs-params">(<span class="hljs-rest_arg">...innerArgs</span>)</span> &#123;<br>    <span class="hljs-comment">// 处理 `new` 关键字调用</span><br>    <span class="hljs-keyword">return</span> self.apply(<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> boundFunction ? <span class="hljs-keyword">this</span> : context, [...args, ...innerArgs]);<br>  &#125;<br><br>  <span class="hljs-comment">// 继承原型，确保 new 调用时不会丢失原函数的 prototype</span><br>  boundFunction.prototype = Object.create(<span class="hljs-keyword">this</span>.prototype);<br><br>  <span class="hljs-keyword">return</span> boundFunction;<br>&#125;;<br></code></pre></td></tr></table></figure></li>
<li>应用场景<ol>
<li>事件监听时绑定 this 默认情况下，this 在事件回调中指向触发事件的 DOM 元素，而不是原始对象。可以用 bind 绑定 this。</li>
<li>在 setTimeout &#x2F; setInterval 里绑定 this JavaScript 的 setTimeout 和 setInterval 默认 this 指向 window，需要用 bind 绑定 this。</li>
<li>在 React 组件中使用 在 React class 组件中，事件回调函数 this 可能会丢失，需要 bind 绑定。</li>
<li>回调函数（如 map()、filter()）</li>
<li>类继承</li>
<li>高阶函数</li>
<li>new 关键字配合 bind</li>
</ol>
</li>
</ol>
<h3 id="15-js-中什么是-softbind，如何实现"><a href="#15-js-中什么是-softbind，如何实现" class="headerlink" title="15.js 中什么是 softbind，如何实现"></a>15.js 中什么是 softbind，如何实现</h3><h3 id="16-如何实现一个-loading-动画"><a href="#16-如何实现一个-loading-动画" class="headerlink" title="16.如何实现一个 loading 动画"></a>16.如何实现一个 loading 动画</h3><h3 id="17-http-常见的状态码有哪些"><a href="#17-http-常见的状态码有哪些" class="headerlink" title="17.http 常见的状态码有哪些"></a>17.http 常见的状态码有哪些</h3><h3 id="18-http-状态码中-301，302和307有什么区别"><a href="#18-http-状态码中-301，302和307有什么区别" class="headerlink" title="18.http 状态码中 301，302和307有什么区别"></a>18.http 状态码中 301，302和307有什么区别</h3><h3 id="19-使用-react-实现一个通用的-message-组件"><a href="#19-使用-react-实现一个通用的-message-组件" class="headerlink" title="19.使用 react 实现一个通用的 message 组件"></a>19.使用 react 实现一个通用的 message 组件</h3><h3 id="20-http-状态码-502-和-504-有什么区别"><a href="#20-http-状态码-502-和-504-有什么区别" class="headerlink" title="20.http 状态码 502 和 504 有什么区别"></a>20.http 状态码 502 和 504 有什么区别</h3><h3 id="21"><a href="#21" class="headerlink" title="21."></a>21.</h3>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>前端常见面试题总结</div>
      <div>https://easywz.github.io/2025/03/25/Interview/OftenMeetTest/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>wang zou</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年3月25日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/10/28/Resources/IELTSvocabulary/" title="雅思必备词汇 &amp;&amp; 计算机英语">
                        <span class="hidden-mobile">雅思必备词汇 &amp;&amp; 计算机英语</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
<!-- hexo injector body_end start --><script src="/js/outdate.js"></script><!-- hexo injector body_end end --></body>
</html>
